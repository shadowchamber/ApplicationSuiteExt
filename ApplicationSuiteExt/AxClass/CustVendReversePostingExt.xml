<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendReversePostingExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendReversePosting</c> class serves as the parent class of a hierarchy of three classes
/// that is the engine for reverse settlements of customer and vendor transactions.
/// </summary>
/// <remarks>
/// This reverse settlement can be performed from the customer or vendor table form.
/// </remarks>
public abstract class CustVendReversePostingExt implements SysSaveable
{
    Common                          common;
    CustVendTrans                   custVendTrans;
    CustVendTrans                   custVendTransOffset;
    CustVendSettlement              custVendSettlement;
    SpecTrans                       specTrans;
    CustVendTransOpen               custVendTransOpen;

    LedgerVoucherGroup              ledgerVoucherGroup;
    LedgerVoucher                   ledgerVoucher;
    Voucher                         parentVoucher;
    Voucher                         voucher;
    SettleDatePrinc                 datePrinciple;

    LedgerDimensionDefaultAccount   custVendLedgerDimension;
    LedgerDimensionDefaultAccount   discountLedgerDimension;
    LedgerDimensionDefaultAccount   pennyDiffLedgerDimension;
    LedgerDimensionDefaultAccount   exchAdjLedgerDimension;

    LedgerPostingType               cashDiscPostingType;
    LedgerPostingType               exchAdjustmentPostingType;
    TaxAmount                       taxAmount;

    TransDate                       diffTransDate; //date for discounts and differences
    container                       taxReverse;
    container                       conLedgerAccount;
    container                       conTaxBaseAmountCur;
    container                       taxTransRecId;
    AmountCur                       taxPctAccumulat;//accumulate of tax percent using in prepayment

    AmountMST                       totalUnrealizedExchAdjCustVendTrans;
    AmountMST                       totalUnrealizedExchAdjCustVendTransOffset;
    AmountMSTSecondary              totalUnrealizedReportingExchAdjCustVendTrans;
    AmountMSTSecondary              totalUnrealizedReportingExchAdjCustVendTransOffset;
    AmountMST                       totalRealizedExchAdjCustVendTrans;
    AmountMST                       totalRealizedExchAdjCustVendTransOffset;
    AmountMSTSecondary              totalRealizedReportingExchAdjCustVendTrans;
    AmountMSTSecondary              totalRealizedReportingExchAdjCustVendTransOffset;
    RefRecId                        custVendTransRecId;
    RefRecId                        custVendTransOffsetRecId;

    SysModule                       module;
    boolean                         isReversalForSettlementGroupComplete;
    boolean                         isFirstReversalForSettlementGroup;
    Counter                         settlementGroupPlaceHolder;
    CustVendTransSettlement         custVendTransSettlement;
    container                       tax1099VendTrans;   //Contains RECID's of all VendTrans records processed plus settlement amounts for the transactions
    Map                             numberSeqMap;
    Map                             ledgerVoucherObjectMap;
    #ISOCountryRegionCodes

    // <GTH>
    boolean                         isTaxWithholdEnabled_TH;
    // </GTH>
    
    // <GGB>
    boolean                         countryRegionGB;
    // </GGB>
    boolean                         countryRegion_SAIE;

    // <GEERU>
    RTax25DebtDebitReverse          debitReverse;
    RTax25DebtCreditReverse         creditReverse;
    CustVendExchAdjParm_W           custVendExchAdjParm;
    CustVendTransPostingLogType_RU  custVendTransPostingLogType;
    Set                             reversePostingLogSet;

    TransDate              saveDate;
    TransDate              transactionDate;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        datePrinciple,
        saveDate
    #ENDMACRO
    // </GEERU>

    // <GBR>
    Voucher             paymentVoucher_BR;
    // </GBR>
    Set                 reverseVoucherProcessed;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createReverseTax1099Settlement</Name>
				<Source><![CDATA[
      /// <summary>
      ///    Creates transactions to reverse a 1099 tax transaction.
      /// </summary>
      /// <param name="_vendSettlementTax1099">
      ///    The <c>vendSettlementTax1099</c> record for which a reverse entry is being created.
      /// </param>
      /// <remarks>
      ///    This method will create the appropriate reversing <c>VendSettlementTax1099</c> record.
      /// </remarks>
      private void createReverseTax1099Settlement(vendSettlementTax1099 _vendSettlementTax1099)
      {        
        VendSettlementTax1099       vendSettlementTax1099Offset;
        changecompany(_vendSettlementTax1099.company())
        {
            // Create reversing vendSettlementTax1099 entry
            vendSettlementTax1099Offset.clear();
            vendSettlementTax1099Offset = _vendSettlementTax1099.data();

            vendSettlementTax1099Offset.TransDate = this.parmTransDate();

            vendSettlementTax1099Offset.SettleTax1099Amount = -vendSettlementTax1099Offset.SettleTax1099Amount;
            vendSettlementTax1099Offset.SettleTax1099StateAmount = -vendSettlementTax1099Offset.SettleTax1099StateAmount;
            
            //if this is an S-record we want to delete the entire entry because 0 is a valid amount for S.
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) 
                && vendSettlementTax1099Offset.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099S::grossProceeds())
                && vendSettlementTax1099Offset.Tax1099Fields != 0)
            {
                vendSettlementTax1099Offset.selectForUpdate(true);
                vendSettlementTax1099Offset.delete();                
            }
            else
            {
                vendSettlementTax1099Offset.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExchAdjValuesToTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the sum of the exchange adjustment values for a record.
    /// </summary>
    /// <param name="_custVendTransToReverse">
    ///    The <c>CustVendTrans</c> map that contains the values to reverse.
    /// </param>
    protected void addExchAdjValuesToTotal(CustVendTrans _custVendTransToReverse)
    {
        // If the CustVendTrans contains an realized or unrealized exch adjustment
        // accumulate the amounts, and set the transaction rec id.
        // These amounts will be used to update the Trans and TransOpen records.
        if (_custVendTransToReverse.OffsetRecId == custVendTrans.RecId)
        {
            custVendTransRecId = _custVendTransToReverse.OffsetRecId;
            totalUnrealizedExchAdjCustVendTrans += _custVendTransToReverse.ExchAdjustmentUnrealized;
            totalRealizedExchAdjCustVendTrans += _custVendTransToReverse.ExchAdjustmentRealized;

            totalUnrealizedReportingExchAdjCustVendTrans += _custVendTransToReverse.ReportingExchAdjustmentUnrealized;
            totalRealizedReportingExchAdjCustVendTrans += _custVendTransToReverse.ReportingExchAdjustmentRealized;
        }
        else if (_custVendTransToReverse.OffsetRecId == custVendTransOffset.RecId)
        {
            custVendTransOffsetRecId = _custVendTransToReverse.OffsetRecId;
            totalUnrealizedExchAdjCustVendTransOffset += _custVendTransToReverse.ExchAdjustmentUnrealized;
            totalRealizedExchAdjCustVendTransOffset += _custVendTransToReverse.ExchAdjustmentRealized;

            totalUnrealizedReportingExchAdjCustVendTransOffset += _custVendTransToReverse.ReportingExchAdjustmentUnrealized;
            totalRealizedReportingExchAdjCustVendTransOffset += _custVendTransToReverse.ReportingExchAdjustmentRealized;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeReversed_RU</Name>
				<Source><![CDATA[
    protected boolean canBeReversed_RU(CustVendSettlement _custVendSettlement)
    {
        CustVendTransPostingLog_RU  postingLog;
        boolean                     ret;
        select firstonly RecId from postingLog
            where postingLog.PostingLogType     == CustVendTransPostingLogType_RU::Prepayment &&
                  postingLog.TransDate          == _custVendSettlement.TransDate              &&
                  ((postingLog.TransRecId       == _custVendSettlement.TransRecId             &&
                    postingLog.TransCompany     == _custVendSettlement.TransCompany           &&
                    postingLog.OffSetRecId      == _custVendSettlement.OffsetRecId            &&
                    postingLog.OffsetCompany    == _custVendSettlement.OffsetCompany)         ||
                   (postingLog.TransRecId       == _custVendSettlement.OffsetRecId            &&
                    postingLog.TransCompany     == _custVendSettlement.OffsetCompany          &&
                    postingLog.OffSetRecId      == _custVendSettlement.TransRecId             &&
                    postingLog.OffsetCompany    == _custVendSettlement.TransCompany));

        if (! postingLog.RecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscountLedgerDimension</Name>
				<Source><![CDATA[
    public abstract LedgerDimensionDefaultAccount cashDiscountLedgerDimension(CustVendTrans _vendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscVat</Name>
				<Source><![CDATA[
    public abstract boolean cashDiscVat()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverdueJournal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if overdue journal exists, then takes the date of last journal and
    /// validates that overdue debt amount on that date will not be changed by reverse settlement operation.
    /// </summary>
    /// <returns>
    /// True if check succeed(overdue debt will not change); Otherwise fase.
    /// </returns>
    /// <remarks>
    /// This check can be disabled by unmarking validate checkbox on <c>OverdueJournalSettings_W</c> form.
    /// </remarks>
    protected boolean checkOverdueJournal_W()
    {
        boolean ret = true;
        if (custVendTrans.Invoice)
        {
            ret = OverdueJournalSettings_W::canTransactionBePosted(
                custVendTrans,
                custVendTrans.TransDate,
                custVendSettlement.DueDate,
                transactionDate);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditNoteForCashDiscount_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method creates credit note <c>CustInvoiceJour</c> and <c>CustInvoiceTrans</c>
    ///     for reverse discount transaction <c>CustTrans</c>
    /// </summary>
    /// <param name="_custTrans">
    ///     Source  <c>CustTrans</c> record for reverce discount transaction
    /// </param>
    /// <param name="_reversedDiscTrans">
    ///     Reverse discount transaction - <c>CustTrans</c> record
    /// </param>
    /// <remarks>
    ///     Reverse document is used only for the reporting and for Czech Republic
    /// </remarks>
    protected void createCreditNoteForCashDiscount_CZ(
        CustVendTrans   _custTrans,
        CustVendTrans   _reversedDiscTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendSettleRef_RU</Name>
				<Source><![CDATA[
    public container custVendSettleRef_RU(
        CustVendSettlement             _custVendSettlement,
        CustVendTransPostingLogType_RU _custVendTransPostingLogType)
    {
        CustVendTransPostingLog_RU postingLog;
        container                  con;
        RefTableId                 refTableId = _custVendSettlement.TableId == tableNum(CustSettlement) ? tableNum(CustTrans) : tableNum(VendTrans);

        while select sum(AmountMST), sum(SettlementExchAdj), sum(AmountMSTSecond), sum(ReportingSettlementExchAdj) from postingLog
            group by TransDate, Voucher
            where postingLog.RefTableId             == refTableId
               && postingLog.TransRecId             == _custVendSettlement.TransRecId
               && postingLog.TransCompany           == _custVendSettlement.TransCompany
               && postingLog.OffSetRecId            == _custVendSettlement.OffsetRecId
               && postingLog.OffsetCompany          == _custVendSettlement.OffsetCompany
               && postingLog.TransDate              == _custVendSettlement.TransDate
               && postingLog.Reversed               == NoYes::No
               && postingLog.PostingLogType         == _custVendTransPostingLogType
               && postingLog.IsReportingCurrencyTax == NoYes::No
        {
            con += [[   postingLog.TransDate,
                        postingLog.Voucher,
                        postingLog.AmountMST,
                        postingLog.SettlementExchAdj,
                        postingLog.AmountMSTSecond,
                        postingLog.ReportingSettlementExchAdj]];
        }

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBankChequePaymTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes <c>BankChequePaymTrans</c> records linked to the transaction being reversed.
    /// </summary>
    protected void deleteBankChequePaymTrans()
    {
        BankChequePaymTrans deleteBankChequePaymTrans;

        delete_from deleteBankChequePaymTrans
            where deleteBankChequePaymTrans.InvoiceTransDate == custVendTrans.TransDate &&
                deleteBankChequePaymTrans.InvoiceVoucher == custVendTrans.Voucher &&
                deleteBankChequePaymTrans.ChequeNum == custVendTrans.PaymReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogDatePrinciple_W</Name>
				<Source><![CDATA[
    public boolean dialogDatePrinciple_W()
    {
        DialogField         dialogDatePrinciple;
        DialogField         dialogDate;
        Dialog              dialog = DialogRunbase::newOnClient("@SYS25511",null);
        FormComboBoxControl datePrincipleControl;
        xSysLastValue::getLast(this);

        dialogDatePrinciple = dialog.addField(enumStr(SettleDatePrinc),"@SYS117110" ,"@SYS117109");
        dialogDate          = dialog.addFieldValue(extendedTypeStr(TransDate), saveDate, "@SYS10396", "@SYS70502");
        dialog.doRun();
        datePrincipleControl = dialogDatePrinciple.control();
        datePrincipleControl.delete(enum2str(SettleDatePrinc::DateOfPayment));
        datePrincipleControl.insert("@SYS16693",0);
        datePrincipleControl.selection(datePrinciple);
        dialog.wait();
        if (dialog.closedOk())
        {
            datePrinciple   = dialogDatePrinciple.value();
            saveDate        = dialogDate.value();

            xSysLastValue::saveLast(this);

            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtCustVend</Name>
				<Source><![CDATA[
    public abstract LedgerTransTxt discTxtCustVend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjTxt</Name>
				<Source><![CDATA[
    public abstract LedgerTransTxt exchAdjTxt(LedgerJournalACType _ledgerJournalACType = LedgerJournalACType::Ledger)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoice</Name>
				<Source><![CDATA[
    public abstract CustVendInvoiceJour findInvoice(CustVendAC  _custVendAC,
                                             InvoiceId   _invoiceId,
                                             Voucher     _voucher,
                                             TransDate   _transDate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerVoucherByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>LedgerVoucher</c> instance for the current company.
    /// </summary>
    /// <returns>
    ///    The <c>LedgerVoucher</c> instance for the company.
    /// </returns>
    /// <remarks>
    ///    This method will create a new <c>LedgerVoucher</c> instance if one does not exist for the current
    ///    company.
    /// </remarks>
    protected LedgerVoucher findLedgerVoucherByCompany()
    {
        LedgerVoucherObject     ledgerVoucherObject;
        NumberSequenceCode      numberSequenceCode;
        NumberSeq               numberSeq;
        CompanyId               currentCompany = curext();
        TaxWithholdTrans        taxWithholdTrans;
        boolean                 utFound = false;
        // <GEEU>
        boolean                 usePostingLog = CustVendTransPostingLog_RU::usePostingLog();
        // </GEEU>

        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(custVendTrans);
        }

        // When an invoice and payment are fully settled there is no need to create ledger trans records.
        // In this case we don't want to burn voucher numbers.  This is indicated by an empty SettlementVoucher
        // when the SettlementGroup is non-zero.  The "old" code path (SettlementGroup == 0) will continue
        // to use journal numbers as it has in the past.  A voucher number will be needed if tax withholding
        // information exists, so that case must be included as well.
        if (custVendSettlement.SettlementVoucher == ''
            && custVendSettlement.SettlementGroup != 0
            && !taxWithholdTrans
            // <GEERU><GEECZ>
            && utFound == false
            && ! CustVendTransPostingLog_RU::usePostingLog())
            // </GEECZ></GEERU>
        {
            return null;
        }

        numberSequenceCode = this.findNumberSequenceCodeByCompany();

        ledgerVoucher = ledgerVoucherGroup.findLedgerVoucher(currentCompany, numberSequenceCode);

        if (ledgerVoucher == null)
        {
            // Create a company-specific ledgerVoucher class and add it to the
            // ledger voucher group
            ledgerVoucher = LedgerVoucher::newLedgerPost(
                DetailSummary::Detail,
                this.getModule(),
                numberSequenceCode);

            ledgerVoucher.lastTransDate(diffTransDate);
            ledgerVoucher.parmCheckBlockedDimensions(false);
            ledgerVoucher.parmCompanyId(currentCompany);
            ledgerVoucher.parmReversal(true);
            ledgerVoucherGroup.addLedgerVoucher(ledgerVoucher);
        }

        // The ledgerVoucherObjectMap is reset for each settlement group, which prevents
        // the same voucher from being used for the same company, but different settlement groups.
        if (ledgerVoucherObjectMap.exists(currentCompany))
        {
            ledgerVoucherObject = ledgerVoucherObjectMap.lookup(currentCompany);
        }
        else
        {
            // Add a new voucher to the ledgerVoucher and cache

            numberSeq = NumberSeq::newGetVoucher(this.getNumberSeqRef());

            // Create a new LedgerVoucherObject because transactions exist for current one.
            ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                diffTransDate,
                this.getModule(),
                this.getLedgerTransType());

            if (LedgerParameters::find().TransactionReversalCorrection)
            {
                ledgerVoucherObject.parmCorrection(true);
            }

            // <GEEU>
            if (usePostingLog && transactionDate)
            {
                ledgerVoucher.lastTransDate(transactionDate);
                ledgerVoucherObject.parmTransDate(transactionDate);
            }
            // </GEEU>
            ledgerVoucher.addVoucher(ledgerVoucherObject);

            ledgerVoucherObjectMap.insert(currentCompany, ledgerVoucherObject);
        }

        // This voucher number will be used to create all transactions
        voucher = ledgerVoucherObject.parmVoucher();

        // <GEEU>
        if (usePostingLog && transactionDate)
        {
            ledgerVoucher.lastTransDate(transactionDate);
            ledgerVoucherObject.parmTransDate(transactionDate);
        }

        // </GEEU>
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNumberSequenceCodeByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the number sequence code used to create reversing settlement transaction voucher numbers for
    ///    the provided company.
    /// </summary>
    /// <param name="_companyId">
    ///    The company of the number sequence code; optional.
    /// </param>
    /// <returns>
    ///    The number sequence code for the provided company.
    /// </returns>
    public NumberSequenceCode findNumberSequenceCodeByCompany(CompanyId _companyId = curext())
    {
        NumberSequenceCode returnNumberSeqCode;
        NumberSequenceReference numberSeqRef;
        if (numberSeqMap.exists(_companyId))
        {
            returnNumberSeqCode = numberSeqMap.lookup(_companyId);
        }
        else
        {
            changecompany(_companyId)
            {
                numberSeqRef = this.getNumberSeqRef();
            }

            returnNumberSeqCode = numberSeqRef.numberSequenceTable().NumberSequence;
            numberSeqMap.insert(_companyId, returnNumberSeqCode);
        }

        return returnNumberSeqCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOffsetSettlementRecId</Name>
				<Source><![CDATA[
    public abstract CustVendSettlement findOffsetSettlementRecId(CustVendSettlement _custVendSettlement)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxTrans</Name>
				<Source><![CDATA[
    public TaxTrans findTaxTrans()
    {
        CustSettlement  localCustSettlement;
        VendSettlement  localVendSettlement;

        CustTrans custCashDisc;
        VendTrans vendCashDisc;
        TaxTrans  taxTrans;

        switch (custVendTrans.TableId)
        {
            // This code only executes for a single company where so don't need to
            // check OffsetCompany field.
            case tableNum(CustTrans):

                select firstonly TransRecId from localCustSettlement
                    where localCustSettlement.OffsetRecid == custVendTrans.RecId
                    join  Voucher, TransDate from custCashDisc
                    where custCashDisc.RecId == localCustSettlement.TransRecId
                    join  taxTrans
                    where taxTrans.Voucher   == custCashDisc.Voucher
                    &&    taxTrans.TransDate == custCashDisc.TransDate
                    &&    taxTrans.TaxOrigin == TaxOrigin::CashDisc;

                break;

            case tableNum(VendTrans):

                select firstonly TransRecId from localVendSettlement
                    where localVendSettlement.OffsetRecid == custVendTrans.RecId
                    join  Voucher, TransDate from vendCashDisc
                    where vendCashDisc.RecId == localVendSettlement.TransRecId
                    join  taxTrans
                    where taxTrans.Voucher   == vendCashDisc.Voucher
                    &&    taxTrans.TransDate == vendCashDisc.TransDate
                    &&    taxTrans.TaxOrigin == TaxOrigin::CashDisc;

                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTransType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ledger transaction type for reversal processing.
    /// </summary>
    /// <returns>
    ///    The ledger transaction type for reversal processing.
    /// </returns>
    /// <remarks>
    ///    The ledger transaction type is used to correctly post the reversing transactions.
    /// </remarks>
    protected abstract LedgerTransType getLedgerTransType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the module used for reversal processing.
    /// </summary>
    /// <returns>
    ///    The module used for reversal processing.
    /// </returns>
    protected abstract SysModule getModule()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSeqRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the number sequence reference for reversal processing.
    /// </summary>
    /// <returns>
    ///    The number sequence reference for reversal processing.
    /// </returns>
    /// <remarks>
    ///    The number sequence reference is used to generate the appropriate voucher numbers for reversing
    ///    transactions.
    /// </remarks>
    protected abstract NumberSequenceReference getNumberSeqRef()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementBuffer</Name>
				<Source><![CDATA[
    public abstract CustVendSettlement initCustVendSettlementBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementOffsetVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates either a <c>CustSettlementOffsetVoucher</c> or a <c>VendSettlementOffsetVoucher</c>.
    /// </summary>
    /// <returns>
    ///    The new <c>CustSettlementOffsetVoucher</c> or <c>VendSettlementOffsetVoucher</c> instance.
    /// </returns>
    protected abstract CustVendSettlementOffsetVoucher initCustVendSettlementOffsetVoucher()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransBuffer</Name>
				<Source><![CDATA[
    public abstract CustVendTrans initCustVendTransBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForNewReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes variables a settlement reversal is started.
    /// </summary>
    /// <remarks>
    ///    This method increments the voucher number and updates the transaction date on the
    ///    <c>LedgerVoucher</c> object. It also increments the settlement group placeholder.
    /// </remarks>
    protected void initForNewReversal()
    {
        settlementGroupPlaceHolder++;

        // Reset the ledgerVoucherObjectMap cache since a new settlement group is being processed.
        // The cache is cleared each time the settlement group changes to ensure uniqueness.
        // Settlement groups are unique across companies so the company aspect of the cache is
        // automatically handled by tracking changes in settlement groups.
        ledgerVoucherObjectMap = new Map(Types::String, Types::Class);

        isReversalForSettlementGroupComplete = false;
        isFirstReversalForSettlementGroup = true;

        custVendTransRecId = 0;
        custVendTransOffsetRecId = 0;

        this.resetExchRateTransactionAmounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetExchRateTransactionAmounts</Name>
				<Source><![CDATA[
    private void resetExchRateTransactionAmounts()
    {
        totalUnrealizedExchAdjCustVendTrans = 0;
        totalUnrealizedExchAdjCustVendTransOffset = 0;
        totalRealizedExchAdjCustVendTrans = 0;
        totalRealizedExchAdjCustVendTransOffset = 0;

        totalUnrealizedReportingExchAdjCustVendTrans = 0;
        totalUnrealizedReportingExchAdjCustVendTransOffset = 0;
        totalRealizedReportingExchAdjCustVendTrans = 0;
        totalRealizedReportingExchAdjCustVendTransOffset = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /*MAN
    This method is called when no SysLastValue record can be found in xSysLastValue.GetLast()
    */
    public void initParmDefault()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAgreementRecordList_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts values in the set.
    /// </summary>
    /// <param name="_agreementSet">
    ///     The agreement set.
    /// </param>
    /// <param name="_custVendTrans">
    ///     The record of the <c>CustTrans</c> or <c>VendTrans</c> table.
    /// </param>
    protected void insertAgreementRecordList_RU(Set _agreementSet, CustVendTrans _custVendTrans)
    {
        if (_agreementSet)
        {
            _agreementSet.add([_custVendTrans.company(),
                this.getModule() == SysModule::Cust ? ModuleSalesPurch::Sales : ModuleSalesPurch::Purch,
                AgreementHeaderExt_RU::findByDefaultDimension(_custVendTrans.DefaultDimension).RecId,
                _custVendTrans.AccountNum]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCrossCompanySettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the settlement spans company boundaries.
    /// </summary>
    /// <param name="_custVendSettlement">
    ///    The <c>CustVendSettlement</c> table record.
    /// </param>
    /// <returns>
    ///    true if the settlement spans company boundaries; otherwise, false.
    /// </returns>
    protected boolean isCrossCompanySettlement(CustVendSettlement _custVendSettlement)
    {
        return (_custVendSettlement.OffsetCompany != _custVendSettlement.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExchAmountDiff_RU</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    public boolean isExchAmountDiff_RU()
    {
        boolean       ret;
        CustVendTrans custVendTransDebet, custVendTransCredit;
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            switch (custVendTrans.TableId)
            {
                case tableNum(CustTrans):
                    custVendTransDebet = custVendTrans.AmountCur > 0 ? custVendTrans : custVendTransOffset;
                    break;

                case tableNum(VendTrans):
                    custVendTransDebet = custVendTrans.AmountCur < 0 ? custVendTrans : custVendTransOffset;
                    break;
            }

            custVendTransCredit = custVendTransDebet.RecId == custVendTrans.RecId ? custVendTransOffset : custVendTrans;

            ret = custVendTransDebet.CurrencyCode  != CompanyInfoHelper::standardCurrency() && custVendTransDebet.Invoice &&
                  custVendTransCredit.CurrencyCode == CompanyInfoHelper::standardCurrency() && ! custVendTransCredit.Invoice;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItPennyDiff</Name>
				<Source><![CDATA[
    public abstract boolean isItPennyDiff()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOffsetPrepayment</Name>
				<Source><![CDATA[
    public abstract boolean isOffsetPrepayment(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public IdentifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    public IdentifierName lastValueElementName()
    {
        return classId2Name(classIdGet(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    public UtilElementType lastValueType()
    {
        return UtilElementType::Class;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    public UserId lastValueUserId()
    {
        return curUserId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReversePrepaymentWithLog_RU</Name>
				<Source><![CDATA[
    protected abstract boolean mustReversePrepaymentWithLog_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(Common             _common,
             LedgerVoucherGroup _ledgerVoucherGroup,
             SettleDatePrinc    _datePrinciple = SettleDatePrinc::DateOfPayment)
    {
        // <GEERU><GEEPL>
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean                 countryRegion_PL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);
        // </GEEPL></GEERU>

        // <GGB>
        countryRegionGB = SysCountryRegionCode::isLegalEntityInCountryRegion([#ISOGB]);
        // </GGB>
        countryRegion_SAIE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoSA, #isoIE]);

        common = _common;
        ledgerVoucherGroup = _ledgerVoucherGroup;
        datePrinciple =     _datePrinciple;

        numberSeqMap = new Map(Types::String, Types::String);
        ledgerVoucherObjectMap = new Map(Types::String, Types::Class);

        reversePostingLogSet = new Set(Types::Int64);

        // <GTH>
        isTaxWithholdEnabled_TH = TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled();
        // </GTH>

        // <GEERU><GEECZ><GEEPL>
        if (TaxParameters::find().ReverseSettlementDatePrinciple_W
            ||  countryRegion_RU || countryRegion_PL ||
           (FeatureStateProvider::isFeatureEnabled(CustVendTransReversePostingSelectedDateFeature_WExt::instance()) &&
            CustVendTransPostingLog_RU::usePostingLog()))
        {
            xSysLastValue::getLast(this);
        }
        // </GEECZ></GEERU></GEEPL>

        reverseVoucherProcessed = new Set(Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendSettlement_W</Name>
				<Source><![CDATA[
    public CustVendSettlement parmCustVendSettlement_W(CustVendSettlement _custVendSettlement = custVendSettlement)
    {
        custVendSettlement = _custVendSettlement;
        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTrans_W</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTrans_W(CustVendTrans _custVendTrans = custVendTrans)
    {
        custVendTrans = _custVendTrans;
        return custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransOffset_W</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTransOffset_W(CustVendTrans _custVendTransOffset = custVendTransOffset)
    {
        custVendTransOffset = _custVendTransOffset;
        return custVendTransOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransSettlement_W</Name>
				<Source><![CDATA[
    public CustVendTransSettlement parmCustVendTransSettlement_W(CustVendTransSettlement _custVendTransSettlement = custVendTransSettlement)
    {
        custVendTransSettlement = _custVendTransSettlement;

        return custVendTransSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDatePrinciple</Name>
				<Source><![CDATA[
    public SettleDatePrinc parmDatePrinciple(SettleDatePrinc _datePrinciple = datePrinciple)
    {
        if (!prmisDefault(_datePrinciple))
            datePrinciple = _datePrinciple;

        return datePrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher_W</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher_W(LedgerVoucher _ledgerVoucher   = null)
    {
        if (! _ledgerVoucher)
        {
            ledgerVoucher = this.findLedgerVoucherByCompany();
        }
        else
        {
            ledgerVoucher = _ledgerVoucher;
        }

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentVoucher</Name>
				<Source><![CDATA[
    public Voucher parmParentVoucher(Voucher _parentVoucher = parentVoucher)
    {
        parentVoucher = _parentVoucher;

        return parentVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentVoucher_BR</Name>
				<Source><![CDATA[
    public Voucher parmPaymentVoucher_BR(Voucher _paymentVoucher_BR = paymentVoucher_BR)
    {
        paymentVoucher_BR = _paymentVoucher_BR;
        return paymentVoucher_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveDate_W</Name>
				<Source><![CDATA[
    public TransDate parmSaveDate_W(TransDate _saveDate = saveDate)
    {
        saveDate = _saveDate;
        return saveDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementGroupPlaceHolder_W</Name>
				<Source><![CDATA[
    public Counter parmSettlementGroupPlaceHolder_W(Counter _settlementGroupPlaceHolder = settlementGroupPlaceHolder)
    {
        settlementGroupPlaceHolder = _settlementGroupPlaceHolder;

        return settlementGroupPlaceHolder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionDate_W</Name>
				<Source><![CDATA[
    public TransDate parmTransactionDate_W(TransDate _transactionDate = transactionDate)
    {
        transactionDate = _transactionDate;
        return transactionDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = diffTransDate)
    {
        diffTransDate = _transDate;

        return diffTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDiscount</Name>
				<Source><![CDATA[
    public void postDiscount(AmountCur      totalAmountCur,
        CustVendTrans  _custVendTrans,
        ExchRate       _exchRate,
        container      _conLedgerAccount,
        container      _conTaxbaseAmountCur,
        CustVendTrans  _custVendTransPayment,
        RefTableId     _taxParentTableId,
        RefRecId       _taxParentRecId)
    {
        int                             idx = conLen(_conLedgerAccount);
        LedgerDimensionDefaultAccount   ledgerDimension;
        LedgerDimensionDefaultAccount   summaryLedgerDimension;
        AmountCur                       remainAmountCur = -totalAmountCur;
        AmountCur                       amountCur;
        DimensionDefault                cashDiscDefaultDimension;
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerDimensionAccount          mergedLedgerDimension;

        summaryLedgerDimension = _custVendTrans.summaryLedgerDimension();

        while (idx)
        {
            // if tax has been posted we can find the account here
            ledgerDimension = conPeek(_conLedgerAccount, idx);
            amountCur       = conPeek(_conTaxBaseAmountCur, idx);

            // if no tax was posted we can find the account here
            if (!ledgerDimension)
            {
                ledgerDimension = this.cashDiscountLedgerDimension(custVendTrans);
            }
            idx--;
            remainAmountCur  -= amountCur;

            //--> Retrieve Cash Discount Dimension from Settlement
            if (custVendSettlement.CanBeReversed && custVendSettlement.UtilizedCashDisc)
            {
                cashDiscDefaultDimension = custVendSettlement.DefaultDimension ? custVendSettlement.DefaultDimension : custVendTrans.DefaultDimension;
            }
            else
            {
                cashDiscDefaultDimension = _custVendTrans.DefaultDimension;
            }
            //<--

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                                    Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                                    ledgerVoucherObject.parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(_exchRate);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension, cashDiscDefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    ledgerVoucherObject,
                                                                    LedgerPostingType::CashDiscount,
                                                                    mergedLedgerDimension,
                                                                    _custVendTrans.CurrencyCode,
                                                                    amountCur,
                                                                    exchangeRateHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(_taxParentTableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(_taxParentRecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        if (remainAmountCur)
        {
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(_exchRate);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(summaryLedgerDimension, _custVendTrans.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    ledgerVoucherObject,
                                                                    LedgerPostingType::CashDiscount,
                                                                    mergedLedgerDimension,
                                                                    _custVendTrans.CurrencyCode,
                                                                    remainAmountCur,
                                                                    exchangeRateHelper);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseCustTransOffsetNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Releases <c>CustVendTransOffset</c> number sequence.
    /// </summary>
    private void releaseCustTransOffsetNumber()
    {
        CustTrans               custTrans;
        CustTransExtensionTH    custTransExtensionTH;

        custVendTransOffset.selectForUpdate(true);

        if (custVendTransOffset.TableId == tableNum(CustTrans))
        {
            custTrans = custVendTransOffset;

            custTransExtensionTH = custTrans.custTransExtensionTH();
            if (custTransExtensionTH.ReceiptId)
            {
                NumberSeq::releaseNumber(CustParameters::numRefCustReceiptId().NumberSequenceId, custTransExtensionTH.ReceiptId);
                custTransExtensionTH.ReceiptId = '';
                custTrans.SysExtensionSerializerMap::packExtensionTable(custTransExtensionTH);
            }
        }

        if (custVendTransOffset.DocumentNum)
        {
            NumberSeq::releaseNumber(CustParameters::numRefCustTaxInvoiceReceiptId().NumberSequenceId, custVendTransOffset.DocumentNum);
            custVendTransOffset.DocumentNum = '';
        }
        custVendTransOffset.update();
        custVendTransOffset.selectForUpdate(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreAdvanceAdjFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Marks the VAT adjustment factures as reversed during the reversal of the settlement.
    /// </summary>
    /// <param name="_transDate">
    ///   Date of original settlement.
    /// </param>
    /// <param name="_voucher">
    ///   Voucher of original settlement.
    /// </param>
    /// <returns>
    ///   <c>Set</c> object, containing list of factures marked as Reversed.
    /// </returns>
    /// <remarks>
    ///   The method originally was intended for use with Advance adjsutment factures also, but now Advance adjustment factures processing moved to <c>CustVendAdvAdjustmentDocUpdate_W</c> class.
    /// </remarks>
    protected Set restoreAdvanceAdjFacture_RU(TransDate _transDate,
                                              Voucher   _voucher)
    {
        FactureJour_RU factureJour;
        Set            reversedFactureJourSet = new Set(Types::Container);

        while select forupdate factureJour
            where factureJour.Voucher      == _voucher                          &&
                  factureJour.FactureDate  == _transDate                        &&
                  factureJour.Reversed     == NoYes::No                         &&
                  factureJour.FactureType  == FactureType_RU::VATAdjustment
        {
            factureJour.Reversed = NoYes::Yes;
            if (custVendSettlement.TransDate != transactionDate)
            {
                factureJour.ReverseDate = transactionDate;
            }
            factureJour.update();

            reversedFactureJourSet.add([factureJour.FactureId, factureJour.Module]);
        }

        return reversedFactureJourSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreAmountDiffFacture_RU</Name>
				<Source><![CDATA[
    protected void restoreAmountDiffFacture_RU(TransDate _transDate,
                                               Voucher   _voucher)
    {
        FactureJour_RU              facture;
        FactureCalcAmountAdjustments_RU factureCalcAmountsAdj;
        CustVendTrans                   localCustVendTrans = this.initCustVendTransBuffer();

        facture = FactureJour_RU::findAmountDiff(_voucher, _transDate, UnknownNoYes::No, true);

        if (facture)
        {
            facture.Reversed    = NoYes::Yes;
            if (custVendSettlement.TransDate != transactionDate)
            {
                facture.ReverseDate = transactionDate;
            }
            facture.update();

            if (facture.AmountAdjustment)
            {
                select firstonly localCustVendTrans
                    where localCustVendTrans.RecId == facture.ExchAdjInvoiceRecId;

                factureCalcAmountsAdj = FactureCalcAmountAdjustments_RU::newCustVendTrans(localCustVendTrans);
                factureCalcAmountsAdj.calc();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRestoreCustomerTransactionOpenLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the customer transaction open lines must be restored.
    /// </summary>
    /// <returns>
    /// true if the customer transaction open lines must be restored; otherwise, false.
    /// </returns>
    protected boolean mustRestoreCustomerTransactionOpenLine()
    {
        return (custVendTrans.TransType == LedgerTransType::Cust || custVendTrans.TransType == LedgerTransType::Interest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransOpenForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates values in the <c>CustVendTransOpen</c> table buffer.
    /// </summary>
    [SysObsolete("Use method populateTransOpenForReversalInsert", false, 30\6\2020), Wrappable(true)]
    final protected void populateTransOpenForReversal()
    {
        custVendTransOpen.RefRecId = custVendTrans.RecId;
        custVendTransOpen.AccountNum = custVendTrans.AccountNum;

        //Check if the transaction is of type 'Payment'
        if (custVendTrans.TransType == LedgerTransType::Payment)
        {
            //If transaction is a 'Payment' then set the DueDate same as payment date
            custVendTransOpen.DueDate = custVendSettlement.TransDate;
        }
        else
        {
            //If transaction is not of type 'Payment' then retain the DueDate
            custVendTransOpen.DueDate = custVendSettlement.DueDate;
        }

        if (custVendTransOpen.TableId == tableNum(CustTransOpen))
        {
            custVendTransOpen.LastInterestDate =
                            (select maxof(LastInterestDate)
                                from custSettlement
                                where
                                    custSettlement.TransRecId == custVendTrans.RecId &&
                                    custSettlement.TransCompany == custVendTrans.DataAreaId &&
                                    custSettlement.AccountNum == custVendTrans.AccountNum
                                ).LastInterestDate;
        }

        custVendTransOpen.TransDate = custVendTrans.TransDate;
        custVendTransOpen.CashDiscDate = custVendSettlement.CashDiscDate;

        // <GBR>
        // Newly created open transaction, all values should be zero
        if (BrazilParameters::isEnabled())
        {
            custVendTransOpen.InterestAmount_BR = 0;
            custVendTransOpen.FineAmount_BR = 0;
            custVendTransOpen.FineAmountPaymCur_BR = 0;
            custVendTransOpen.InterestAmountPaymCur_BR = 0;
            custVendTransOpen.InterestCode_BR = custVendSettlement.InterestCode_BR;
            custVendTransOpen.FineCode_BR = custVendSettlement.FineCode_BR;
        }
        // </GBR>
	}

]]></Source>
			</Method>
			<Method>
				<Name>populateTransOpenForReversalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustVendTransOpen</c> table buffer fields as a result of reversing the settlement.
    /// </summary>
    [Wrappable(true)]
    final protected void populateTransOpenForReversalUpdate()
    {
        // Existing open transaction record, so decrement existing values. *AmountPaymCur should
        // always be zero after reversal.
        if (BrazilParameters::isEnabled())
        {
            custVendTransOpen.InterestAmount_BR -= custVendSettlement.InterestAmount_BR;
            custVendTransOpen.FineAmount_BR -= custVendSettlement.FineAmount_BR;
            custVendTransOpen.FineAmountPaymCur_BR = 0;
            custVendTransOpen.InterestAmountPaymCur_BR = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransOpenForReversalInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the <c>CustVendTransOpen</c> table buffer fields as a result of reversing the settlement.
    /// </summary>
    [Wrappable(true)]
    final protected void populateTransOpenForReversalInsert()
    {
        // MOD: update cause original is obsolete
        custVendTransOpen.RefRecId = custVendTrans.RecId;
        custVendTransOpen.AccountNum = custVendTrans.AccountNum;

        //Check if the transaction is of type 'Payment'
        if (custVendTrans.TransType == LedgerTransType::Payment)
        {
            //If transaction is a 'Payment' then set the DueDate same as payment date
            custVendTransOpen.DueDate = custVendSettlement.TransDate;
        }
        else
        {
            //If transaction is not of type 'Payment' then retain the DueDate
            custVendTransOpen.DueDate = custVendSettlement.DueDate;
        }

        if (custVendTransOpen.TableId == tableNum(CustTransOpen))
        {
            custVendTransOpen.LastInterestDate =
                            (select maxof(LastInterestDate)
                                from custSettlement
                                where
                                    custSettlement.TransRecId == custVendTrans.RecId &&
                                    custSettlement.TransCompany == custVendTrans.DataAreaId &&
                                    custSettlement.AccountNum == custVendTrans.AccountNum
                                ).LastInterestDate;
        }

        custVendTransOpen.TransDate = custVendTrans.TransDate;
        custVendTransOpen.CashDiscDate = custVendSettlement.CashDiscDate;

        // <GBR>
        // Newly created open transaction, all values should be zero
        if (BrazilParameters::isEnabled())
        {
            custVendTransOpen.InterestAmount_BR = 0;
            custVendTransOpen.FineAmount_BR = 0;
            custVendTransOpen.FineAmountPaymCur_BR = 0;
            custVendTransOpen.InterestAmountPaymCur_BR = 0;
            custVendTransOpen.InterestCode_BR = custVendSettlement.InterestCode_BR;
            custVendTransOpen.FineCode_BR = custVendSettlement.FineCode_BR;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores the <c>CustVendTransOpen</c> table buffer record along with other related information as a result of reversing the settlement.
    /// </summary>
    /// <param name="_totalUnrealizedExchAdjCustVendTrans">
    /// The total unrealized exchange adjustment as an accounting currency amount.
    /// </param>
    /// <param name="_totalUnrealizedReporting">
    /// The total unrealized exchange adjustment as an reporting currency amount.
    /// </param>
    protected void restoreCustVendTransOpen(
        Amount _totalUnrealizedExchAdjCustVendTrans = 0,
        Amount _totalUnrealizedReporting = 0)
    {
        CustSettlement localCustSettlement;
        CustTransCashDisc localCustTransCashDisc;
        VendSettlement localVendSettlement;
        VendTransCashDisc localVendTransCashDisc;
        CustSettlementLine  custSettlementLine;
        CustTransOpenLine custTransOpenLine;
        // <GIN>
        CustVendTrans   custVendTransloc;
        CustVendTrans_W custVendTransloc_W;
        Factor          taxWithholdFactor = 1;
        // </GIN>

        // recreate or adjust existing custVendTransOpen

        if (custVendTrans.TransType == LedgerTransType::Payment)
        {
            custVendTransOpen = custVendTrans.transOpen(dateNull(), true);
        }
        else
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custVendSettlement.TableId == tableNum(VendSettlement) && custVendSettlement.ThirdPartyBankAccountId)
            {
                custVendTransOpen = custVendTrans.transOpenForVendBank(
                                    custVendSettlement.ThirdPartyBankAccountId,
                                    custVendSettlement.DueDate,true);

                custVendTransOpen.ThirdPartyBankAccountId += custVendSettlement.ThirdPartyBankAccountId;
            }
            else
            {
                custVendTransOpen = custVendTrans.transOpen(custVendSettlement.DueDate, true);
            }
        }

        if (custVendSettlement.SettleAmountCur)
        {
            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                custVendTransloc = custVendSettlement.custVendTrans();
                if (custVendTransloc.AmountCur)
                {
                    taxWithholdFactor = abs(custVendSettlement.SettleAmountCur/custVendTransloc.AmountCur);
                    custVendTransloc_W = custVendTransloc.CustVendTrans::getCustVendTrans_W();
                    custVendTransOpen.tcsAmount_IN  += CurrencyExchange::round(taxWithholdFactor * custVendTransloc_W.tcsAmount_IN, custVendTransloc.CurrencyCode);
                    custVendTransOpen.tdsAmount_IN  += CurrencyExchange::round(taxWithholdFactor * custVendTransloc_W.tdsAmount_IN, custVendTransloc.CurrencyCode);
                    custVendTransOpen.TaxWithholdAmountOrigin_IN += CurrencyExchange::round(taxWithholdFactor * custVendTransloc_W.TaxWithholdAmountOrigin_IN, custVendTransloc.CurrencyCode);
                }
            }
            // </GIN>
            custVendTransOpen.AmountCur += custVendSettlement.SettleAmountCur;
            custVendTransOpen.AmountMST += (custVendSettlement.SettleAmountMST - custVendSettlement.ExchAdjustment) + _totalUnrealizedExchAdjCustVendTrans;
            custVendTransOpen.ReportingCurrencyAmount += (custVendSettlement.SettleAmountReporting - custVendSettlement.ExchAdjustmentReporting) + _totalUnrealizedReporting;
            custVendTransOpen.PossibleCashDisc += custVendSettlement.UtilizedCashDisc;
            custVendTransOpen.ExchAdjUnrealized += _totalUnrealizedExchAdjCustVendTrans;
            custVendTransOpen.ExchAdjUnrealizedReporting += _totalUnrealizedReporting;

            if (custVendTransOpen.RecId)
            {
                this.populateTransOpenForReversalUpdate();
                custVendTransOpen.update();
            }
            else
            {
                this.populateTransOpenForReversalInsert();
                custVendTransOpen.insert();
            }

            //Check if the transaction is of type 'Cust' or 'Interest'
            if (this.mustRestoreCustomerTransactionOpenLine())
            {
                //Restore customer transaction open lines.
                while select CustInvoiceLineIdRef, CustSettlement, SettledAmountCur from custSettlementLine
                    order by custSettlementLine.CustInvoiceLineIdRef
                        where custSettlementLine.CustSettlement == custVendSettlement.RecId
                {
                    custTransOpenLine =  CustTransOpenLine::findByCustInvoiceLineRefId(custSettlementLine.CustInvoiceLineIdRef,
                    CustTransOpen::findDueDate(custVendTrans.RecId, CustSettlement::find(custSettlementLine.CustSettlement).DueDate).RecId, true);

                    if (custTransOpenLine.RecId != 0)
                    {
                        custTransOpenLine.AmountCur += custSettlementLine.SettledAmountCur;
                        custTransOpenLine.update();
                    }
                    else
                    {
                        custTransOpenLine.AmountCur = custSettlementLine.SettledAmountCur;
                        custTransOpenLine.CustInvoiceLineIdRef = custSettlementLine.CustInvoiceLineIdRef;
                        custTransOpenLine.CustTransOpen = custVendTransOpen.RecId;
                        custTransOpenLine.insert();
                    }
                }
            }

            switch (custVendTransOpen.TableId)
            {
                // find if any settlement for this trans has the cash discount
                // records and move these to the trans open

                case tableNum(CustTransOpen) :
                    select firstonly RecId from localCustSettlement
                       where localCustSettlement.TransRecId == custVendTrans.RecId
                        exists join * from localCustTransCashDisc
                            where (localCustTransCashDisc.RefRecId == localCustSettlement.RecId
                               && localCustTransCashDisc.RefTableId == tableNum(CustSettlement));

                    CustTransCashDisc::moveCashDisc(localCustSettlement.TableId, localCustSettlement.RecId,
                                                    custVendTransOpen.TableId,  custVendTransOpen.RecId);
                    break;

                case tableNum(VendTransOpen) :
                    select firstonly RecId from localVendSettlement
                       where localVendSettlement.TransRecId == custVendTrans.RecId
                        exists join * from localVendTransCashDisc
                            where (localVendTransCashDisc.RefRecId == localVendSettlement.RecId
                               && localVendTransCashDisc.RefTableId == tableNum(VendSettlement));

                    VendTransCashDisc::moveCashDisc(localVendSettlement.TableId, localVendSettlement.RecId,
                                                    custVendTransOpen.TableId,  custVendTransOpen.RecId);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAssetTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses fixed asset transactions related to specified voucher and date.
    /// </summary>
    /// <param name="_voucherToReverse">
    /// The voucher number of the transactions to reverse.
    /// </param>
    /// <param name="_transDateToReverse">
    /// The transaction date of the transactions to reverse.
    /// </param>
    protected void reverseAssetTrans(Voucher _voucherToReverse, TransDate _transDateToReverse)
    {
        AssetTrans  assetTrans;
        AssetTransReverse  assetTransReverse;
        Voucher voucherId = voucher;

        insert_recordset assetTrans
        (
            Voucher,
            TransDate,
            AmountCur,
            AmountMST,
            ReportingCurrencyAmount,
            CurrencyCode,
            AssetGroup,
            AssetId,
            BookId,
            TransType,
            PostingProfile,
            DefaultDimension,
            CashDiscBaseTransId,
            CashDiscBaseAmountMST
        )
        select
            voucherId,
            diffTransDate,
            NegativeAmountCur,
            NegativeAmountMST,
            NegativeReportingCurrencyAmount,
            CurrencyCode,
            AssetGroup,
            AssetId,
            BookId,
            TransType,
            PostingProfile,
            DefaultDimension,
            CashDiscBaseTransId,
            NegativeCashDiscBaseAmountMST
            from assetTransReverse
        where assetTransReverse.Voucher == _voucherToReverse
            && assetTransReverse.TransDate == _transDateToReverse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseCrossCompanySettlement_W</Name>
				<Source><![CDATA[
    protected void reverseCrossCompanySettlement_W()
    {
        CustVendTrans                   custVendTransToReverse      = this.initCustVendTransBuffer();
        CustVendSettlement              custVendSettlementToReverse = this.initCustVendSettlementBuffer();
        CustVendTransPostingLog_RU      custVendTransPostingLog;
        CustVendReversePostingLog_RU    custVendReversePostingLog;
        Voucher                         oldVoucher;

        while select Voucher from custVendTransPostingLog
            where custVendTransPostingLog.TransCompany   == custVendSettlement.TransCompany  &&
                  custVendTransPostingLog.TransRecId     == custVendSettlement.TransRecId    &&
                  custVendTransPostingLog.OffsetCompany  == custVendSettlement.OffsetCompany &&
                  custVendTransPostingLog.OffSetRecId    == custVendSettlement.OffsetRecId   &&
                  custVendTransPostingLog.RefTableId     == custVendTrans.TableId            &&
                  custVendTransPostingLog.PostingLogType == CustVendTransPostingLogType_RU::CrossCompanySettlement
        join custVendTransToReverse
            where custVendTransToReverse.TransDate == custVendTransPostingLog.TransDate &&
                  custVendTransToReverse.Voucher   == custVendTransPostingLog.Voucher   &&
                  custVendTransToReverse.TransType == LedgerTransType::CrossCompanySettlement
        join custVendSettlementToReverse
            where custVendSettlementToReverse.TransRecId == custVendTransToReverse.RecId
        {
            oldVoucher = voucher;
            voucher    = custVendTransPostingLog.Voucher;

            this.reverseTransAndSettlement(custVendTransToReverse, custVendSettlementToReverse);

            voucher = oldVoucher;

            custVendReversePostingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement, ledgerVoucher);
            custVendReversePostingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::CrossCompanySettlement);
            custVendReversePostingLog.doReverse(true, true);
            reversePostingLogSet = Set::union(reversePostingLogSet, custVendReversePostingLog.getReversePostingLogSet());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseDiscount</Name>
				<Source><![CDATA[
    public void reverseDiscount()
    {
        CustVendTrans       localCustVendTrans          = this.initCustVendTransBuffer();
        CustVendTrans       localCustVendTransOffset    = this.initCustVendTransBuffer();
        TaxReverseTax       taxReverseTax;
        ExchRate            reverseExchRate             = custVendTrans.AmountCur ? custVendTrans.AmountMST / custVendTrans.AmountCur * 100 : 0;
        TransactionTxt      transactionTxt              = TransactionTxt::construct();
        AmountCur           cashDiscTaxAmount;
        Voucher             lastVoucher;
        TaxTrans            taxTrans;
        LedgerPostingController ledgerPostingController;

        // <GEERU>
        LedgerBondClient_RU ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        RefTableId          taxParentTableId;
        RefRecId            taxParentRecId;

        if (custVendSettlement.UtilizedCashDisc != 0)
        {
            this.setupReverseDiscount();
            cashDiscTaxAmount = 0;

            // This code only executes for a single company where so don't need to
            // check OffsetCompany field.
            select firstonly localCustVendTransOffset
            where localCustVendTransOffset.RecId == custVendSettlement.OffsetRecId;

            // create new custVendTrans as reverse for the cashdisc custVendTrans that was created when settling

            localCustVendTrans.OffsetRecId      = custVendTrans.RecId;
            localCustVendTrans.AccountNum       = custVendTrans.AccountNum;
            localCustVendTrans.Approved         = NoYes::Yes;
            localCustVendTrans.CurrencyCode     = custVendTrans.CurrencyCode;
            localCustVendTrans.DefaultDimension = localCustVendTransOffset.DefaultDimension;
            localCustVendTrans.TransType        = LedgerTransType::CashDiscount;
            localCustVendTrans.Voucher          = voucher;
            localCustVendTrans.TransDate        = diffTransDate;

            localCustVendTrans.AmountCur = custVendSettlement.UtilizedCashDisc;
            localCustVendTrans.AmountMST = CurrencyExchangeHelper::mstAmount(custVendSettlement.UtilizedCashDisc, localCustVendTrans.CurrencyCode, localCustVendTrans.TransDate, UnknownNoYes::No, reverseExchRate);
            localCustVendTrans.ExchRate = reverseExchRate;

            localCustVendTrans.SettleAmountCur  = localCustVendTrans.AmountCur;
            localCustVendTrans.SettleAmountMST  = localCustVendTrans.AmountMST;
            localCustVendTrans.Settlement       = NoYes::No;
            localCustVendTrans.Closed           = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);

            localCustVendTrans.LastSettleDate       = dateNull();
            localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
            localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
            localCustVendTrans.LastSettleCompany    = custVendTrans.DataAreaId;

            localCustVendTrans.PostingProfile = custVendTrans.PostingProfile;

            transactionTxt.setType(this.discTxtCustVend());
            transactionTxt.setVoucher(voucher);
            transactionTxt.setFormLetter(localCustVendTrans.Invoice);
            localCustVendTrans.Txt              = transactionTxt.txt();

            ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

            ledgerPostingController.getReference().lastTransTxt(strFmt('%1 %2 %3 ', "@SYS4412", "@SYS12371", localCustVendTrans.Voucher));

            custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, settlementGroupPlaceHolder);

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
            // </GEERU>
            // reinstate the reversed tax posted when settling original invoice
            lastVoucher = custVendSettlement.OffsetTransVoucher;

            taxTrans = this.findTaxTrans();

            if (localCustVendTrans.RecId == 0)
            {
                taxParentTableId = taxTrans.SourceTableId;
                taxParentRecId = taxTrans.SourceRecId;
            }
            else
            {
                taxParentTableId = localCustVendTrans.TableId;
                taxParentRecId = localCustVendTrans.RecId;
            }

            taxReverseTax = new TaxReverseTaxCashDisc(ledgerPostingController.getReference().parmVoucher(),
                                                      ledgerPostingController.getReference().parmTransDate(),
                                                      ledgerPostingController.getReference().lastTransTxt());
            taxReverseTax.setReverseTableId(taxParentTableId);
            taxReverseTax.setReverseRecId(taxParentRecId);
            taxReverseTax.setSourceAmountCur(localCustVendTrans.AmountCur);

            if (this.cashDiscVat())
            {
                cashDiscTaxAmount = this.taxCashDisc(custVendTrans, localCustVendTransOffset, custVendSettlement);

                // If use tax, taxCashDisc method (above) has not inserted the correct ledger account.
                if (taxTrans.TaxDirection == TaxDirection::UseTax)
                {
                    conLedgerAccount = conDel(conLedgerAccount,conLen(conLedgerAccount),1);
                    conLedgerAccount += this.cashDiscountLedgerDimension(custVendTrans);
                }
            }
            else
            {
                cashDiscTaxAmount = taxReverseTax.calcAndPost(ledgerPostingController, taxTrans.Voucher, taxTrans.TransDate);
                [conLedgerAccount, conTaxBaseAmountCur] = taxReverseTax.getContainers();
            }

            if (conLen(conLedgerAccount))
            {
                taxReverse += lastVoucher;
            }
            else
            {
                conLedgerAccount    += this.cashDiscountLedgerDimension(custVendTrans);
                conTaxBaseAmountCur += -localCustVendTrans.AmountCur;
            }

            //
            //  Is this a vendor transaction and does Fixed Assets allow
            //  cash discount deductions.
            //
            if (custVendTrans.TableId == tableNum(VendTrans) &&
               AssetParameters::find().DeductCashDisc)
            {
                //  Reverse any valid fixed asset cash discounts.
                cashDiscTaxAmount -= this.reverseFixedAssetDiscount(localCustVendTransOffset, localCustVendTrans, cashDiscTaxAmount);
            }

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log();
                ledgerBondClient.removeCurrentLogObject();
            }
            // </GEERU>

            this.postDiscount(cashDiscTaxAmount, localCustVendTrans, reverseExchRate, conLedgerAccount, conTaxBaseAmountCur, localCustVendTransOffset, taxParentTableId, taxParentRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseDiscount_RU</Name>
				<Source><![CDATA[
    protected void reverseDiscount_RU()
    {
        CustVendTrans                    localCustVendTrans = this.initCustVendTransBuffer();
        CustVendTransPostingLog_RU       custVendTransPostingLog;
        CustVendReversePostingLog_RU     postingLog;
        TransactionTxt                   transactionTxt = TransactionTxt::construct();
        RefTableId                       refTableId = custVendSettlement.TableId == tableNum(CustSettlement) ? tableNum(CustTrans) : tableNum(VendTrans);
        TaxTrans taxTrans;

        if (custVendSettlement.UtilizedCashDisc)
        {
            while select forupdate sum(AmountCur),sum(AmountMST) from custVendTransPostingLog
                group by Voucher, OffsetLedgerDimension, Correct, CurrencyCode
                where ((custVendTransPostingLog.TransCompany == custVendSettlement.TransCompany &&
                    custVendTransPostingLog.OffsetCompany == custVendSettlement.OffsetCompany &&
                    custVendTransPostingLog.TransRecId == custVendSettlement.TransRecId &&
                    custVendTransPostingLog.OffSetRecId == custVendSettlement.OffsetRecId) ||
                    (custVendTransPostingLog.TransCompany == custVendSettlement.OffsetCompany &&
                    custVendTransPostingLog.OffsetCompany == custVendSettlement.TransCompany &&
                    custVendTransPostingLog.TransRecId == custVendSettlement.OffsetRecId &&
                    custVendTransPostingLog.OffSetRecId == custVendSettlement.TransRecId)) &&
                    custVendTransPostingLog.TransDate == custVendSettlement.TransDate &&
                    custVendTransPostingLog.Reversed == NoYes::No &&
                    custVendTransPostingLog.PostingLogType == CustVendTransPostingLogType_RU::CashDisc &&
                    custVendTransPostingLog.RefTableId == refTableId
            {
                localCustVendTrans.OffsetRecId          = custVendTrans.RecId;
                localCustVendTrans.Correct              = ! custVendTransPostingLog.Correct;
                localCustVendTrans.PostingProfile       = custVendTrans.PostingProfile;
                localCustVendTrans.AccountNum           = custVendTrans.AccountNum;
                localCustVendTrans.Approved             = NoYes::Yes;
                localCustVendTrans.CurrencyCode         = custVendTransPostingLog.CurrencyCode;
                localCustVendTrans.LastSettleDate       = transactionDate;

                localCustVendTrans.DefaultDimension     = AgreementHeaderExt_RU::createAgreementDimension(
                    AgreementHeaderExt_RU::findByDefaultDimension(custVendTrans.DefaultDimension).RecId,
                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(custVendTransPostingLog.OffsetLedgerDimension));

                localCustVendTrans.TransType            = LedgerTransType::CashDiscount;
                localCustVendTrans.Voucher              = custVendTransPostingLog.Voucher;
                localCustVendTrans.TransDate            = transactionDate;

                select firstonly SourceTaxAmountCur, TaxAmount from taxTrans
                    where taxTrans.Voucher == custVendTransPostingLog.Voucher &&
                        taxTrans.TaxDirection == TaxDirection::UseTax;

                localCustVendTrans.AmountCur = custVendTransPostingLog.AmountCur - taxTrans.SourceTaxAmountCur;
                localCustVendTrans.AmountMST = custVendTransPostingLog.AmountMST - taxTrans.TaxAmount;

                localCustVendTrans.ExchRate             = custVendTransPostingLog.AmountCur                                           ?
                                                          custVendTransPostingLog.AmountMST / custVendTransPostingLog.AmountCur * 100 :
                                                          100;
                localCustVendTrans.SettleAmountCur      = localCustVendTrans.AmountCur;
                localCustVendTrans.SettleAmountMST      = localCustVendTrans.AmountMST;
                localCustVendTrans.Settlement           = NoYes::No;
                localCustVendTrans.Closed               = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);
                localCustVendTrans.LastSettleDate       = dateNull();
                localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
                localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
                localCustVendTrans.LastSettleCompany    = custVendTrans.DataAreaId;

                transactionTxt.setType(this.discTxtCustVend());
                transactionTxt.setVoucher(voucher);
                transactionTxt.setFormLetter(localCustVendTrans.Invoice);
                localCustVendTrans.Txt = transactionTxt.txt();

                // <GEECZ>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
                {
                    this.createCreditNoteForCashDiscount_CZ(custVendTrans, localCustVendTrans);
                }
                // </GEECZ>

                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(localCustVendTrans.Txt);

                custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, settlementGroupPlaceHolder);

                postingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement, ledgerVoucher);
                postingLog.setTaxReverseTax(new TaxReverseTaxCustVendSettle_RU(ledgerVoucher.lastVoucher(),
                                                                               ledgerVoucher.lastTransDate(),
                                                                               ''));

                postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::CashDisc);
                postingLog.setAllowedVoucher(custVendTransPostingLog.Voucher);
                postingLog.doReverse(true,true);
                reversePostingLogSet = Set::union(reversePostingLogSet, postingLog.getReversePostingLogSet());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseExchAdjustment</Name>
				<Source><![CDATA[
    public void reverseExchAdjustment(boolean _restoreRealExhAdj = true)
    {
        CustVendTrans               localCustVendTrans  = this.initCustVendTransBuffer();
        CustVendTrans               localCustVendTrans1 = this.initCustVendTransBuffer();
        AmountMSTSecondary          amountMSTSecondary;
        TransactionTxt              transactionTxt      = TransactionTxt::construct();
        NoYes                       realized;
        CurrencyExchangeHelper      currencyHelper;
        LedgerVoucherObject         ledgerVoucherObject;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerDimensionAccount      mergedLedgerDimension;
        // <GEERU><GEECZ>
        CustVendSettlement       localCustVendSettlement;
        boolean                  countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        LedgerPostingType        summaryPostingType = (localCustVendTrans.TableId == tableNum(CustTrans)) ? LedgerPostingType::CustBalance : LedgerPostingType::VendBalance;
        // </GEECZ></GEERU>
        //<GEEU>
        boolean                 usePostingLog   = CustVendTransPostingLog_RU::usePostingLog();
        //</GEEU>

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            localCustVendSettlement    = this.initCustVendSettlementBuffer();
        }
        // </GEECZ></GEERU>

        if (custVendTrans.LastExchAdjRate
            && !CustVendExchAdjPostingEngine::isPreviousRevaluationInvDatePrinciple(custVendTrans))
        {
            //Unrealized exhange adjustment
            realized = false;

            // find accounts to post to
            // <GEEU>
            if (!usePostingLog)
            {
                // </GEEU>
                this.setupReverseExchAdjustment(realized);
                // <GEEU>
            }
            // </GEEU>

            // create new custVendTrans as reverse for the exchrate custVendTrans that was created when settling
            localCustVendTrans1.OffsetRecId     = custVendTrans.RecId;
            localCustVendTrans1.AccountNum      = custVendTrans.AccountNum;
            localCustVendTrans1.Invoice         = custVendTrans.Invoice;
            localCustVendTrans1.Approved        = NoYes::Yes;
            localCustVendTrans1.CurrencyCode    = custVendTrans.CurrencyCode;
            localCustVendTrans1.DefaultDimension= custVendTrans.DefaultDimension;
            localCustVendTrans1.TransType       = LedgerTransType::ExchAdjustment;
            localCustVendTrans1.Voucher         = voucher;

            // <GEERU><GEECZ>
            if (!countryRegion_RUCZ)
            {
                // </GEECZ></GEERU>
                if (custVendTrans.LastExchAdj < custVendSettlement.TransDate ||
                    !this.isDatePrincipleDateOfPayment())
                {
                    localCustVendTrans1.TransDate = diffTransDate;
                }
                else
                {
                    localCustVendTrans1.TransDate = custVendTrans.LastExchAdj;
                }
                // <GEERU><GEECZ>
            }
            if (countryRegion_RUCZ)
            {
                localCustVendTrans1.TransDate                = max(custVendTrans.LastExchAdj, diffTransDate);
            }
            // </GEECZ></GEERU>

            localCustVendTrans1.AmountCur = 0;
            localCustVendTrans1.AmountMST = -CurrencyExchangeHelper::amount((custVendTrans.AmountMST / custVendTrans.AmountCur * 100 - custVendTrans.LastExchAdjRate) * custVendSettlement.SettleAmountCur / 100, custVendTrans.CurrencyCode);
            localCustVendTrans1.ExchRate = 100;

            localCustVendTrans1.SettleAmountCur             = localCustVendTrans1.AmountCur;
            localCustVendTrans1.SettleAmountMST             = localCustVendTrans1.AmountMST;
            localCustVendTrans1.ExchAdjustmentUnrealized    = localCustVendTrans1.AmountMST;
            localCustVendTrans1.ExchAdjustment              = localCustVendTrans1.AmountMST;
            localCustVendTrans1.Settlement                  = NoYes::No;
            localCustVendTrans1.Closed                      = CustVendTransData::construct(localCustVendTrans1).maxSettlementDate(localCustVendTrans1.TransDate);

            localCustVendTrans1.LastSettleDate          = localCustVendTrans1.TransDate;
            localCustVendTrans1.LastSettleVoucher       = custVendTrans.Voucher;
            localCustVendTrans1.LastSettleAccountNum    = custVendTrans.AccountNum;
            localCustVendTrans1.LastSettleCompany       = custVendTrans.DataAreaId;

            localCustVendTrans1.PostingProfile = custVendTrans.PostingProfile;

            transactionTxt.setType(this.exchAdjTxt());
            transactionTxt.setVoucher(voucher);
            transactionTxt.setFormLetter(custVendTrans.Invoice);
            localCustVendTrans1.Txt                 = transactionTxt.txt();

            ledgerVoucher.findLedgerVoucherObject().lastTransTxt(strFmt('%1 %2 %3 ',"@SYS4768", "@SYS14204", localCustVendTrans1.Invoice));

            // adjust unrealized exchadjustment values on original invoice custVendTransaction
            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                custVendTrans.update();
            }
            // </GEECZ></GEERU>

            custVendTrans.ExchAdjustmentUnrealized  += localCustVendTrans1.AmountMST;
            custVendTrans.ExchAdjustment            += localCustVendTrans1.AmountMST;
            custVendTransOpen.AmountMST             += localCustVendTrans1.AmountMST;
            custVendTransOpen.ExchAdjUnrealized     += localCustVendTrans1.AmountMST;
            custVendTransOpen.update();

            // <GEEU>
            if (usePostingLog)
            {
                this.setupReverseExchAdjustment(realized);
            }
            // </GEEU>

            currencyHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                diffTransDate);
            amountMSTSecondary = currencyHelper.calculateAccountingToReportingAdjustment(
                localCustVendTrans1.CurrencyCode,
                localCustVendTrans1.AmountMST,
                true);

            mergedLedgerDimension = CustVendReversePostingExt::mergeLedgerDimension(
                countryRegion_RUCZ,
                exchAdjLedgerDimension,
                localCustVendTrans1.DefaultDimension);

            // <GEERU><GEECZ>
            //<GEEU>
            if (usePostingLog)
            //</GEEU>
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(ledgerVoucher.lastVoucher(), localCustVendTrans1.TransDate);
                if ( !ledgerVoucherObject)
                {
                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher,
                                                                          localCustVendTrans1.TransDate,
                                                                          this.getModule(),
                                                                          this.getLedgerTransType()
                                                                          );
                    ledgerVoucher.addVoucher(ledgerVoucherObject);
                }
            }
            else
            {
                // </GEECZ></GEERU>
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
                // <GEERU><GEECZ>
            }
            // </GEECZ></GEERU>
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                                        ledgerVoucherObject,
                                        exchAdjustmentPostingType,
                                        mergedLedgerDimension,
                                        localCustVendTrans1.CurrencyCode,
                                        -localCustVendTrans1.AmountMST,
                                        -amountMSTSecondary);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            mergedLedgerDimension = CustVendReversePostingExt::mergeLedgerDimension(
                countryRegion_RUCZ,
                this.summaryLedgerDimension(),
                localCustVendTrans1.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                                        ledgerVoucherObject,
                                        exchAdjustmentPostingType,
                                        mergedLedgerDimension,
                                        localCustVendTrans1.CurrencyCode,
                                        localCustVendTrans1.AmountMST,
                                        amountMSTSecondary);
            // <GEEU>
            if (usePostingLog)
            {
                ledgerVoucherTransObject.parmLedgerPostingType(summaryPostingType);
            }
            // </GEEU>

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // <GEERU><GEECZ>
            if (!countryRegion_RUCZ)
            {
                // </GEECZ></GEERU>
                custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans1, settlementGroupPlaceHolder);
                // <GEERU><GEECZ>
            }
            if (countryRegion_RUCZ)
            {
                ledgerVoucher.bondLast2_RU();

                localCustVendSettlement.CustVendSettlement::initFromCustVendTrans(localCustVendTrans1);
                localCustVendSettlement.TransDate           = max(transactionDate, custVendTrans.LastSettleDate);
                localCustVendSettlement.OffsetTransVoucher  = custVendSettlement.OffsetTransVoucher;

                custVendTransSettlement.addTransAndSettlement(localCustVendTrans1, localCustVendSettlement, settlementGroupPlaceHolder);

                if (localCustVendTrans1.TransDate != transactionDate)
                {
                    ledgerVoucher.lastTransDate(transactionDate);
                }
            }
            // </GEECZ></GEERU>
        }

        // <GEERU>
        if (_restoreRealExhAdj
            && custVendSettlement.ExchAdjustment != 0)
        // </GEERU>
        {
            //Realized exhange adjustment
            realized = true;

            // find accounts to post to
            this.setupReverseExchAdjustment(realized);

            // adjust exchadjustment values on original invoice custVendTransaction
            custVendTrans.ExchAdjustmentRealized -= custVendSettlement.ExchAdjustment;
            custVendTrans.ExchAdjustment         -= custVendSettlement.ExchAdjustment;

            // create new custVendTrans as reverse for the exchrate custVendTrans that was created when settling
            localCustVendTrans.OffsetRecId      = custVendTrans.RecId;
            localCustVendTrans.AccountNum       = custVendTrans.AccountNum;
            localCustVendTrans.Invoice          = custVendTrans.Invoice;
            localCustVendTrans.Approved         = NoYes::Yes;
            localCustVendTrans.CurrencyCode     = custVendTrans.CurrencyCode;
            localCustVendTrans.DefaultDimension = custVendTrans.DefaultDimension;
            localCustVendTrans.TransType        = LedgerTransType::ExchAdjustment;
            localCustVendTrans.Voucher          = voucher;

            // <GEERU><GEECZ>
            if (!countryRegion_RUCZ)
            {
                // </GEECZ></GEERU>
                if (!this.isDatePrincipleDateOfPayment())
                {
                    localCustVendTrans.TransDate = diffTransDate;
                }
                else
                {
                    localCustVendTrans.TransDate        = custVendSettlement.TransDate;
                }
                // <GEERU><GEECZ>
            }
            if (countryRegion_RUCZ)
            {
                localCustVendTrans.TransDate              = max(custVendSettlement.TransDate, diffTransDate);
            }
            // </GEECZ></GEERU>

            localCustVendTrans.AmountCur    = 0;
            localCustVendTrans.AmountMST    = -custVendSettlement.ExchAdjustment;
            localCustVendTrans.ExchRate     = 100;

            localCustVendTrans.SettleAmountCur  = localCustVendTrans.AmountCur;
            localCustVendTrans.SettleAmountMST  = localCustVendTrans.AmountMST;

            localCustVendTrans.ExchAdjustmentRealized   = localCustVendTrans.AmountMST;
            localCustVendTrans.ExchAdjustment           = localCustVendTrans.AmountMST;

            localCustVendTrans.Settlement   = NoYes::No;
            localCustVendTrans.Closed       = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);

            localCustVendTrans.LastSettleDate       = dateNull();
            localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
            localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
            localCustVendTrans.LastSettleCompany    = custVendTrans.DataAreaId;

            localCustVendTrans.PostingProfile       = custVendTrans.PostingProfile;

            // if there is and custVendTransOffset with different posting profile than
            // the custVendTrans, use the posting profile from the custVendTransOffset
            if (custVendTransOffset.RecId != 0)
            {
                if (custVendTransOffset.PostingProfile != custVendTrans.PostingProfile)
                {
                    localCustVendTrans.PostingProfile = custVendTransOffset.PostingProfile;
                }
            }

            transactionTxt.setType(this.exchAdjTxt());
            transactionTxt.setVoucher(voucher);
            transactionTxt.setFormLetter(custVendTrans.Invoice);
            localCustVendTrans.Txt = transactionTxt.txt();

            ledgerVoucher.findLedgerVoucherObject().lastTransTxt(strFmt('%1 %2 %3 ',"@SYS4768", "@SYS14204", localCustVendTrans.Invoice));

            currencyHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                diffTransDate);
            amountMSTSecondary = currencyHelper.calculateAccountingToReportingAdjustment(
                localCustVendTrans.CurrencyCode,
                localCustVendTrans.AmountMST,
                true);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(exchAdjLedgerDimension, localCustVendTrans.DefaultDimension);
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                                        ledgerVoucherObject,
                                        exchAdjustmentPostingType,
                                        mergedLedgerDimension,
                                        localCustVendTrans.CurrencyCode,
                                        -localCustVendTrans.AmountMST,
                                        -amountMSTSecondary);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(localCustVendTrans.summaryLedgerDimension(), localCustVendTrans.DefaultDimension);
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                                        ledgerVoucherObject,
                                        exchAdjustmentPostingType,
                                        mergedLedgerDimension,
                                        localCustVendTrans.CurrencyCode,
                                        localCustVendTrans.AmountMST,
                                        amountMSTSecondary);
            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                ledgerVoucherTransObject.parmLedgerPostingType(summaryPostingType);
            }
            // </GEECZ></GEERU>

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                ledgerVoucher.bondLast2_RU();
            }
            // </GEECZ></GEERU>

            custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, settlementGroupPlaceHolder);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLedgerDimension</Name>
				<Source><![CDATA[
    private static LedgerDimensionAccount mergeLedgerDimension(
        boolean _useDefaultDimensionForMainAccountLegalEntity,
        LedgerDimensionDefaultAccount _ledgerDimension,
        DimensionDefault _dimensionDefault)
    {
        DimensionDefault dimensionDefault = _dimensionDefault;

        if (_useDefaultDimensionForMainAccountLegalEntity && !dimensionDefault)
        {
            SourceDocumentILedgerDimensionProvider ledgerDimensionProvider = SourceDocumentLedgerDimensionProviderFactory::getProvider();
            dimensionDefault = ledgerDimensionProvider.getDefaultDimensionForMainAccountLegalEntity(_ledgerDimension);
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimension, dimensionDefault);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseExchAdjustment_RU</Name>
				<Source><![CDATA[
    public void reverseExchAdjustment_RU(boolean _useVoucherDate = true)
    {
        CustVendTrans                       localCustVendTrans      = this.initCustVendTransBuffer();
        CustVendTrans                       exchRateTrans           = this.initCustVendTransBuffer();
        CustVendSettlement                  localCustVendSettlement = this.initCustVendSettlementBuffer();
        LedgerBondClient_RU                 ledgerBondClient;
        TransDate                           amountExchDate;
        Voucher                             amountExchVoucher;
        CustVendReversePostingLog_RU        postingLog;
        LedgerVoucherObject                 ledgerVoucherObject;
        int                                 i;
        container                           conDateAndVoucher;
        CustVendTrans_W                     localCustVendTrans_W;
        CustVendTrans_W                     exchRateTrans_W;

        AmountMST                           exchAdjustmentAmountAccounting;
        AmountMST                           settlementExchAdjAccounting;
        AmountMSTSecondary                  exchAdjustmentAmountReporting;
        AmountMSTSecondary                  settlementExchAdjReporting;

        CustVendTransPostingLog_RU          custVendTransPostingLogAccounting;
        CustVendTransPostingLog_RU          custVendTransPostingLogReporting;
        boolean                             emptyRecordCorrectAccounting;
        boolean                             emptyRecordCorrectReporting;
        CustVendAdvAdjustmentDocUpdate_W    custVendAdvAdjustmentDocUpdate;
        Set                                 reversedFactureJourSet;
        CustVendTransData                   custVendTransData;
        RefTableId                          refTableId = custVendSettlement.TableId == tableNum(CustSettlement) ? tableNum(CustTrans) : tableNum(VendTrans);

        if (CustVendTransPostingLog_RU::find(custVendSettlement, CustVendTransPostingLogType_RU::ExchAmountDiff))
        {
            custVendTransPostingLogType = CustVendTransPostingLogType_RU::ExchAmountDiff;
        }
        else if (CustVendTransPostingLog_RU::find(custVendSettlement, CustVendTransPostingLogType_RU::GainLossCurrencyDeal))
        {
            custVendTransPostingLogType = CustVendTransPostingLogType_RU::GainLossCurrencyDeal;
        }
        else
        {
            custVendTransPostingLogType = CustVendExchAdjustment_W::isAdvanceAdjustment(null, custVendTrans, custVendTransOffset) ?
                                          CustVendTransPostingLogType_RU::AdvanceAdjustment                                       :
                                          CustVendTransPostingLogType_RU::ExchAdjustment;
            custVendExchAdjParm         = CustVendExchAdjParm_W::newFromParm(custVendTrans,
                                                                             this.isExchAmountDiff_RU(),
                                                                             false,
                                                                             CustVendExchAdjustment_W::isAdvanceAdjustment(null,
                                                                                                                           custVendTrans,
                                                                                                                           custVendTransOffset) ?
                                                                             LedgerTransType::AdvanceAdjustment_RU                              :
                                                                             LedgerTransType::ExchAdjustment);
        }

        conDateAndVoucher = this.custVendSettleRef_RU(custVendSettlement, custVendTransPostingLogType);

        postingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement, ledgerVoucher, true);
        postingLog.voucherStateSave();
        postingLog.addAllowedPostingLogType(custVendTransPostingLogType);

        custVendTrans.ExchAdjustmentRealized -= custVendSettlement.ExchAdjustment;
        custVendTrans.ExchAdjustment         -= custVendSettlement.ExchAdjustment;

        custVendTrans.ReportingExchAdjustmentRealized   -= custVendSettlement.ExchAdjustmentReporting;
        custVendTrans.ExchAdjustmentReporting           -= custVendSettlement.ExchAdjustmentReporting;

        for (i = 1 ; i <= conLen(conDateAndVoucher) ; i++)
        {
            [amountExchDate,
             amountExchVoucher,
             exchAdjustmentAmountAccounting,
             settlementExchAdjAccounting,
             exchAdjustmentAmountReporting,
             settlementExchAdjReporting] = conPeek(conDateAndVoucher, i);

            localCustVendTrans.OffsetRecId          = custVendTrans.RecId;
            localCustVendTrans.AccountNum           = custVendTrans.AccountNum;
            localCustVendTrans.Invoice              = custVendTrans.Invoice;
            localCustVendTrans.Approved             = NoYes::Yes;
            localCustVendTrans.CurrencyCode         = custVendTrans.CurrencyCode;
            localCustVendTrans.DefaultDimension     = custVendTrans.DefaultDimension;
            localCustVendTrans.TransDate            = transactionDate;
            localCustVendTrans.AmountCur            = 0;
            localCustVendTrans.SettleAmountCur      = 0;
            localCustVendTrans.Settlement           = NoYes::No;
            localCustVendTrans.Closed               = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);

            localCustVendTrans.LastSettleDate       = localCustVendTrans.TransDate;
            localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
            localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
            localCustVendTrans.LastSettleCompany    = custVendTrans.company();

            switch (custVendTransPostingLogType)
            {
                case CustVendTransPostingLogType_RU::AdvanceAdjustment :
                    localCustVendTrans.TransType = LedgerTransType::AdvanceAdjustment_RU;
                    break;

                case CustVendTransPostingLogType_RU::GainLossCurrencyDeal :
                    localCustVendTrans.TransType = LedgerTransType::GainLossCurrencyDeal_RU;
                    break;

                default :
                    localCustVendTrans.TransType = LedgerTransType::ExchAdjustment;
            }

            select firstonly exchRateTrans
                where exchRateTrans.OffsetRecId == custVendTrans.RecId
                  && (exchRateTrans.TransType   == LedgerTransType::ExchAdjustment
                  ||  exchRateTrans.TransType   == LedgerTransType::AdvanceAdjustment_RU
                  ||  exchRateTrans.TransType   == LedgerTransType::GainLossCurrencyDeal_RU)
                  &&  exchRateTrans.TransDate   == amountExchDate
                  &&  exchRateTrans.Voucher     == amountExchVoucher;

            localCustVendTrans.PostingProfile = exchRateTrans.PostingProfile;

            localCustVendTrans.DefaultDimension     = AgreementHeaderExt_RU::createAgreementDimension(
                AgreementHeaderExt_RU::findByDefaultDimension(localCustVendTrans.DefaultDimension).RecId,
                exchRateTrans.DefaultDimension);

            exchRateTrans_W = exchRateTrans.CustVendTrans::getCustVendTrans_W();
            localCustVendTrans_W = localCustVendTrans.CustVendTrans::getCustVendTrans_W();
            localCustVendTrans_W.DefaultDimensionReporting_RU = AgreementHeaderExt_RU::createAgreementDimension(
                AgreementHeaderExt_RU::findByDefaultDimension(localCustVendTrans.DefaultDimension).RecId,
                exchRateTrans_W.DefaultDimensionReporting_RU);

            localCustVendTrans.Correct                      = !exchRateTrans.Correct;
            localCustVendTrans_W.CorrectReporting_RU          = !exchRateTrans_W.CorrectReporting_RU;
            localCustVendTrans.CustVendTrans::packCustVendTrans_W(localCustVendTrans_W);

            ledgerVoucher.findLedgerVoucherObject().parmTransDate (localCustVendTrans.TransDate);
            ledgerVoucher.findLedgerVoucherObject().parmCorrection(localCustVendTrans.Correct);

            postingLog.setTaxReverseTax(new TaxReverseTaxAmountDiff_RU(ledgerVoucher.lastVoucher(),
                                                                       ledgerVoucher.lastTransDate(),
                                                                       ''));
            localCustVendTrans.data(localCustVendTrans);

            postingLog.setAllowedVoucher(amountExchVoucher);

            localCustVendTrans.AmountMST                        = exchAdjustmentAmountAccounting;
            localCustVendTrans.ExchRate                         = 100;
            localCustVendTrans.SettleAmountMST                  = localCustVendTrans.AmountMST;
            localCustVendTrans.ExchAdjustmentRealized           = -localCustVendTrans.AmountMST;
            localCustVendTrans.ExchAdjustment                   = -localCustVendTrans.AmountMST;

            localCustVendTrans.ReportingCurrencyAmount = exchAdjustmentAmountReporting;
            localCustVendTrans.ReportingCurrencyExchRate = 100.0;
            localCustVendTrans.ReportingCurrencyCrossRate = 100.0;
            localCustVendTrans.SettleAmountReporting = localCustVendTrans.ReportingCurrencyAmount;
            localCustVendTrans.ReportingExchAdjustmentRealized = -localCustVendTrans.ReportingCurrencyAmount;
            localCustVendTrans.ExchAdjustmentReporting = -localCustVendTrans.ReportingCurrencyAmount;

            localCustVendTrans.Voucher                          = amountExchVoucher;

            select firstonly Correct from custVendTransPostingLogAccounting
                where custVendTransPostingLogAccounting.TransRecId     == custVendSettlement.TransRecId
                  &&  custVendTransPostingLogAccounting.OffSetRecId    == custVendSettlement.OffsetRecId
                  &&  custVendTransPostingLogAccounting.TransDate      == amountExchDate
                  &&  custVendTransPostingLogAccounting.Voucher        == amountExchVoucher
                  &&  custVendTransPostingLogAccounting.PostingLogType == custVendTransPostingLogType
                  && (!custVendTransPostingLogAccounting.LedgerDimension        || custVendTransPostingLogAccounting.InventVoucher)
                  && (!custVendTransPostingLogAccounting.OffsetLedgerDimension  || custVendTransPostingLogAccounting.InventVoucher)
                  && !custVendTransPostingLogAccounting.IsTaxed
                  &&  custVendTransPostingLogAccounting.RefTableId     == refTableId
                  &&  custVendTransPostingLogAccounting.AmountMST
                  && !custVendTransPostingLogAccounting.AmountMSTSecond;

            emptyRecordCorrectAccounting = custVendTransPostingLogAccounting.Correct;

            select firstonly Correct from custVendTransPostingLogReporting
                where custVendTransPostingLogReporting.TransRecId     == custVendSettlement.TransRecId
                  &&  custVendTransPostingLogReporting.OffSetRecId    == custVendSettlement.OffsetRecId
                  &&  custVendTransPostingLogReporting.TransDate      == amountExchDate
                  &&  custVendTransPostingLogReporting.Voucher        == amountExchVoucher
                  &&  custVendTransPostingLogReporting.PostingLogType == custVendTransPostingLogType
                  && (!custVendTransPostingLogReporting.LedgerDimension       || custVendTransPostingLogAccounting.InventVoucher)
                  && (!custVendTransPostingLogReporting.OffsetLedgerDimension || custVendTransPostingLogAccounting.InventVoucher)
                  && !custVendTransPostingLogReporting.IsTaxed
                  &&  custVendTransPostingLogReporting.RefTableId     == refTableId
                  && !custVendTransPostingLogReporting.AmountMST
                  &&  custVendTransPostingLogReporting.AmountMSTSecond;

            emptyRecordCorrectReporting = custVendTransPostingLogReporting.Correct;

            if (custVendTransPostingLogType == CustVendTransPostingLogType_RU::AdvanceAdjustment)
            {
                reversedFactureJourSet = this.restoreAdvanceAdjFacture_RU(amountExchDate, amountExchVoucher);
            }
            else
            {
                this.restoreAmountDiffFacture_RU(amountExchDate,amountExchVoucher);
            }

            if (custVendTransPostingLogType == CustVendTransPostingLogType_RU::ExchAmountDiff ||
               (custVendExchAdjParm && custVendExchAdjParm.inheritInvoicePosting() &&
                 custVendTransPostingLogType != CustVendTransPostingLogType_RU::GainLossCurrencyDeal))
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(amountExchVoucher, transactionDate);

                if (! ledgerVoucherObject)
                {
                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(amountExchVoucher,
                                                                          transactionDate,
                                                                          ledgerVoucher.parmSysModuleDefault(),
                                                                          ledgerVoucher.findLedgerVoucherObject().parmLedgerTransType());
                    ledgerVoucherObject.parmVoucherCheck(false);
                    ledgerVoucherObject.lastTransTxt(strFmt('%1 %2 %3 ', "@SYS4412", "@SYS12371", amountExchVoucher));
                    ledgerVoucher.addVoucher(ledgerVoucherObject);
                }

                ledgerVoucher.lastVoucher(amountExchVoucher);
                ledgerVoucher.lastTransDate(ledgerVoucherObject.parmAccountingDate());

                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                if (custVendTransPostingLogAccounting)
                {
                    ledgerVoucherObject.parmCorrection(!emptyRecordCorrectAccounting);
                }

                if (custVendTransPostingLogReporting)
                {
                    ledgerVoucherObject = ledgerVoucher.findOrCreateReferenceSecCur_RU();
                    ledgerVoucherObject.parmCorrection(!emptyRecordCorrectReporting);
                    ledgerVoucher.restoreReferenceSecCur_RU();
                }

                this.reverseInventSumAdjust_RU(amountExchDate,
                                               amountExchVoucher,
                                               localCustVendTrans,
                                               ledgerVoucher);
                if (ledgerBondClient)
                {
                    ledgerBondClient.bondLog2Log(transactionDate);
                    ledgerBondClient.removeCurrentLogObject();
                }
            }

            if (custVendTransPostingLogType == CustVendTransPostingLogType_RU::ExchAmountDiff)
            {
                localCustVendTrans.CurrencyCode    = CompanyInfoHelper::standardCurrency();
                localCustVendTrans.AmountCur       = localCustVendTrans.AmountMST;
                localCustVendTrans.SettleAmountCur = localCustVendTrans.AmountMST;
            }

            custVendTransData = CustVendTransData::construct(localCustVendTrans);
            custVendTransData.parmIsGroupSettlement_W(true);

            localCustVendSettlement = custVendTransData.updateSettlement(custVendTransOpen);

            custVendAdvAdjustmentDocUpdate = CustVendAdvAdjustmentDocUpdate_W::newFromReverseSettlement(transactionDate,
                                                                                                        reversedFactureJourSet,
                                                                                                        localCustVendTrans,
                                                                                                        amountExchDate,
                                                                                                        amountExchVoucher);
            postingLog.setCustVendAdvAdjustmentDocUpdate(custVendAdvAdjustmentDocUpdate);
            postingLog.doReverse(true, _useVoucherDate);
            reversePostingLogSet = Set::union(reversePostingLogSet, postingLog.getReversePostingLogSet());

            localCustVendTrans.Txt       = strFmt('%1 %2 %3 ', "@SYS4412", "@SYS12371", localCustVendTrans.Voucher);

            if (exchAdjustmentAmountAccounting || exchAdjustmentAmountReporting)
            {
                custVendTransSettlement.addTransAndSettlement(localCustVendTrans, localCustVendSettlement, settlementGroupPlaceHolder);
            }
        }

        postingLog.voucherStateRestore();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseFixedAssetDiscount</Name>
				<Source><![CDATA[
    //  This method reverses any cash discounts that might have been applied to a fixed asset.
    private AmountCur reverseFixedAssetDiscount(CustVendTrans  _localCustVendTransOffset,
                                                CustVendTrans  _localCustVendTrans,
                                                AmountCur      _cashDiscTaxAmount)
    {
        AmountCur               totalAssetCashDiscReversal;
        AssetBookTableDerived   assetBookTableDerived;
        AssetTrans              assetTrans;
        AssetTrans              assetTransGrp;
        AssetPost               assetPost;
        //
        //  If there are any assetTrans rows that match the custVendTrans
        //  voucher, transDate, are also Acquisition or Acquisition Adjustment
        //  type asset transactions, and are not for derived books.
        //
        //  Since the AssetTrans table does not indicate which transactions are
        //  original and which are derived this process is assuming that AP Invoice
        //  Fixed Asset transactions are only made on original value models
        //  and not derived ones.
        //
        //  Should an AP invoice contain transaction lines for a fixed asset's
        //  value model and derived value model there would not be anyway to
        //  distinguish between the derived value model transaction posted directly
        //  from the AP invoice and the one that was posted as a result of the posting
        //  of original value model's transactions.
        //
        //  One approach to correct this issue would be to make a data model change in the
        //  AssteTrans table that would clearly identify transactions created through automatic
        //  derived value model handling.
        //
        //  The derived book assets will be handled when the
        //  original asset book's cash discount is posted.
        //
        while select assetTransGrp
            group by AssetId, BookId
            where assetTransGrp.Voucher   == _localCustVendTransOffset.Voucher &&
                  assetTransGrp.TransDate == _localCustVendTransOffset.TransDate &&
                  (assetTransGrp.TransType == AssetTransType::Acquisition ||
                   assetTransGrp.TransType == AssetTransType::AcquisitionAdj)
        notexists join assetBookTableDerived
            where assetBookTableDerived.BookIdDerived == assetTransGrp.BookId
        {
            //  For each individual Fixed Asset cash discount transaction found.
            select firstonly assetTrans
                where assetTrans.AssetId   == assetTransGrp.AssetId &&
                      assetTrans.BookId    == assetTransGrp.BookId &&
                      assetTrans.Voucher   == _localCustVendTransOffset.Voucher &&
                      assetTrans.TransDate == _localCustVendTransOffset.TransDate &&
                      (assetTrans.TransType == AssetTransType::Acquisition ||
                       assetTransGrp.TransType == AssetTransType::AcquisitionAdj);

            //  If there is a cash discount
            if (assetTrans.AmountMST)
            {
                if (assetTrans.CashDiscBaseTransId)
                {
                    AssetTrans originalAssetTrans = AssetTrans::find(assetTrans.CashDiscBaseTransId);

                    // Create a AssetPost object for handling the cash discount reversal based on original transaction
                    assetPost = AssetPost::newCashDiscTrans(originalAssetTrans, _localCustVendTrans, ledgerVoucher, assetTrans.AmountMST, -assetTrans.CashDiscBaseAmountMST);
                }
                else
                {
                    // This part is needed to support discount transactions without link to original one
                    // Create a AssetPost object for handling the cash discount reversal.
                    assetPost = AssetPost::newCashDiscTrans(assetTrans, _localCustVendTrans, ledgerVoucher, assetTrans.AmountMST);
                }

                //  If the asset post transaction is ok
                if (assetPost.check())
                {
                    //  If there is a non-discountable tax amount for the entire cash discount.
                    if (_cashDiscTaxAmount)
                    {
                        //
                        //  If the cash discount is calculated from amounts
                        //  that include sales tax.
                        //
                        if (this.cashDiscVat())
                        {
                            //
                            //  The sales tax reversal will handle the Fixed Asset GL reversal
                            //  therefore only the AssetTrans table requires an update.
                            //
                            //  AssetPost.post(false, true) will post to the AssetTrans table
                            //  for the Value Model and Derived Book but it will not update The GL.
                            //
                            assetPost.post(false, true);
                        }
                        else
                        {
                            //
                            //  This code path would require a valid TaxTrans row as a result of "this.findTaxTrans()"
                            //
                            //  It is current unknown how to create a TaxTrans row that could meet could
                            //  successfully meet the requirements of this method. It is therefore best if
                            //  application throws a unique error message at this point instead of possibly
                            //  damaging any data.
                            //  If a client receives this error it is important to collect as mush information as
                            //  possible so the process for this code path can be resolved.

                            throw error("@SYS100275");
                        }
                    }
                    else
                    {
                        //
                        //  The sales tax reversal will not handle the Fixed Asset GL reversal
                        //  therefore the AssetTrans table and the GL requires an update.
                        //
                        //  AssetPost.post(true, true) will post to the AssetTrans table
                        //  for the Value Model and Derived Book and it will update The GL.
                        //
                        assetPost.post(true, true);
                        //
                        //  Add a blank account value to the conLedgerAccount container.
                        //  This will cause the default cash discount account to be used.
                        //
                        conLedgerAccount    += '';
                        //
                        //  Add the assetTrans.AmountMst (cash discount reversal) to the
                        //  contaxBaseAmountCur to offset the portion of the cash discount
                        //  reversal owned by the Fixed Asset transaction.
                        //
                        conTaxBaseAmountCur += assetTrans.AmountMST;
                        //
                        //  Accumulate the assetTrans.AmountMst (cash discount reversal)
                        //  to the cashDisctaxAmount so it will net correctly for
                        //  updating the AP summary account.
                        //
                        totalAssetCashDiscReversal += assetTrans.AmountMST;
                    }
                }
            }
        }
        //  Return the net change to _cashDiscTaxAmount.
        return totalAssetCashDiscReversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseInventSumAdjust_RU</Name>
				<Source><![CDATA[
    protected void reverseInventSumAdjust_RU(TransDate        _reverseDate,
                                             Voucher          _reverseVoucher,
                                             CustVendTrans    _custVendTrans,
                                             LedgerVoucher    _ledgerVoucher = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseInvoicePaymentSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and updates transactions to reverse the settlement of an invoice or payment.
    /// </summary>
    protected void reverseInvoicePaymentSettlement()
    {
        boolean         isTaxWithholdVendTrans;
        TransDate       taxWithholdDate;
        // <GTH>
        boolean         isTaxWithholdCustTrans_TH = false;
        // </GTH>
        boolean         isTaxWithholdCustTrans_GB = false;
        boolean         isAdvancedTaxWithholdCustTrans = false;


        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            isTaxWithholdVendTrans = TaxWithholdTrans::existVendTransPaym(custVendTrans);
        }
        // <GBR>
        else if (BrazilParameters::isEnabled() && custVendTrans.TableId == tableNum(CustTrans))
        {
            isTaxWithholdVendTrans = TaxWithholdTrans::existCustTransPaym(custVendTrans);
        }
        // </GBR>

        // <GTH>
        if (isTaxWithholdEnabled_TH && custVendTrans.TableId == tableNum(CustTrans))
        {
            isTaxWithholdCustTrans_TH = TaxWithholdTrans::existCustTransPaym(custVendTrans);
        }
        // </GTH>
        else if (countryRegionGB && custVendTrans.TableId == tableNum(CustTrans))
        {
            isTaxWithholdCustTrans_GB = TaxWithholdTrans::existCustTransPaym(custVendTrans);
        }
        else if (TaxWithhold::enableAdvancedTaxWithhold() && custVendTrans.TableId == tableNum(CustTrans))
        {
            isAdvancedTaxWithholdCustTrans = TaxWithholdTrans::existCustTransPaym(custVendTrans);
        }

        // adjust exchange adjustment amounts on invoice or payment custVendTrans and custVendTransOpen
        if (custVendTransRecId == custVendTrans.RecId)
        {
            custVendTrans.ExchAdjustment += totalUnrealizedExchAdjCustVendTrans + totalRealizedExchAdjCustVendTrans;
            custVendTrans.ExchAdjustmentRealized += totalRealizedExchAdjCustVendTrans;
            custVendTrans.ExchAdjustmentUnrealized += totalUnrealizedExchAdjCustVendTrans;

            custVendTrans.ExchAdjustmentReporting += totalUnrealizedReportingExchAdjCustVendTrans + totalRealizedReportingExchAdjCustVendTrans;
            custVendTrans.ReportingExchAdjustmentRealized += totalRealizedReportingExchAdjCustVendTrans;
            custVendTrans.ReportingExchAdjustmentUnrealized += totalUnrealizedReportingExchAdjCustVendTrans;

            this.restoreCustVendTransOpen(totalUnrealizedExchAdjCustVendTrans, totalUnrealizedReportingExchAdjCustVendTrans);
        }
        else if (custVendTransOffsetRecId == custVendTrans.RecId)
        {
            custVendTrans.ExchAdjustment += totalUnrealizedExchAdjCustVendTransOffset + totalRealizedExchAdjCustVendTransOffset;
            custVendTrans.ExchAdjustmentRealized += totalRealizedExchAdjCustVendTransOffset;
            custVendTrans.ExchAdjustmentUnrealized += totalUnrealizedExchAdjCustVendTransOffset;

            custVendTrans.ExchAdjustmentReporting += totalUnrealizedReportingExchAdjCustVendTransOffset + totalRealizedReportingExchAdjCustVendTransOffset;
            custVendTrans.ReportingExchAdjustmentRealized += totalRealizedReportingExchAdjCustVendTransOffset;
            custVendTrans.ReportingExchAdjustmentUnrealized += totalUnrealizedReportingExchAdjCustVendTransOffset;

            this.restoreCustVendTransOpen(totalUnrealizedExchAdjCustVendTransOffset, totalUnrealizedReportingExchAdjCustVendTransOffset);
        }
        else
        {
            // no exchange adjustment
            this.restoreCustVendTransOpen(0, 0);
        }

        this.deleteBankChequePaymTrans();
        this.updateCustVendTrans();

        this.reverseSettlement(custVendSettlement);
        this.updateSettlement();

        // Update Advance Definition
        this.updateAdvanceDefinition(custVendTrans, custVendSettlement.SettleAmountCur);

        if (isTaxWithholdVendTrans
            // <GTH>
            || isTaxWithholdCustTrans_TH
            // </GTH>
            || isTaxWithholdCustTrans_GB
            || isAdvancedTaxWithholdCustTrans
            )
        {
            // create additional vend trans to offset the existing record
            if (!this.isDatePrincipleDateOfPayment())
            {
                taxWithholdDate = diffTransDate;
            }
            else
            {
                taxWithholdDate = custVendTrans.TransDate;
            }

            // create additional vend trans to offset the existing record
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                this.reverseTaxWithold_BR(taxWithholdDate);
                if (custVendTrans.TableId == tableNum(VendTrans))
                {
                    TaxWithhold::createVendTransForReverseTaxWithhold(custVendTrans, voucher, taxWithholdDate);
                }
                else
                {
                    TaxWithhold_CustPaym::createCustTransForReverseTaxWithhold_BR(custVendTrans, voucher, taxWithholdDate);
                }
            }
            // </GBR>
            // <GTH>
            else if (isTaxWithholdCustTrans_TH || isTaxWithholdCustTrans_GB || isAdvancedTaxWithholdCustTrans)
            {
                TaxWithhold::createCustVendTransForReverse(custVendTrans, voucher, taxWithholdDate);
            }
            else
            {
                // </GTH>
                TaxWithhold::createVendTransForReverseTaxWithhold(custVendTrans, voucher, taxWithholdDate);
                // <GTH>
            }
            // </GTH>
        }

        if (!FeatureExt::isFeatureEnabled('Dynamics.AX.Application.TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature')) // FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance()))
        {
            if (TaxWithholdParameters_IN::checkTaxParameters() && custVendTrans.TableId == tableNum(CustTrans))
            {
                CustTrans custTrans = custVendTrans;
                CustVendSettle::processInterimTaxWithholdWithReceiptDate(custTrans, custVendSettlement.SettleAmountMST, false, custTrans.TransDate);
            }
        }

        // Reverse the generated withholding tax at settlement stage.
        if (TaxWithholdParameters_IN::checkTaxParameters() // FeatureStateProvider::isFeatureEnabled(TaxWHTReverseTDSForVendorFeature::instance())
            && custVendTrans.TableId == tableNum(VendTrans))
        {
            TaxWithholdCustVendSettlementHelper_INExt::processWithholdingTaxReverseSettlement_IN(
                custVendTrans,
                custVendSettlement.SettlementGroup,
                this.parmTransDate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseRelatedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the related transactions for the specified voucher and date.
    /// </summary>
    /// <param name="_voucherToReverse">
    ///    The voucher number of the transactions to reverse.
    /// </param>
    /// <param name="_transDateToReverse">
    ///    The transaction date of the transactions to reverse.
    /// </param>
    /// <param name="_accountNum">
    ///    The account number of the customer or vendor of the transactions to reverse.
    /// </param>
    /// <remarks>
    ///    This method creates reversal transactions for the general journal and the <c>TaxTrans</c>,
    ///    <c>TaxWithholdTrans</c>, and <c>AssetTrans</c> records.
    /// </remarks>
    protected void reverseRelatedTransactions(Voucher _voucherToReverse, TransDate _transDateToReverse, CustVendAC _accountNum)
    {
        CustVendSettlementOffsetVoucher custVendSettlementOffsetVoucher = this.initCustVendSettlementOffsetVoucher();

        // Reverse using the current settlement voucher in the current company.
        if (!reverseVoucherProcessed.in([curext(), _voucherToReverse, _transDateToReverse]))
        {
            this.reverseTaxTransGeneralJournal(_voucherToReverse, _transDateToReverse);
            this.reverseTaxWithholdTrans(_voucherToReverse, _transDateToReverse);
            this.reverseAssetTrans(_voucherToReverse, _transDateToReverse);
            reverseVoucherProcessed.add([curext(), _voucherToReverse, _transDateToReverse]);
        }

        // Reverse tax trans and general journal account entry using intercompany vouchers that might have been created if the tax company was different than the settlement company.
        while select * from custVendSettlementOffsetVoucher
            where custVendSettlementOffsetVoucher.SettlementVoucher == _voucherToReverse
                && custVendSettlementOffsetVoucher.OffsetTransDate == _transDateToReverse
                && custVendSettlementOffsetVoucher.AccountNum == _accountNum
                && custVendSettlementOffsetVoucher.OffsetType == CustVendSettlementOffsetVoucherType::Tax
        {
            if (!reverseVoucherProcessed.in([custVendSettlementOffsetVoucher.OffsetCompany, custVendSettlementOffsetVoucher.OffsetVoucher, custVendSettlementOffsetVoucher.OffsetTransDate]))
            {
                changecompany(custVendSettlementOffsetVoucher.OffsetCompany)
                {
                    this.reverseTaxTransGeneralJournal(custVendSettlementOffsetVoucher.OffsetVoucher, custVendSettlementOffsetVoucher.OffsetTransDate);
                }

                reverseVoucherProcessed.add([custVendSettlementOffsetVoucher.OffsetCompany, custVendSettlementOffsetVoucher.OffsetVoucher, custVendSettlementOffsetVoucher.OffsetTransDate]);
            }
        }

        // Reset the ledger and voucher to the current company.
        this.findLedgerVoucherByCompany();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePennyDiff</Name>
				<Source><![CDATA[
    public void reversePennyDiff()
    {
        TaxOverUnderPayment          taxOverUnderPayment;
        RecordSortedList             rslTmpOverUnderReverseTax;
        TaxAmount                    taxAmountToReverse;
        TmpSettleOverUnderReverseTax tmpSettleOverUnderReverseTax;
        CustVendTrans                localCustVendTransInvoice = this.initCustVendTransBuffer();
        int                          moduleSign = (custVendTrans.TableId == tableNum(VendTrans) ? 1 : -1);
        LedgerDimensionDefaultAccount  operationLedgerDimension = LedgerSystemAccounts::getDefaultAccount(custVendTrans.TableId == tableNum(CustTrans) ? LedgerPostingType::CustCashDisc : LedgerPostingType::VendCashDisc);

        CustVendTrans                localCustVendTrans  = this.initCustVendTransBuffer();
        ExchRate                     reverseExchRate     = custVendTrans.AmountMST / custVendTrans.AmountCur * 100;

        // <GEERU>
        LedgerBondClient_RU          ledgerBondClient;
        boolean                      countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        LedgerPostingController      ledgerPostingController;

        LedgerVoucherTransObject     ledgerVoucherTransObject;
        LedgerVoucherObject          ledgerVoucherObject;
        CurrencyExchangeHelper       exchangeRateHelper;
        LedgerDimensionAccount       mergedLedgerDimension;

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerBondClient    = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        }
        // </GEERU>
        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

        if (custVendSettlement.PennyDiff)
        {
            if (!this.isItPennyDiff())
            {
                // This code only executes for a single company where so don't need to
                // check OffsetCompany field.
                select firstonly localCustVendTransInvoice
                    where (localCustVendTransInvoice.RecId == custVendSettlement.OffsetRecId
                       || localCustVendTransInvoice.RecId == custVendSettlement.TransRecId)
                       &&  localCustVendTransInvoice.Invoice;

                if (localCustVendTransInvoice.AmountMST * moduleSign > 0)
                {
                    //credit note
                    localCustVendTransInvoice.data(custVendTrans);
                }

                rslTmpOverUnderReverseTax                   = new RecordSortedList(tableNum(TmpSettleOverUnderReverseTax));
                rslTmpOverUnderReverseTax.sortOrder(fieldNum(TmpSettleOverUnderReverseTax,RefRecId));
                tmpSettleOverUnderReverseTax.clear();
                tmpSettleOverUnderReverseTax.RefRecId        = localCustVendTransInvoice.RecId;
                tmpSettleOverUnderReverseTax.Voucher         = localCustVendTransInvoice.Voucher;
                tmpSettleOverUnderReverseTax.TransDate       = localCustVendTransInvoice.TransDate;
                tmpSettleOverUnderReverseTax.SettleAmountMST = localCustVendTransInvoice.SettleAmountMST;
                tmpSettleOverUnderReverseTax.AmountMST       = -localCustVendTransInvoice.AmountMST;
                rslTmpOverUnderReverseTax.ins(tmpSettleOverUnderReverseTax, true);

                taxOverUnderPayment = new TaxOverUnderPayment(custVendSettlement.PennyDiff * reverseExchRate / 100,
                                                              rslTmpOverUnderReverseTax);

                taxOverUnderPayment.parmOperationLedgerDimension(operationLedgerDimension);

                taxOverUnderPayment.setReverseTableId(custVendTrans.TableId);
                taxOverUnderPayment.setReverseRecId(custVendTrans.RecId);
                taxAmountToReverse = taxOverUnderPayment.calcAndPost(ledgerPostingController) * 100 / (reverseExchRate ? reverseExchRate : 100);
            }

            this.setupReversePennyDiff();

            // create new custVendTrans as reverse for the pennydiff custVendTrans that was created when settling
            localCustVendTrans.OffsetRecId      = custVendTrans.RecId;
            localCustVendTrans.AccountNum       = custVendTrans.AccountNum;
            localCustVendTrans.Approved         = NoYes::Yes;
            localCustVendTrans.CurrencyCode     = custVendTrans.CurrencyCode;
            localCustVendTrans.DefaultDimension = custVendTrans.DefaultDimension;
            localCustVendTrans.TransType        = LedgerTransType::PennyDifference;
            localCustVendTrans.Voucher          = voucher;
            localCustVendTrans.TransDate        = diffTransDate;

            localCustVendTrans.AmountCur    = -custVendSettlement.PennyDiff;
            localCustVendTrans.AmountMST    = -CurrencyExchangeHelper::mstAmount(custVendSettlement.PennyDiff, localCustVendTrans.CurrencyCode, localCustVendTrans.TransDate, UnknownNoYes::No, reverseExchRate);
            localCustVendTrans.ExchRate     = reverseExchRate;

            localCustVendTrans.SettleAmountCur  = localCustVendTrans.AmountCur;
            localCustVendTrans.SettleAmountMST  = localCustVendTrans.AmountMST;
            localCustVendTrans.Settlement       = NoYes::No;
            localCustVendTrans.Closed           = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);

            localCustVendTrans.LastSettleDate       = dateNull();
            localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
            localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
            localCustVendTrans.LastSettleCompany    = custVendTrans.DataAreaId;

            ledgerPostingController.getReference().lastTransTxt(strFmt('%1 %2 %3 ',"@SYS4768", "@SYS14204", localCustVendTrans.Invoice));

            custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, settlementGroupPlaceHolder);

            ledgerVoucherObject = ledgerPostingController.getReference();
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                                        ledgerVoucherObject.parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(reverseExchRate);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(pennyDiffLedgerDimension, localCustVendTrans.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    ledgerVoucherObject,
                                                                    LedgerPostingType::MSTDiff,
                                                                    mergedLedgerDimension,
                                                                    localCustVendTrans.CurrencyCode,
                                                                    -localCustVendTrans.AmountCur - taxAmountToReverse,
                                                                    exchangeRateHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(custVendTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(custVendTrans.RecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.summaryLedgerDimension(), localCustVendTrans.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    ledgerVoucherObject,
                                                                    LedgerPostingType::MSTDiff,
                                                                    mergedLedgerDimension,
                                                                    localCustVendTrans.CurrencyCode,
                                                                    localCustVendTrans.AmountCur,
                                                                    exchangeRateHelper);

            ledgerVoucherTransObject.parmSourceTableId(localCustVendTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(localCustVendTrans.RecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePennyDiff_RU</Name>
				<Source><![CDATA[
    protected void reversePennyDiff_RU()
    {
        CustVendTrans                  localCustVendTrans  = this.initCustVendTransBuffer();
        LedgerBondClient_RU            ledgerBondClient;
        CustVendTransPostingLog_RU     custVendTransPostingLog;
        LedgerVoucherObject            ledgerVoucherObject;
        TaxReverseTaxCustVendSettle_RU taxReverseTax;
        AmountCur                      pennyDiffTaxAmount;
        LedgerVoucherTransObject       transObject;

        CurrencyExchangeHelper         exchangeHelper;

        if (custVendSettlement.PennyDiff)
        {
            select firstonly forupdate custVendTransPostingLog
                where custVendTransPostingLog.RefTableId        == custVendTrans.TableId
                   && custVendTransPostingLog.TransRecId        == custVendSettlement.TransRecId
                   && custVendTransPostingLog.TransCompany      == custVendSettlement.TransCompany
                   && custVendTransPostingLog.TransDate         == custVendSettlement.TransDate
                   && custVendTransPostingLog.Reversed          == NoYes::No
                   && custVendTransPostingLog.PostingLogType    == CustVendTransPostingLogType_RU::PennyDifference;

            localCustVendTrans.OffsetRecId          = custVendTrans.RecId;
            localCustVendTrans.AccountNum           = custVendTrans.AccountNum;
            localCustVendTrans.Approved             = NoYes::Yes;
            localCustVendTrans.CurrencyCode         = custVendTransPostingLog.CurrencyCode;
            localCustVendTrans.LastSettleDate       = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

            localCustVendTrans.DefaultDimension     = AgreementHeaderExt_RU::createAgreementDimension(
                AgreementHeaderExt_RU::findByDefaultDimension(custVendTrans.DefaultDimension).RecId,
                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(custVendTransPostingLog.LedgerDimension));

            localCustVendTrans.TransType            = LedgerTransType::PennyDifference;
            localCustVendTrans.Voucher              = custVendTransPostingLog.Voucher;
            localCustVendTrans.TransDate            = transactionDate;
            localCustVendTrans.AmountCur            = -custVendTransPostingLog.AmountCur;
            localCustVendTrans.AmountMST            = -custVendTransPostingLog.AmountMST;
            localCustVendTrans.ExchRate             = custVendTransPostingLog.AmountCur                                           ?
                                                      custVendTransPostingLog.AmountMST / custVendTransPostingLog.AmountCur * 100 :
                                                      100;
            localCustVendTrans.SettleAmountCur      = localCustVendTrans.AmountCur;
            localCustVendTrans.SettleAmountMST      = localCustVendTrans.AmountMST;
            localCustVendTrans.Settlement           = NoYes::No;
            localCustVendTrans.Closed               = CustVendTransData::construct(localCustVendTrans).maxSettlementDate(localCustVendTrans.TransDate);
            localCustVendTrans.LastSettleDate       = dateNull();
            localCustVendTrans.LastSettleVoucher    = custVendTrans.Voucher;
            localCustVendTrans.LastSettleAccountNum = custVendTrans.AccountNum;
            localCustVendTrans.LastSettleCompany    = custVendTrans.DataAreaId;
            localCustVendTrans.PostingProfile       = custVendTrans.PostingProfile;
            localCustVendTrans.Correct              = ! custVendTransPostingLog.Correct;
            localCustVendTrans.Txt                  = strFmt('%1 %2 %3 ', "@SYS4412", "@SYS12371", localCustVendTrans.Voucher);

            custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, settlementGroupPlaceHolder);

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(custVendTransPostingLog.Voucher, transactionDate);

            if (! ledgerVoucherObject)
            {
                ledgerVoucherObject = LedgerVoucherObject::newVoucher(custVendTransPostingLog.Voucher,
                                                                      transactionDate,
                                                                      ledgerVoucher.parmSysModuleDefault(),
                                                                      ledgerVoucher.findLedgerVoucherObject().parmLedgerTransType());

                ledgerVoucherObject.parmVoucherCheck(false);
                ledgerVoucherObject.parmCorrection(! custVendTransPostingLog.Correct);
                ledgerVoucher.addVoucher(ledgerVoucherObject);
            }

            ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

            ledgerVoucherObject.lastTransTxt(localCustVendTrans.Txt);
            taxReverseTax = new TaxReverseTaxCustVendSettle_RU(custVendTransPostingLog.Voucher,
                                                               transactionDate,
                                                               ledgerVoucherObject.lastTransTxt());
            pennyDiffTaxAmount = taxReverseTax.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher), custVendTransPostingLog.Voucher, custVendTransPostingLog.TransDate);
            if (ledgerBondClient && ! ledgerBondClient.currentLogLength())
            {
                pennyDiffTaxAmount = 0;
            }

            exchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

            transObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::MSTDiff,
                                                                                custVendTransPostingLog.LedgerDimension,
                                                                                CompanyInfoHelper::standardCurrency(),
                                                                                -custVendTransPostingLog.AmountCur,
                                                                                exchangeHelper);
            transObject.parmSourceTableId(localCustVendTrans.TableId);
            transObject.parmSourceRecId(localCustVendTrans.RecId);
            transObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(transObject);

            transObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::MSTDiff,
                                                                                custVendTransPostingLog.OffsetLedgerDimension,
                                                                                CompanyInfoHelper::standardCurrency(),
                                                                                custVendTransPostingLog.AmountCur - pennyDiffTaxAmount,
                                                                                exchangeHelper);
            transObject.parmSourceTableId(localCustVendTrans.TableId);
            transObject.parmSourceRecId(localCustVendTrans.RecId);
            transObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(transObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log();
            }

            custVendTransPostingLog.reversePosting(transactionDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePostingTransLog_RU</Name>
				<Source><![CDATA[
    protected void reversePostingTransLog_RU()
    {
        CustVendPrePaymentReversal   prePaymentReversal;
        CustVendReversePostingLog_RU postingLog;
        boolean                      postVATTransit = true;
        CustTrans                    custTransInvoice;
        CustInvoiceJour              custInvoiceJour;
        #VATTransitionPeriod_RU

        // for sales book system shouldn't reverse vat on pyament transactions during settlement cancelation (after transition period)
        // for invoices posted before transition period
        if (custVendTrans.TableId == tableNum(CustTrans))
        {
            custTransInvoice = custVendTrans.Invoice ? custVendTrans : custVendTransOffset;
            if (custTransInvoice.Invoice                          &&
                custTransInvoice.TransDate < #TransitionStartDate &&
                transactionDate            > #TransitionEndDate   &&
                CustParameters::taxation_RU(custTransInvoice.TransDate) == CustTaxation_RU::OnDelivery)
            {
                custInvoiceJour = CustInvoiceJour::findFromCustTrans(custTransInvoice.Invoice,
                                                                     custTransInvoice.TransDate,
                                                                     custTransInvoice.AccountNum,
                                                                     false,
                                                                     custTransInvoice.Voucher);
                postVATTransit = custInvoiceJour.custInvoiceJour_RU().vatOnPayment_RU;
            }
        }

        postingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement, ledgerVoucher);
        postingLog.setTaxReverseTax(new TaxReverseTaxCustPrepaymentSettle_RU(ledgerVoucher.lastVoucher(),
                                                                             ledgerVoucher.lastTransDate(),
                                                                             ''));

        postingLog.parmCustVendTransSettlement(custVendTransSettlement);
        postingLog.parmSettlementGroupPlaceHolder(settlementGroupPlaceHolder);

        postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::VATTransit);

        if (this.mustReversePrepaymentWithLog_RU())
        {
            postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::PrepaymentStorno);
            postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::PrepaymentStornoVAT);
        }
        else
        {
            if (custVendTrans.Prepayment)
            {
                prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(custVendTrans, custVendTransSettlement, settlementGroupPlaceHolder);
                taxPctAccumulat = prePaymentReversal.reverseReversePrePayment(custVendTrans, custVendSettlement, ledgerVoucher, custVendTrans.CurrencyCode, custVendTrans.AmountCur, taxPctAccumulat);
            }
        }

        postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::Balance);

        postingLog.doReverse(true,true, postVATTransit);
        reversePostingLogSet = Set::union(reversePostingLogSet, postingLog.getReversePostingLogSet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePrepayment</Name>
				<Source><![CDATA[
    void reversePrepayment(CustVendTrans    _custVendTrans,
                           LedgerVoucher    _ledgerVoucher,
                           CurrencyCode     _currencyCode)
    {
        CustVendPrePaymentReversal  prePaymentReversal;
        if (_custVendTrans.Prepayment)
        {
            prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(_custVendTrans, custVendTransSettlement, settlementGroupPlaceHolder);
            taxPctAccumulat = prePaymentReversal.reverseReversePrePayment(_custVendTrans, custVendSettlement, _ledgerVoucher, _currencyCode, _custVendTrans.AmountCur, taxPctAccumulat);
        }
        else
        {
            prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(_custVendTrans, custVendTransSettlement, settlementGroupPlaceHolder);

            if (prePaymentReversal.postingProfileDifference(custVendSettlement) &&
                custVendSettlement.CanBeReversed                                &&
                !this.isOffsetPrepayment(_custVendTrans))
            {
                prePaymentReversal.reversePostingProfileBalance(_custVendTrans, custVendSettlement, _ledgerVoucher, _currencyCode, custVendSettlement.SettleAmountCur);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>CustVendSettlement</c> record to reverse the existing records.
    /// </summary>
    /// <param name="_custVendSettlement">
    ///    The settlement to reverse.
    /// </param>
    public void reverseSettlement(CustVendSettlement _custVendSettlement)
    {
        // create reverse custVendSettlement for the original settled
        CustVendSettlement reverseCustVendSettlement = _custVendSettlement.data();
        if (!this.isDatePrincipleDateOfPayment())
        {
            reverseCustVendSettlement.TransDate = diffTransDate;
        }

        reverseCustVendSettlement.DueDate = _custVendSettlement.DueDate;
        reverseCustVendSettlement.CanBeReversed       = NoYes::No;
        reverseCustVendSettlement.SettlementGroup     = 0;

        reverseCustVendSettlement.SettleAmountCur       = -_custVendSettlement.SettleAmountCur;
        reverseCustVendSettlement.SettleAmountMST       = -_custVendSettlement.SettleAmountMST;
        reverseCustVendSettlement.SettleAmountReporting = -_custVendSettlement.SettleAmountReporting;

        reverseCustVendSettlement.UtilizedCashDisc        = -_custVendSettlement.UtilizedCashDisc;
        reverseCustVendSettlement.ExchAdjustment          = -_custVendSettlement.ExchAdjustment;
        reverseCustVendSettlement.ExchAdjustmentReporting = -_custVendSettlement.ExchAdjustmentReporting;
        reverseCustVendSettlement.PennyDiff               = -_custVendSettlement.PennyDiff;

        reverseCustVendSettlement.SettleTax1099Amount = -_custVendSettlement.SettleTax1099Amount;
        reverseCustVendSettlement.SettleTax1099StateAmount = -_custVendSettlement.SettleTax1099StateAmount;

        reverseCustVendSettlement.SettlementVoucher = voucher;

        reverseCustVendSettlement.ClosedDate = reverseCustVendSettlement.TransDate;

        // <GEERU><GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]))
        {
            if (TaxParameters::find().ReverseSettlementDatePrinciple_W
             || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                reverseCustVendSettlement.TransDate = transactionDate;
            }
            custVendTransSettlement.addSettlement(reverseCustVendSettlement,
                                                  settlementGroupPlaceHolder,
                                                  custVendTrans.TransType,
                                                  _custVendSettlement,
                                                  custVendSettlement.TransDate == transactionDate ? 0 : _custVendSettlement.RecId);
        }
        else
        {
            // </GEECZ></GEERU>
            custVendTransSettlement.addSettlement(reverseCustVendSettlement, settlementGroupPlaceHolder, custVendTrans.TransType, _custVendSettlement);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTax1099Settlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and updates transactions to reverse a 1099 tax transaction.
    /// </summary>
    /// <remarks>
    ///    This method will create the appropriate reversing <c>VendSettlementTax1099</c> record and will
    ///    update 1099 amounts for the vendor invoice and open vendor transaction
    /// </remarks>

    protected void reverseTax1099Settlement()
    {
        VendSettlementTax1099       vendSettlementTax1099;
        VendTrans                   vendTransOffset;
        VendTrans                   vendTrans;
        VendTransOpen               vendTransOpen;
        real                        settlementFator;
        AmountCur                   tax1099Amount;
        AmountCur                   tax1099StateAmount;
        AmountCur                   tax1099AmountSettled;
        AmountCur                   tax1099StateAmountSettled;
        int                         idx;
        real                        setttleAmount;
        real                        discount;
        boolean                     vendSettlementTax1099RevDone;

        for (idx = 1; idx <= conLen(tax1099VendTrans); idx += 6)
        {
            // There will be two settlement records for each 1099 settlement that can be reversed.
            // Need to set this up so that the payment is the vendTrans and the invoice is the
            // vendTransOffset. This information was saved as updateNow() was processing
            // specTrans records. All that needs done here is to loop through the
            // information saved in the tax1099VendTrans container. This container will
            // be processed in sets of six where the first element is the RECID of the
            // vendor payment, the second element is the dataAreaId of the vendor payment,
            // the third element is the RECID of the vendor invoice, the fourth element is
            // the dataAreaId of the vendor invoice, the fifth element is the settlement amount
            // including discounts and the sixth element is the discount.

            vendTrans = VendTrans::findByCompany(conPeek(tax1099VendTrans, idx + 1), conPeek(tax1099VendTrans, idx), false);
            vendTransOffset = VendTrans::findByCompany(conPeek(tax1099VendTrans, idx + 3), conPeek(tax1099VendTrans, idx + 2), true);
            select forupdate crosscompany vendTransOpen where vendTransOpen.RefRecId == vendTransOffset.RecId &&
                                        vendTransOpen.DueDate  == vendTransOffset.DueDate;
            setttleAmount =  conPeek(tax1099VendTrans, idx + 4) * -1;
            discount = conPeek(tax1099VendTrans, idx + 5) * -1;

            if (vendTrans && vendTransOffset && setttleAmount != 0 &&
                    (vendTransOffset.SettleTax1099Amount != 0 || vendTransOffset.SettleTax1099Amount != 0))
            {
                // The 1099 settlement amount can be recalculated given the invoice amount and the settlement amount.
                // By using these amounts the ratio of settlement amount to invoice amount can be obtained.
                // This same ratio can then be used to calculate what the 1099 amount was for this settlement
                // This information is needed to ensure that the correct VendSettlement1099 record is retrieved for
                // reversal since the VendSettlement record may or may not contain the correct 1099 amounts and there is
                // is no direct link between the VendSettlement and VendSettlementTax1099 tables.
                settlementFator = abs(vendTransOffset.AmountCur ? setttleAmount/vendTransOffset.AmountCur : 0);
                tax1099Amount = vendTransOffset.Tax1099Amount * -settlementFator;
                tax1099StateAmount = vendTransOffset.Tax1099StateAmount * -settlementFator;

                tax1099AmountSettled = tax1099Amount - discount;
                tax1099StateAmountSettled = tax1099StateAmount - discount;

                // Given the amount, the voucher for the payment (vendTrans) and
                // the vendor invoice being settled against (vendTransOffset), the
                // correct VendSettlementTax1099 record can be located.
                select firstonly crosscompany vendSettlementTax1099
                where vendSettlementTax1099.Voucher == vendTrans.Voucher
                    && vendSettlementTax1099.VendAccount == vendTrans.AccountNum
                    && vendSettlementTax1099.VendInvoiceId == vendTransOffset.Invoice
                    && vendSettlementTax1099.SettleTax1099Amount == tax1099AmountSettled
                    && vendSettlementTax1099.SettleTax1099StateAmount == tax1099StateAmountSettled;

                if (vendSettlementTax1099)
                {
                    this.createReverseTax1099Settlement(vendSettlementTax1099);
                    vendSettlementTax1099RevDone = true;
                }

                // Since the user is able to edit 1099 amounts after settlment, the above select
                // may not have found a record.  Try again, but this time not looking for a
                // specific amount.
                if (!vendSettlementTax1099)
                {
                    while select crosscompany vendSettlementTax1099
                        where vendSettlementTax1099.Voucher == vendTrans.Voucher
                            && vendSettlementTax1099.VendAccount == vendTrans.AccountNum
                            && vendSettlementTax1099.VendInvoiceId == vendTransOffset.Invoice
                            && ((vendSettlementTax1099.SettleTax1099Amount > 0 && tax1099AmountSettled > 0)
                            || (vendSettlementTax1099.SettleTax1099Amount < 0 && tax1099AmountSettled < 0))
                    {
                        this.createReverseTax1099Settlement(vendSettlementTax1099);
                        vendSettlementTax1099RevDone = true;
                    }
                }

                if (vendSettlementTax1099RevDone)
                {
                    ttsbegin;
                    // Update vendor invoice
                    if (vendTransOffset)
                    {
                        changecompany(vendTransOffset.company())
                        {
                            vendTransOffset.SettleTax1099Amount += tax1099Amount;
                            vendTransOffset.SettleTax1099StateAmount += tax1099StateAmount;
                            vendTransOffset.update();
                        }
                    }

                    // Update VendTransOpen
                    if (vendTransOpen)
                    {
                        changecompany(vendTransOffset.company())
                        {
                            vendTransOpen.Tax1099Amount -= tax1099StateAmount;
                            vendTransOpen.Tax1099StateAmount -= tax1099StateAmount;
                            vendTransOpen.update();
                        }
                    }
                    vendSettlementTax1099RevDone = false;
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxAverageVATAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method reverses related inventory cost and asset transactions.
    /// </summary>
    /// <param name="_voucherToReverse">
    ///     The voucher is to be reversed.
    /// </param>
    /// <param name="_transDateToReverse">
    ///     The transaction date for the voucher which to be reversed.
    /// </param>
    /// <param name="_reverseDate">
    ///     The transaction date for reversing.
    /// </param>
    private void reverseTaxAverageVATAdjust(
        Voucher                 _voucherToReverse,
        TransDate               _transDateToReverse,
        TransDate               _reverseDate)
    {
        TaxTrans                    taxTrans;
        InventTrans                 inventTrans;

        #define.Zero(0)
        #define.NegOne(-1)

        while select InventTransId, sum(TaxInCostPriceMST), sum(TaxInCostPrice) from taxTrans
            group by InventTransId
            where taxTrans.Voucher    == _voucherToReverse
                && taxTrans.TransDate == _transDateToReverse
        {
            if (taxTrans.TaxInCostPrice != #Zero)
            {
                inventTrans = InventTrans::findTransId(taxTrans.InventTransId, true);
                if (inventTrans.RecId)
                {
                    TaxAverageVATAdjust::updateInvent(
                        ledgerVoucher,
                        inventTrans,
                        _reverseDate,
                        ledgerVoucher.findLedgerVoucherObject().parmVoucher(),
                        #NegOne * taxTrans.TaxInCostPriceMST);
                }

                TaxAverageVATAdjust::updateAsset(
                    _voucherToReverse,
                    _transDateToReverse,
                    _reverseDate,
                    ledgerVoucher,
                    #NegOne * taxTrans.TaxInCostPrice,
                #NegOne * taxTrans.TaxInCostPriceMST);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxSettlement_W</Name>
				<Source><![CDATA[
    private void reverseTaxSettlement_W()
    {
        CustVendReversePostingLog_RU postingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement,
                                                                                                      ledgerVoucher,
                                                                                                      true);

        postingLog.setTaxReverseTax(new TaxReverseTaxConditionalTax_W(ledgerVoucher.lastVoucher(),
                                                                      ledgerVoucher.lastTransDate(),
                                                                      ''));
        postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::ConditionalTax);
        postingLog.doReverse(true, true);
        reversePostingLogSet = Set::union(reversePostingLogSet, postingLog.getReversePostingLogSet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxTransGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the related transactions for the specified voucher and date.
    /// </summary>
    /// <param name="_voucherToReverse">
    ///    The voucher number of the transactions to reverse.
    /// </param>
    /// <param name="_transDateToReverse">
    ///    The transaction date of the transactions to reverse.
    /// </param>
    /// <remarks>
    ///    This method creates reversal transactions for the general journal and the <c>TaxTrans</c> records.
    /// </remarks>
    protected void reverseTaxTransGeneralJournal(Voucher _voucherToReverse, TransDate _transDateToReverse)
    {
        LedgerPostingController     ledgerPostingController;
        TaxTrans                    taxTrans;
        TaxTrans                    taxTransLocal;
        Map                         recIdMap;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        Map                         taxTransRelationshipTypes;
        MapEnumerator               enumerator;
        boolean                     transactionLineAccountReversed;
        boolean                     isInitialized;
        TransDate                   accountingDate;
        GeneralJournalEntry         generalJournalEntry;
        GeneralJournalAccountEntry  generalJournalAccountEntry;
        LedgerVoucherObject         ledgerPostingReference;
        LedgerVoucherTransObject    ledgerPostingTransaction;

        // <GIN>
        boolean                     relatedVoucherCreated;
        TaxTransReversal_IN         taxTransReversal;
        TaxParameters               taxParameters;
        // </GIN>

        recIdMap = new Map(Types::Int64, Types::Int64);

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            taxParameters = TaxParameters::find();
            taxTransReversal = new TaxTransReversal_IN();
            taxTransReversal.init();
        }
        // </GIN>

        this.findLedgerVoucherByCompany();

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

        while select taxTrans
            where taxTrans.Voucher == _voucherToReverse
                && taxTrans.TransDate == _transDateToReverse
        {
            taxTransLocal = taxTrans.data();
            taxTransLocal.copyTaxTrans(taxTrans, -1);
            taxTransLocal.Voucher = voucher;
            taxTransLocal.TransDate = diffTransDate;
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
            {
                taxTransLocal.TaxBookSection    = 0;
                taxTransLocal.TaxBook           = 0;
            }
            taxTransLocal.insert();

            // <GIN>
            if (taxParameters.ServiceTax_IN
                || taxParameters.Customs_IN
                || taxParameters.vat_in
                || taxParameters.SalesTax_IN
                || taxParameters.Excise_IN)
            {
                taxTransReversal.reverseByTaxTrans(taxTrans.RecId, taxTransLocal);
            }
            // </GIN>

            recIdMap.insert(taxTrans.RecId, taxTransLocal.RecId);
        }

        // <GIN>
        if (taxParameters.Excise_IN)
        {
            taxTransReversal.reverseExciseRegistration(_transDateToReverse, _voucherToReverse, diffTransDate, voucher);
        }
        // </GIN>

        isInitialized = false;

        while select AccountingDate from generalJournalEntry
            where
                generalJournalEntry.Ledger == Ledger::current()
        join Voucher from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == _voucherToReverse &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == _transDateToReverse &&
                    subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext() &&
                    subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
        join * from generalJournalAccountEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
        {
            if (!isInitialized)
            {
                if (this.isDatePrincipleDateOfPayment())
                {
                    accountingDate = generalJournalEntry.AccountingDate;
                }
                else
                {
                    accountingDate = diffTransDate;
                }

                if (ledgerPostingController.findReference(voucher, accountingDate))
                {
                    ledgerPostingReference = ledgerPostingController.getReference();

                    ledgerPostingReference.parmAccountingDate(accountingDate);
                }
                else
                {
                    ledgerPostingReference = LedgerVoucherObject::newReference(voucher, accountingDate, SysModule::None);

                    ledgerPostingController.addReference(ledgerPostingReference);
                }

                isInitialized = true;
            }

            ledgerPostingTransaction = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry);
            ledgerPostingTransaction.invertAmounts();

            // This setting must be checked each time since the company could be different and needs
            // to be honored on a per company basis.
            if (LedgerParameters::find().TransactionReversalCorrection)
            {
                ledgerPostingTransaction.parmIsCorrection(true);
            }

            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                && isConfigurationkeyEnabled(configurationKeyNum(FreeTextInvoiceCorrection))
                && generalJournalAccountEntry.PostingType == LedgerPostingType::ServiceTax_IN
                && !relatedVoucherCreated
                && ledgerVoucher)
            {
                ledgerPostingTransaction.parmIgnoreAllocation(true);
                ledgerVoucher.createVoucherLinks(_voucherToReverse, _transDateToReverse);
                relatedVoucherCreated = true;
            }
            // </GIN>
            ledgerPostingTransaction.parmText(strFmt('%1 %2', "@SYS110624", generalJournalAccountEntry.Text));

            taxTransRelationshipTypes = TaxTransGeneralJournalAccountEntry::reversePostedLinks(generalJournalAccountEntry.RecId, recIdMap, ledgerPostingTransaction);

            transactionLineAccountReversed = taxTransRelationshipTypes.lookup(TaxTransRelationshipType::TransactionLineAccount);
            ledgerPostingTransaction.parmSkipDimensionValidation(true);

            ledgerPostingController.addTrans(ledgerPostingTransaction);
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isAverageVATEnabled())
        {
            this.reverseTaxAverageVATAdjust(_voucherToReverse, _transDateToReverse, accountingDate);
        }
        // </GTH>

        // Some reversal scenarios don't reverse the amounts out of the transaction's account on the line.
        // In this case, the tax links need to be fixed to point back to the original posting to those accounts.
        if (!transactionLineAccountReversed)
        {
            enumerator = recIdMap.getEnumerator();
            while (enumerator.moveNext())
            {
                TaxTransGeneralJournalAccountEntry::reversePostedByTaxTrans(enumerator.current(), TaxTransRelationshipType::TransactionLineAccount, recIdMap);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithholdingNoSettlementGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the tax withholding transactions by recalculating the amounts.
    /// </summary>
    /// <remarks>
    ///    This method recalculates the tax amounts and corresponding ledger transaction amounts.
    /// </remarks>
    protected void reverseTaxWithholdingNoSettlementGroup()
    {
        TaxWithholdTrans taxWithholdTrans;
        VendSettlement   vendSettlementLoc;
        CustSettlement   custSettlementLoc;

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            if (custVendTrans.TableId == tableNum(VendTrans))
            {
                taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(custVendTrans);
            }
            else
            {
                taxWithholdTrans = TaxWithholdTrans::findCustTransPaym(custVendTrans);
            }

            if (TaxWithhold::allowedReverseTaxWithHold_BR(taxWithholdTrans, custVendTransOffset.TransDate))
            {
                // If payment voucher is empty, find the voucher using the settlement table
                if (custVendTrans.TableId == tableNum(VendTrans))
                {
                    select vendSettlementLoc
                        where vendSettlementLoc.TransRecId == custVendSettlement.OffsetRecId &&
                            vendSettlementLoc.TransCompany == custVendSettlement.OffsetCompany;

                    paymentVoucher_BR = vendSettlementLoc.custVendTrans().Voucher;
                }
                else
                {
                    select custSettlementLoc
                        where custSettlementLoc.TransRecId == custVendSettlement.OffsetRecId &&
                            custSettlementLoc.TransCompany == custVendSettlement.OffsetCompany;

                    paymentVoucher_BR = custSettlementLoc.custVendTrans().Voucher;
                }

                TaxWithhold::reverseTaxWithhold_BR(ledgerVoucher,
                                                   custVendTrans,
                                                   paymentVoucher_BR,
                                                   custVendTransOpen.RecId,
                                                   custVendTransOffset.TransDate);
            }
        }
        // </GBR>
        else if (custVendTrans.TableId == tableNum(VendTrans))
        {
            // Withholding taxes are only implemented on vendors
            TaxWithhold::reverseTaxWithhold(ledgerVoucher, custVendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the related transactions for the specified voucher and date.
    /// </summary>
    /// <param name="_voucherToReverse">
    ///    The voucher number of the transactions to reverse.
    /// </param>
    /// <param name="_transDateToReverse">
    ///    The transaction date of the transactions to reverse.
    /// </param>
    /// <remarks>
    ///    This method creates reversal transactions for <c>TaxWithholdTrans</c> records.
    /// </remarks>
    protected void reverseTaxWithholdTrans(Voucher _voucherToReverse, TransDate _transDateToReverse)
    {
        TaxWithholdTrans            taxWithholdTrans;

        // <GBR>
        // For Brazil, we won't post withholding taxes here.  Instead,
        // taxes will be posted from reverseInvoicePaymentSettlement
        if (!BrazilParameters::isEnabled())
        {
            // </GBR>
            if (custVendTrans.TableId == tableNum(VendTrans)
                // <GTH>
                || (custVendTrans.TableId == tableNum(CustTrans)
                    && (isTaxWithholdEnabled_TH || countryRegionGB || countryRegion_SAIE))
                // <GTH>
                )
            {
                // Find if there is a TaxWithholdTrans record for the vendor transaction.
                // <GTH>
                if (isTaxWithholdEnabled_TH || countryRegionGB || countryRegion_SAIE)
                {
                    taxWithholdTrans = TaxWithholdTrans::findByCustVendTransPaym(custVendTrans);
                }
                else
                {
                    // </GTH>
                    taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(custVendTrans);
                }

                // No taxwitholding transaction found for vendTrans, need to check the
                // offset vendTrans
                if (taxWithholdTrans.RecId == 0)
                {
                    // <GTH>
                    if (isTaxWithholdEnabled_TH || countryRegionGB || countryRegion_SAIE)
                    {
                        taxWithholdTrans = TaxWithholdTrans::findByCustVendTransPaym(custVendTransOffset);
                    }
                    else
                    {
                        // </GTH>
                        taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(custVendTransOffset);
                    }
                }

                if (taxWithholdTrans.RecId != 0)
                {
                    this.createTaxWithholdTransReverse(taxWithholdTrans);
                }
            }
            // <GBR>
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholdTransReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the reversal <c>TaxWithholdTrans</c> table record based on the original <c>TaxWithholdTrans</c> table record.
    /// </summary>
    /// <param name = "_originalTaxWithholdTrans">The original <c>TaxWithholdTrans</c> table record.</param>
    /// <returns>The newly inserted reversal <c>TaxWithholdTrans</c> table record.</returns>
    protected TaxWithholdTrans createTaxWithholdTransReverse(TaxWithholdTrans _originalTaxWithholdTrans)
    {
        TaxWithholdTrans taxWithholdTransReverse = this.populateTaxWithholdTransReverse(_originalTaxWithholdTrans);
        taxWithholdTransReverse.insert();

        return taxWithholdTransReverse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTaxWithholdTransReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the reversal <c>TaxWithholdTrans</c> table record based on the original <c>TaxWithholdTrans</c> table record.
    /// </summary>
    /// <param name = "_originalTaxWithholdTrans">The original <c>TaxWithholdTrans</c> table record.</param>
    /// <returns>The newly populated reversal <c>TaxWithholdTrans</c> table record.</returns>
    protected TaxWithholdTrans populateTaxWithholdTransReverse(TaxWithholdTrans _originalTaxWithholdTrans)
    {
        TaxWithholdTrans taxWithholdTransReverse;
        taxWithholdTransReverse.copyTaxWithholdTrans(_originalTaxWithholdTrans, voucher, diffTransDate, -1);
        taxWithholdTransReverse.SettlementVoucher = voucher;
        // if there is a parent voucher use that value to set the voucher field
        if (parentVoucher != '')
        {
            taxWithholdTransReverse.Voucher = parentVoucher;
        }

        return taxWithholdTransReverse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithold_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reversal transactions for TaxWithholdTrans.
    /// </summary>
    /// <param name="_taxWithholdDate">
    ///     The reversal date
    /// </param>
    /// <remarks>
    /// This method is called once for each <c>TaxWithholdTrans</c> record.
    /// </remarks>

    protected void reverseTaxWithold_BR(TransDate _taxWithholdDate)
    {
        TaxWithholdTrans                taxWithholdTrans;
        TaxWithholdTrans                taxWithholdTransReverse;
        VendTrans                       vendTransLoc;
        CustTrans                       custTransLoc;
        RecId                           transOpenRecId;
        boolean                         canReverse = false;

        // These find methods are not cross-company, so if matching taxWithholdTrans
        // are found, then we must be in the same company where taxWithholdTrans
        // are kept (i.e. the invoice company)
        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(custVendTrans);
        }
        else
        {
            taxWithholdTrans = TaxWithholdTrans::findCustTransPaym(custVendTrans);
        }

        // Found the WHT record to reverse
        if (taxWithholdTrans.RecId != 0)
        {
            // Only continue if reversal originated from cancel payment
            // Abort if called from closed edit transactions
            if (!paymentVoucher_BR)
            {
                throw error("@GLS2054");
            }

            // Check that there are no other Withhold transactions that would prevent a reversal
            if (custVendTrans.TableId == tableNum(VendTrans))
            {
                canReverse = TaxWithhold::allowedReverseTaxWithHold_BR(taxWithholdTrans, _taxWithholdDate);
            }
            else
            {
                canReverse = TaxWithhold_CustPaym::allowedReverseTaxWithHold_BR(taxWithholdTrans, _taxWithholdDate);
            }

            if (canReverse)
            {
                if (custVendTrans.TableId == tableNum(VendTrans))
                {
                    vendTransLoc = VendTrans::find(taxWithholdTrans.VendTransInvoiceId);
                    if (vendTransLoc)
                    {
                        transOpenRecId = VendTransOpen::findRefId(vendTransLoc.RecId).RecId;
                    }
                }
                else
                {
                    custTransLoc = CustTrans::find(taxWithholdTrans.CustTransInvoiceId);
                    if (custTransLoc)
                    {
                        transOpenRecId = CustTransOpen::findRefId(custTransLoc.RecId).RecId;
                    }
                }

                // All validation is complete, so reverse withholding tax.

                ttsbegin;

                taxWithholdTrans.selectForUpdate(true);
                taxWithholdTrans.CanBeReversed_BR = NoYes::No;
                taxWithholdTrans.RefCustVendTransRecId_BR = 0;
                taxWithholdTrans.TaxWithholdIsSelected_BR = 0;
                taxWithholdTrans.doUpdate();

                taxWithholdTransReverse = TaxWithholdTrans::copyTaxWithholdTrans_BR(taxWithholdTrans, parentVoucher, ledgerVoucher.lastTransDate());

                taxWithholdTransReverse.VoucherInvoice              = '';
                taxWithholdTransReverse.Posted                      = NoYes::Yes;
                taxWithholdTransReverse.CustVendTransOpenRecId_BR   = transOpenRecId;
                taxWithholdTransReverse.CanBeReversed_BR            = NoYes::No;

                if (TaxWithhold::checkUniquewithholdrecord_BR(taxWithholdTransReverse))
                {
                    taxWithholdTransReverse.insert();
                }
                else
                {
                    ttsabort;
                    return;
                }

                taxWithholdTransReverse.update();

                // Revert other tax transaction used in the threshold amount calculation
                while select forupdate taxWithholdTrans
                        where taxWithholdTrans.RefCustVendTransRecId_BR == vendTransLoc.RecId
                              && taxWithholdTrans.CanBeReversed_BR == NoYes::Yes
                              && taxWithholdTrans.TaxWithholdCode == taxWithholdTransReverse.TaxWithholdCode
                {
                    taxWithholdTrans.TaxWithholdIsSelected_BR = 0;
                    taxWithholdTrans.RefCustVendTransRecId_BR = 0;
                    taxWithholdTrans.CanBeReversed_BR = NoYes::No;
                    taxWithholdTrans.doUpdate();
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTransAndSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a reversal for the specified settlement and transaction.
    /// </summary>
    /// <param name="_custVendTransToReverse">
    ///    The transaction to reverse.
    /// </param>
    /// <param name="_custVendSettlementToReverse">
    ///    The settlement to reverse.
    /// </param>
    protected void reverseTransAndSettlement(CustVendTrans _custVendTransToReverse,
                                             CustVendSettlement _custVendSettlementToReverse)
    {
        CustVendTrans       custVendTransReversed;
        CustVendSettlement  custVendSettlementReversed;

        // <GEERU><GEECZ>
        CustVendTrans_W     custVendTrans_W;
        boolean             countryRegion_RU   = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean             countryRegion_RUCZ = countryRegion_RU
                                              || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        boolean             countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]);
        // </GEECZ></GEERU>

        custVendTransReversed = this.initCustVendTransBuffer();
        custVendTransReversed.data(_custVendTransToReverse);

        custVendTransReversed.Voucher = voucher;

        if (!this.isDatePrincipleDateOfPayment())
        {
            custVendTransReversed.TransDate = diffTransDate;
        }

        custVendTransReversed.Closed = diffTransDate;
        custVendTransReversed.LastSettleDate = diffTransDate;
        custVendTransReversed.DueDate = diffTransDate;

        custVendTransReversed.AmountCur = -_custVendTransToReverse.AmountCur;
        custVendTransReversed.AmountMST = -_custVendTransToReverse.AmountMST;
        custVendTransReversed.ReportingCurrencyAmount = -_custVendTransToReverse.ReportingCurrencyAmount;
        custVendTransReversed.SettleAmountCur = -_custVendTransToReverse.SettleAmountCur;
        custVendTransReversed.SettleAmountMST = -_custVendTransToReverse.SettleAmountMST;
        custVendTransReversed.SettleAmountReporting = -_custVendTransToReverse.SettleAmountReporting;
        custVendTransReversed.ExchAdjustment = -_custVendTransToReverse.ExchAdjustment;
        custVendTransReversed.ExchAdjustmentRealized = -_custVendTransToReverse.ExchAdjustmentRealized;
        custVendTransReversed.ExchAdjustmentUnrealized = -_custVendTransToReverse.ExchAdjustmentUnrealized;

        // <GEERU><GEECZ>
        if (countryRegion_EE)
        {
            custVendTransReversed.Correct               = NoYes::Yes;
        }
        if (countryRegion_RUCZ)
        {
            custVendTrans_W = custVendTransReversed.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.CorrectReporting_RU         = NoYes::Yes;
            custVendTransReversed.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        }
        // </GEECZ></GEERU>

        custVendTransReversed.ExchAdjustmentReporting = -_custVendTransToReverse.ExchAdjustmentReporting;
        custVendTransReversed.ReportingExchAdjustmentRealized = -_custVendTransToReverse.ReportingExchAdjustmentRealized;
        custVendTransReversed.ReportingExchAdjustmentUnrealized = -_custVendTransToReverse.ReportingExchAdjustmentUnrealized;

        custVendTransReversed.Txt = strFmt('%1 %2', "@SYS110624", _custVendTransToReverse.Txt);

        custVendSettlementReversed = this.initCustVendSettlementBuffer();
        custVendSettlementReversed.data(_custVendSettlementToReverse);

        if (!this.isDatePrincipleDateOfPayment())
        {
            custVendSettlementReversed.TransDate = diffTransDate;
        }

        custVendSettlementReversed.DueDate = diffTransDate;
        custVendSettlementReversed.SettlementGroup = 0;
        custVendSettlementReversed.TransRecId = 0;
        custVendSettlementReversed.CanBeReversed = false;

        custVendSettlementReversed.SettleAmountCur = -_custVendSettlementToReverse.SettleAmountCur;
        custVendSettlementReversed.SettleAmountMST = -_custVendSettlementToReverse.SettleAmountMST;
        custVendSettlementReversed.SettleAmountReporting = -_custVendSettlementToReverse.SettleAmountReporting;

        custVendSettlementReversed.ExchAdjustment = -_custVendSettlementToReverse.ExchAdjustment;
        custVendSettlementReversed.ExchAdjustmentReporting = -_custVendSettlementToReverse.ExchAdjustmentReporting;
        custVendSettlementReversed.UtilizedCashDisc = -_custVendSettlementToReverse.UtilizedCashDisc;
        custVendSettlementReversed.SettleTax1099Amount = -_custVendSettlementToReverse.SettleTax1099Amount;
        custVendSettlementReversed.SettleTax1099StateAmount = -_custVendSettlementToReverse.SettleTax1099StateAmount;

        custVendSettlementReversed.SettlementVoucher = voucher;

        // The Czech functionality was shared for the Europe country-context.
        // In case of CZ country context the disc trans reversal is performed in the reverseDiscount_RU() method, which is not called under the Europe context.
        // In case of Europe context the current method is working instead, so calling of the CZ method under the Europe context was added here.
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(CustParameters::listOfCountriesForCreditNoteCashDisc()))
        {
            this.createCreditNoteForCashDiscount_CZ(CustTrans::find(custVendTransReversed.OffsetRecId), custVendTransReversed);
        }

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ
            && (TaxParameters::find().ReverseSettlementDatePrinciple_W
            ||  countryRegion_RU))
        {
            custVendSettlementReversed.TransDate = transactionDate;
        }
        // </GEECZ></GEERU>
        

        switch (custVendTransReversed.TransType)
        {
            // if the TransType is settlement this is reversing the posting profile difference record
            case  LedgerTransType::Settlement:
                custVendTransReversed.LastSettleVoucher = voucher;
                custVendSettlementReversed.OffsetTransVoucher = custVendTransReversed.LastSettleVoucher;
                // set the setOffsetRecId parameter to true.
                custVendTransSettlement.addTransAndSettlement(custVendTransReversed, custVendSettlementReversed, settlementGroupPlaceHolder, true);
                break;

            case LedgerTransType::CrossCompanySettlement:
                // Cross company settlements should offset each other, but it is not possible to set the offset rec id and voucher until it is
                // known.  This ensures the information will be updated at posting time.
                custVendTransSettlement.addTransAndSettlement(custVendTransReversed, custVendSettlementReversed, settlementGroupPlaceHolder, true);
                break;

            case LedgerTransType::Interest, LedgerTransType::Cust:
                 // CustSettlementLine will only be create when the  Transaction type is custVendTransReversed.TransType ==
                 // LedgerTransType::Cust or Interest
                 custVendTransSettlement.addTransAndSettlement(custVendTransReversed, custVendSettlementReversed, settlementGroupPlaceHolder, false, _custVendSettlementToReverse);
                 break;

             default:
                 this.addReverseTransAndSettlementDefault(custVendTransReversed, custVendSettlementReversed, settlementGroupPlaceHolder, false, _custVendSettlementToReverse);
                 break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReverseTransAndSettlementDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the <c>CustVendTrans</c> map record and <c>CustVendSettlement</c> map record to the collection.
    /// </summary>
    /// <param name="_custVendTransReversed">
    /// The <c>CustVendTrans</c>  map record to add to the collection.
    /// </param>
    /// <param name="_custVendSettlementReversed">
    /// The <c>CustVendSettlement</c> map record to add to the collection.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder of the record being added.
    /// </param>
    /// <param name="_setOffsetRecId">
    /// A boolean value that indicates if the <c>CustVendSettlement</c> record needs to have the <c>OffsetRecId</c>
    /// field updated during posting.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map; optional.
    /// </param>
    [Replaceable, SuppressBpWarning('BPParameterNotUsed', 'Parameter _previousCustVendSettlement is used by extensions that wrap this method.')]
    protected void addReverseTransAndSettlementDefault(
        CustVendTrans       _custVendTransReversed, 
        CustVendSettlement  _custVendSettlementReversed,
        Counter             _settlementGroupPlaceHolder,
        boolean             _setOffsetRecId,
        CustVendSettlement  _previousCustVendSettlement
        )
    {
        custVendTransSettlement.addTransAndSettlement(_custVendTransReversed, _custVendSettlementReversed, _settlementGroupPlaceHolder, _setOffsetRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseVATTaxAgentPostingLog_RU</Name>
				<Source><![CDATA[
    private void reverseVATTaxAgentPostingLog_RU()
    {
        CustVendReversePostingLog_RU postingLog = CustVendReversePostingLog_RU::newCustVendSettlement(custVendSettlement,
                                                                                                      ledgerVoucher);

        postingLog.setTaxReverseTax(new TaxReverseTaxCustVendSettle_RU(ledgerVoucher.lastVoucher(),
                                                                       ledgerVoucher.lastTransDate(),
                                                                       ''));
        postingLog.addAllowedPostingLogType(CustVendTransPostingLogType_RU::VATTaxAgent);
        postingLog.doReverse(true, true);
        reversePostingLogSet = Set::union(reversePostingLogSet, postingLog.getReversePostingLogSet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseWithPostingLog_W</Name>
				<Source><![CDATA[
    protected void reverseWithPostingLog_W()
    {
        CustVendExchAdjustment_WExt    custVendExchAdjustment;

        if (LedgerParameters::find().ExchRateDiffCalcType_W != ExchRateDiffCalcType_W::Standard)
        {
            custVendExchAdjustment = CustVendExchAdjustment_WExt::newFromReverseSettlement(custVendTrans.TableId == tableNum(CustTrans) ?
                                                                                        SysModule::Cust : SysModule::Vend,
                                                                                        this);

            custVendExchAdjustment.setCustVendTransSettlement(custVendTransSettlement);
            custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);
            custVendExchAdjustment.parmDatePrinciple(datePrinciple);
        }

        this.reverseDiscount_RU();

        this.updateCustVendTrans();

        this.restoreCustVendTransOpen();

        this.reverseExchAdjustment_RU();
        if (! custVendExchAdjustment)
        {
            this.reverseExchAdjustment(false);
        }

        this.reversePennyDiff_RU();

        this.reverseCrossCompanySettlement_W();

        this.reversePostingTransLog_RU();
        this.reverseVATTaxAgentPostingLog_RU();

        this.reverseSettlement(custVendSettlement);

        this.updateSettlement();

        // Save because above calls could have updated the CustVendTrans record
        custVendTrans.update();

        if (custVendExchAdjustment)
        {
            custVendExchAdjustment.restoreExchAdjustment(custVendSettlement,
                                                         custVendTrans,
                                                         custVendTransOpen);
        }

        this.reverseTaxSettlement_W();

        this.reverseTaxWithholdingNoSettlementGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseWithSettlementGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the transactions in the current settlement group.
    /// </summary>
    /// <param name = "_custVendSettlement">The current settlement.</param>
    /// <param name = "_custVendTrans">The customer or vendor transaction.</param>
    /// <param name = "_custVendTransOffset">The customer or vendor offset transaction.</param>
    protected void reverseWithSettlementGroup(
        CustVendSettlement _custVendSettlement,
        CustVendTrans _custVendTrans,
        CustVendTrans _custVendTransOffset)
    {
        CustVendSettlement custVendSettlementToReverse;
        CustVendTrans custVendTransToReverse;
        TransDate currentSettlementTransDate;
        Voucher currentSettlementVoucher;
        boolean otherSettlementFound = false;

        currentSettlementTransDate = dateNull();
        custVendTransToReverse = this.initCustVendTransBuffer();
        custVendSettlementToReverse = this.initCustVendSettlementBuffer();

        // The reversal process (updateNow) reads each settlement record that can be reversed
        // and calls this method.  There will be two settlement records that can be reversed
        // for a settlement group. When the settlement record doesn't span two companies,
        // the first settlement record will reverse all the records and set the
        // _isReversalForSettlementGroupComplete class variable to true. If the record does
        // span multiple companies it is necessary to process all companies so the variable
        // will be set to true only after the second pass.
        if (!isReversalForSettlementGroupComplete)
        {
            // Find the settlement records for the settlement group and reverse them.
            while select custVendSettlementToReverse
                order by SettlementVoucher, TransDate
                where custVendSettlementToReverse.SettlementGroup == _custVendSettlement.SettlementGroup
                    && custVendSettlementToReverse.CanBeReversed == false
                join custVendTransToReverse
                    where custVendTransToReverse.RecId == custVendSettlementToReverse.TransRecId
            {
                otherSettlementFound = true;

                if (this.isInvoiceOrPaymentSettlement(custVendSettlementToReverse, _custVendTrans, _custVendTransOffset))
                {
                    this.reverseSettlement(custVendSettlementToReverse);
                }
                else
                {
                    this.reverseTransAndSettlement(custVendTransToReverse, custVendSettlementToReverse);
                    this.addExchAdjValuesToTotal(custVendTransToReverse);
                }

                if (currentSettlementVoucher != custVendSettlementToReverse.SettlementVoucher)
                {
                    currentSettlementTransDate = dateNull();
                    currentSettlementVoucher = custVendSettlementToReverse.SettlementVoucher;
                }

                if (currentSettlementTransDate != custVendSettlementToReverse.TransDate && currentSettlementVoucher != '')
                {
                    currentSettlementTransDate = custVendSettlementToReverse.TransDate;
                    this.reverseRelatedTransactions(currentSettlementVoucher, currentSettlementTransDate, custVendSettlementToReverse.AccountNum);
                }
            }

            if (!otherSettlementFound && _custVendSettlement.SettlementVoucher != '')
            {
                this.reverseRelatedTransactions(_custVendSettlement.SettlementVoucher, _custVendSettlement.TransDate, custVendSettlementToReverse.AccountNum);
            }

            if (isFirstReversalForSettlementGroup && this.isCrossCompanySettlement(_custVendSettlement))
            {
                // For cross company scenarios there will actually be one settlement record in
                // each company.  It is necessary to process both of them in that case.
                isFirstReversalForSettlementGroup = false;
            }
            else
            {
                isReversalForSettlementGroupComplete = true;
            }
        }

        this.reverseInvoicePaymentSettlement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceOrPaymentSettlement</Name>
				<Source><![CDATA[
    private boolean isInvoiceOrPaymentSettlement(CustVendSettlement _custVendSettlement,
        CustVendTrans _custVendTrans,
        CustVendTrans _custVendTransOffset)
    {
        return (_custVendSettlement.TransRecId == _custVendTrans.RecId
                    || _custVendSettlement.TransRecId == _custVendTransOffset.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rTax25markTrans</Name>
				<Source><![CDATA[
    protected void rTax25markTrans(CustVendTrans _custVendTrans, CustVendSettlement _custVendSettlement)
    {
        switch (_custVendTrans.TransType)
        {
            case LedgerTransType::RTax25_BadDebtDebitAmortisation :
                debitReverse.appendMarkup(_custVendTrans, _custVendSettlement.TransDate);
                break;
            case LedgerTransType::RTax25_BadDebtCreditAmortisation :
                creditReverse.appendMarkup(_custVendTrans, _custVendSettlement.TransDate);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionDate_W</Name>
				<Source><![CDATA[
    protected TransDate setTransactionDate_W(CustVendSettlement _custVendSettlement,
                                             CustVendTrans      _custVendTransDebet,
                                             CustVendTrans      _custVendTransCredit)
    {
        TransDate reverseDate;

        if (! TaxParameters::find().ReverseSettlementDatePrinciple_W
         && ! CustVendTransPostingLog_RU::usePostingLog())
        {
            return diffTransDate;
        }

        switch (this.parmDatePrinciple())
        {
            case SettleDatePrinc::DaysDate:
                reverseDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                break;
            case SettleDatePrinc::SelectDate:
                reverseDate = this.parmSaveDate_W();
                break;
            case SettleDatePrinc::DateOfPayment:
                reverseDate = _custVendSettlement.TransDate;
                break;
        }

        if (reverseDate < _custVendSettlement.TransDate)
        {
            info(strFmt("@GLS107058",
                        reverseDate,
                        _custVendTransDebet.Voucher,
                        _custVendTransCredit.Voucher,
                        _custVendTransDebet.AccountNum));
        }

        reverseDate = max(reverseDate,_custVendSettlement.TransDate);

        return reverseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupReverseDiscount</Name>
				<Source><![CDATA[
    abstract void setupReverseDiscount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupReverseExchAdjustment</Name>
				<Source><![CDATA[
    abstract void setupReverseExchAdjustment(NoYes  _realized)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupReversePennyDiff</Name>
				<Source><![CDATA[
    abstract void setupReversePennyDiff()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucher</Name>
				<Source><![CDATA[
    protected abstract void setVoucher()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>summaryLedgerDimension</Name>
				<Source><![CDATA[
    abstract LedgerDimensionDefaultAccount summaryLedgerDimension()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCashDisc</Name>
				<Source><![CDATA[
    private TaxAmount taxCashDisc(
        CustVendTrans      _invoiceTrans,
        CustVendTrans      _paymentTrans,
        CustVendSettlement _settlementTrans)
    {
        CustVendInvoiceJour custVendInvoiceJour;
        TaxCashDisc         taxCashDisc;
        TableId             taxTableId;
        RecId               taxRecId;
        CustVendSettlement  settlementLocal;

        if (this.cashDiscVat())
        {
            custVendInvoiceJour = this.findInvoice(_invoiceTrans.AccountNum,
                                                   _invoiceTrans.Invoice,
                                                   _invoiceTrans.Voucher,
                                                   _invoiceTrans.TransDate);
            if (custVendInvoiceJour.RecId)
            {
                taxTableId = custVendInvoiceJour.TableId;
                taxRecId   = custVendInvoiceJour.RecId;
            }
            else
            {
                taxTableId    = _invoiceTrans.TableId;
                taxRecId      = _invoiceTrans.RecId;
                _invoiceTrans = custVendTrans;
            }

            settlementLocal = this.initCustVendSettlementBuffer();

            select
                sum (SettleAmountCur),
                sum (UtilizedCashDisc)
            from settlementLocal
                where settlementLocal.TransRecId == custVendTrans.RecId;

            taxCashDisc = new TaxCashDisc(custVendTrans.Voucher,
                                          _invoiceTrans.TransDate,
                                          taxTableId,
                                          taxRecId,
                                          _invoiceTrans.CurrencyCode,
                                          _paymentTrans.TableId,
                                          _paymentTrans.RecId,
                                          - settlementLocal.UtilizedCashDisc / settlementLocal.SettleAmountCur * 100);

            taxAmount = taxCashDisc.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

            [conLedgerAccount, conTaxBaseAmountCur, taxTransRecId] = taxCashDisc.getContainers();
        }
        else
        {
            conLedgerAccount = conNull();
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxSettlement</Name>
				<Source><![CDATA[
    void taxSettlement(CustVendTrans      _custVendTrans,
                       CustVendSettlement _custVendSettlement,
                       Percent            _percent)
    {
        CustVendInvoiceJour custVendInvoiceJour;
        TaxSettlement       taxSettlement;
        TableId             taxTableId;
        RecId               taxRecId;
        ExchRate            exchRate;
        if (!TaxParameters::find().ConditionalTax)
        {
            return;
        }

        exchRate     = _custVendTrans.AmountMST / _custVendTrans.AmountCur * 100;

        custVendInvoiceJour = this.findInvoice(_custVendTrans.AccountNum,
                                               _custVendTrans.Invoice,
                                               _custVendTrans.Voucher,
                                               _custVendTrans.TransDate);
        if (custVendInvoiceJour.RecId)
        {
            taxTableId = custVendInvoiceJour.TableId;
            taxRecId   = custVendInvoiceJour.RecId;
        }
        else
        {
            taxTableId = _custVendTrans.TableId;
            taxRecId   = _custVendTrans.RecId;
        }

        taxSettlement = new TaxSettlement(_custVendTrans.Voucher,
                                          _custVendTrans.TransDate,
                                          taxTableId,
                                          taxRecId,
                                          _custVendTrans.CurrencyCode,
                                          _custVendTrans.TableId,
                                          _custVendSettlement.OffsetRecId,
                                          _percent,
                                          exchRate,
                                          0,
                                          UnknownNoYes::No);

        taxSettlement.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

        taxSettlement.reverseLinks(TaxTransRelationshipType::TransactionLineAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version,#CurrentList] = _packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>PurchPrepayTable</c> record to update the advance application remaining amount.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> record to recognize the <c>PurchPrepayTable</c> record to be updated.
    /// </param>
    /// <param name="settleAmountCur">
    ///    An amount to update in advance application remaining amount.
    /// </param>
    public void updateAdvanceDefinition(CustVendTrans  _custVendTrans, AmountCur settleAmountCur)
    {
        PurchPrepayTable::updateAdvanceApplicationRemaining(_custVendTrans, settleAmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CustVendTrans</c> table for the current record.
    /// </summary>
    protected void updateCustVendTrans()
    {
        this.populateCustVendTrans();
        custVendTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate <c>CustVendTrans</c>.
    /// </summary>
    protected void populateCustVendTrans()
    {
        // <GIN><GJP>
        CustVendTrans_W custVendTrans_W;
        // </GJP></GIN>
        // <GBR>
        CustVendTransPayment_BR paymentExt_BR;
        // </GBR>

        custVendTrans.SettleAmountCur      -= custVendSettlement.SettleAmountCur;
        custVendTrans.SettleAmountMST      -= custVendSettlement.SettleAmountMST;
        custVendTrans.SettleAmountReporting -= custVendSettlement.SettleAmountReporting;

        custVendTrans.LastSettleDate        = dateNull();
        custVendTrans.LastSettleVoucher     = '';
        custVendTrans.LastSettleAccountNum  = '';
        custVendTrans.LastSettleCompany     = '';
        custVendTrans.Closed                = dateNull();

        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            custVendTrans.VendPaymentGroup      = '';
        }

        if (!CustParameters::find().CustInvoiceRefNum_FI
            && custVendTrans.Invoice != '')
        {
            custVendTrans.PaymReference  = '';
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            paymentExt_BR = custVendTrans.getPaymentExtension_BR();

            if (custVendTrans.TransType == LedgerTransType::Payment)
            {
                paymentExt_BR.FineAmount = 0;
                paymentExt_BR.InterestAmount = 0;
            }
            else
            {
                paymentExt_BR.FineAmount -= custVendSettlement.FineAmount_BR;
                paymentExt_BR.InterestAmount -= custVendSettlement.InterestAmount_BR;
            }
            custVendTrans.packExtensionTable(paymentExt_BR);
        }
        // </GBR>

        // <GJP>
        if (CustConsInvoiceType_JP::isCustConsInvoiceEnabled()
                && custVendTrans.TableId == tableNum(CustTrans)
                && ((custVendTrans.TransType  == LedgerTransType::Payment
                    && custVendTrans.CancelledPayment_JP   == NoYes::No)
                    || (custVendTrans.TransType            == LedgerTransType::None
                    && custVendTrans.CustVendNegInstId_JP  != '')))
        {
            custVendTrans_W = custVendTrans.CustVendTrans::getCustVendTrans_W();
            // sets field ConsInvoice_JP with -1, marked this CustTrans records is cancelled.
            custVendTrans_W.ConsInvoice_JP = -1;
            custVendTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        }
        // </GJP>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow()
    {
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        Set agreementSet = (this.getModule() ==  SysModule::Cust ? CustParameters::find().AgreementCreditLine_RU : VendParameters::find().AgreementCreditLine_RU)
            ? new  Set(Types::Container) : null;

        custVendTrans = this.initCustVendTransBuffer();
        custVendSettlement = this.initCustVendSettlementBuffer();
        custVendTransOffset = this.initCustVendTransBuffer();
        settlementGroupPlaceHolder = 1;

        Debug::assert(diffTransDate != dateNull());

        if (!this.isDatePrincipleDateOfPayment()
            && !custVendSettlement.custVendSettlementInterface().validateReversalSettlementDateExt(common, diffTransDate))
        {
            throw error("@SYS25608");
        }

        custVendTransSettlement = CustVendTransSettlement::construct(this.getModule());

        ttsbegin;

        if (isTaxWithholdEnabled_TH)
        {
            TaxWithhold::markRelatedTaxWithholdSettlement(common);
        }

        if (countryRegion_RUCZ)
        {
            debitReverse = RTax25DebtAmortisation::constructReverse(RTax25DebtType::Debit);
            creditReverse = RTax25DebtAmortisation::constructReverse(RTax25DebtType::Credit);
        }

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

        SysInt64 currentSettlementGroup;
        DataAreaId currentCompany;
        container transCompany;
        container offsetCompany;

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstantsExt::SettleReversalReverseTransactions))
        {
            // MODs: prevent update conflict
            List recordSet = new List(Types::Record);

            while select crosscompany specTrans
                where specTrans.SpecTableId == common.TableId
                   && specTrans.SpecRecId == common.RecId
                   && specTrans.SpecCompany == common.company()
            join forupdate custVendSettlement
                    order by SettlementGroup, TransDate
                    where custVendSettlement.TableId == specTrans.RefTableId
                       && custVendSettlement.RecId == specTrans.RefRecId
                       && custVendSettlement.DataAreaId == specTrans.RefCompany
            {
                recordSet.addEnd(custVendSettlement);
            }

            ListEnumerator enumerator = recordSet.getEnumerator();

            while (enumerator.moveNext())
            {
            ////while select crosscompany specTrans
            ////    where specTrans.SpecTableId == common.TableId
            ////       && specTrans.SpecRecId == common.RecId
            ////       && specTrans.SpecCompany == common.company()
            ////    join forupdate custVendSettlement
            ////        order by SettlementGroup, TransDate
            ////        where custVendSettlement.TableId == specTrans.RefTableId
            ////           && custVendSettlement.RecId == specTrans.RefRecId
            ////           && custVendSettlement.DataAreaId == specTrans.RefCompany
            ////{
            // MODe: prevent update conflict
                custVendSettlement = enumerator.current();
                custVendSettlement.reread();

                if (!this.canBeReversed())
                {
                    continue;
                }

                if (isTaxWithholdEnabled_TH && custVendSettlement.CanBeReversed == NoYes::No)
                {
                    // Bypass the already reversed settlement.
                    continue;
                }

                transCompany = conNull();
                transCompany += [custVendSettlement.company()];

                select firstonly forupdate crosscompany:transCompany custVendTrans
                    where custVendTrans.RecId == custVendSettlement.TransRecId;

                if (countryRegion_RUCZ)
                {
                    this.insertAgreementRecordList_RU(agreementSet,custVendTrans);
                }

                offsetCompany = conNull();
                offsetCompany += [custVendSettlement.OffsetCompany];

                select firstonly crosscompany:offsetCompany custVendTransOffset
                    where custVendTransOffset.RecId == custVendSettlement.OffsetRecId;

                if (countryRegion_RUCZ)
                {
                    this.insertAgreementRecordList_RU(agreementSet,custVendTransOffset);
                }

                if (custVendSettlement)
                {
                    // Reverse based upon the company of the settlement record being processed.
                    // The offset will eventually be processed due to the cross company nature
                    // of the select statement that drives the reversal process.
                    changecompany (custVendSettlement.company())
                    {
                        if (CustVendTransPostingLog_RU::usePostingLog())
                        {
                            transactionDate = this.setTransactionDate_W(custVendSettlement,
                                                                        custVendTrans,
                                                                        custVendTransOffset);

                            if (!this.canBeReversed_RU(custVendSettlement))
                            {
                                continue;
                            }
                        }

                        if (!this.validate())
                        {
                            throw error("@SYS25608");
                        }

                        if (countryRegion_RUCZ)
                        {
                            if ((custVendTrans.TransType == LedgerTransType::RTax25_BadDebtCreditAmortisation
                                && custVendTransOffset.TransType == LedgerTransType::RTax25_BadDebtCreditAmortisation)
                                || (custVendTrans.TransType == LedgerTransType::RTax25_BadDebtDebitAmortisation
                                && custVendTransOffset.TransType == LedgerTransType::RTax25_BadDebtDebitAmortisation))
                            {
                                error(strFmt('%1 %2 -> %1 %3', "@GLS103349", custVendTrans.Voucher, custVendTransOffset.Voucher));
                                throw error("@GLS102600");
                            }

                            this.rTax25markTrans(custVendTrans, custVendSettlement);
                            this.rTax25markTrans(custVendTransOffset, custVendSettlement);
                        }

                        if (!custVendSettlement.SettlementGroup)
                        {
                            throw error("@SYS25608");
                        }

                        if (currentSettlementGroup != custVendSettlement.SettlementGroup)
                        {
                            currentSettlementGroup = custVendSettlement.SettlementGroup;
                            this.initForNewReversal();
                        }

                        if (currentCompany != custVendSettlement.company())
                        {
                            currentCompany = custVendSettlement.company();
                            this.resetExchRateTransactionAmounts();
                        }

                        // Get the ledgerVoucher for each unique company/settlement group combination.
                        this.findLedgerVoucherByCompany();

                        // Save 1099 information to be processed later. This is done because
                        // in certain cases, the VendTransOpen record has not been recreated
                        // so that it may be updated with 1099 information. However, waiting
                        // until all other updates have been processed ensures that all the
                        // required records are created and available.
                        if (custVendTrans.TableId == tableNum(VendTrans)
                            && (custVendTrans.TransType == LedgerTransType::None
                            || custVendTrans.TransType == LedgerTransType::Purch
                            || custVendTrans.TransType == LedgerTransType::Vend
                            || custVendTrans.TransType == LedgerTransType::GeneralJournal))
                        {
                            // There will be two settlment records for each 1099 settlement
                            // which can be reversed.  To avoid double-processing, only
                            // save 1099 information when the current vendTrans record is
                            // a vendor invoice.
                            tax1099VendTrans += custVendTransOffset.RecId;
                            tax1099VendTrans += custVendTransOffset.DataAreaId;
                            tax1099VendTrans += custVendTrans.RecId;
                            tax1099VendTrans += custVendTrans.DataAreaId;
                            tax1099VendTrans += custVendSettlement.SettleAmountCur;
                            tax1099VendTrans += custVendSettlement.UtilizedCashDisc;
                        }

                        if (CustVendTransPostingLog_RU::usePostingLog())
                        {
                            this.reverseWithPostingLog_W();
                        }
                        else
                        {
                            this.reverseWithSettlementGroup(custVendSettlement, custVendTrans, custVendTransOffset);
                        }
                    }
                }

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                    && TaxWithholdParameters_IN::findByCompany(curext()).CrossCompanyPayment
                    && custVendTrans.DataAreaId != curext())
                {
                    this.updateTaxWithholdTrans_IN(custVendTrans.RecId, custVendTrans.Voucher, custVendTrans.DataAreaId);
                }

                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()) 
                {
                    this.reverseTaxEngineTaxSettlement();
                }
            }
        }

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstantsExt::SettleReversalReverseSettlement))
        {
            custVendTransSettlement.post();
        }

        // Everything else has been processed and any neccessary VendTransOpen tables should
        // exist, so update 1099 amounts
        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstantsExt::SettleReversalTax1099))
            {
                this.reverseTax1099Settlement();
            }
        }

        if (BrazilParameters::isEnabled())
        {
            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstantsExt::SettleReversalTaxWithholdBR))
            {
                TaxWithholdTrans::updateTaxWithholdTransOpenTransId_BR();
            }
        }

        if (countryRegion_RUCZ)
        {
            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstantsExt::SettleReversalDebtAmortisationAXL))
            {
                if (!AgreementHeaderExt_RU::checkAgreementCreditLimit(agreementSet))
                {
                    throw error("@SYS79485");
                }

                debitReverse.updateNow();
                creditReverse.updateNow();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeReversed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Can the settlement be reversed.
    /// </summary>
    /// <returns>
    /// true when the settlement can be reversed; otherwise false.
    /// </returns>
    protected boolean canBeReversed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettlement</Name>
				<Source><![CDATA[
    public void updateSettlement()
    {
        custVendSettlement.ClosedDate = diffTransDate;
        custVendSettlement.CanBeReversed = NoYes::No;
        custVendSettlement.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the <c>TaxWithholdTrans_IN</c> buffer.
    /// </summary>
    /// <param name="_recId">
    /// The reference record id.
    /// </param>
    /// <param name="_invoiceVoucher">
    /// The voucher number of the invoice.
    /// </param>
    /// <param name="_companyId">
    /// The current company id.
    /// </param>
    protected void updateTaxWithholdTrans_IN(RecId  _recId, Voucher _invoiceVoucher,CompanyId _companyId)
    {
        TaxWithholdTrans_IN     taxWithholdTrans;

        changecompany(_companyId)
        {
            select Voucher from taxWithholdTrans
                where taxWithholdTrans.CustVendTransInvoiceId   == _recId
                   && taxWithholdTrans.InvoiceVoucher           == _invoiceVoucher
                   && taxWithholdTrans.TransactionReversal      == NoYes::No;

            if (taxWithholdTrans.Voucher)
            {
                update_recordset taxWithholdTrans
                setting
                Voucher             = voucher,
                TransactionReversal = NoYes::Yes
                where taxWithholdTrans.InvoiceVoucher            == _invoiceVoucher
                   && taxWithholdTrans.CustVendTransInvoiceId    == _recId
                   && !taxWithholdTrans.TransactionReversal;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the voucher exists.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    This supports cross-company validation of the voucher.
    /// </remarks>
    public boolean validate()
    {
        boolean ret = true;

        ret = ret && this.validate_IT();

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            ret = ret && this.checkOverdueJournal_W();
        }
        // </GEEPL>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDatePrincipleDateOfPayment</Name>
				<Source><![CDATA[
    private boolean isDatePrincipleDateOfPayment()
    {
        return datePrinciple == SettleDatePrinc::DateOfPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_IT</Name>
				<Source><![CDATA[
    private boolean validate_IT()
    {
        TaxReportPeriod taxReportPeriod;
        TaxTrans        taxTrans;
        boolean         ret = true;
        TaxTable        taxTable;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            select firstonly RecId, TaxPeriod from taxReportPeriod
                where taxReportPeriod.FromDate  <= custVendSettlement.TransDate &&
                      taxReportPeriod.ToDate    >= custVendSettlement.TransDate &&
                      taxReportPeriod.Closed
            exists join taxTrans
                where taxTrans.TaxPeriod == taxReportPeriod.TaxPeriod &&
                      taxTrans.TransDate == custVendTrans.TransDate   &&
                      taxTrans.Voucher   == custVendTrans.Voucher
            // <GFM>  having a tax code that is configured to use conditional sales tax
            exists join taxTable
                where taxTable.TaxCode == taxTrans.TaxCode &&
                taxTable.PaymentTaxCode;

            if (taxReportPeriod)
            {
                ret = checkFailed(strFmt("@SYS79476", "@SYS79287", taxReportPeriod.TaxPeriod));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendReversePostingExt construct(Common               _common,
                                                   LedgerVoucherGroup   _ledgerVoucherGroup)
    {
        CustVendReversePostingExt  custVendReversePosting;
        LedgerJournalTrans      ledgerJournalTrans;

        switch (_common.TableId)
        {
            case tableNum(CustTable), tableNum(CustTrans):
                custVendReversePosting = new CustReversePostingExt(_common, _ledgerVoucherGroup);
                break;

            case tableNum(VendTable):
                custVendReversePosting = new VendReversePostingExt(_common, _ledgerVoucherGroup);
                break;

            case tableNum(LedgerJournalTrans) :
                ledgerJournalTrans = _common as LedgerJournalTrans;
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    custVendReversePosting = new VendReversePostingExt(_common,  _ledgerVoucherGroup);
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                {
                    custVendReversePosting = new CustReversePostingExt(_common, _ledgerVoucherGroup);
                }

                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return custVendReversePosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversePostingLogSet_RU</Name>
				<Source><![CDATA[
    public Set parmReversePostingLogSet_RU(Set _reversePostingLogSet = reversePostingLogSet)
    {
        reversePostingLogSet = _reversePostingLogSet;
        return reversePostingLogSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxEngineTaxSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse tax settlement for tax engine
    /// </summary>
    protected void reverseTaxEngineTaxSettlement()
    {
        CustVendSettlement                      offsetCustVendSettlement;
        CustVendTrans                           offsetCustVendTrans;
        TaxEngineTaxSettlementReverse           taxSettlementReverse;
        
        offsetCustVendTrans = this.initCustVendTransBuffer();
        offsetCustVendSettlement = this.initCustVendSettlementBuffer();
        
        while select offsetCustVendSettlement
            where offsetCustVendSettlement.SettlementGroup == CustVendSettlement.SettlementGroup
                && offsetCustVendSettlement.CanBeReversed == true
                && offsetCustVendSettlement.RecId != CustVendSettlement.RecId
            join offsetCustVendTrans
                where offsetCustVendTrans.RecId == offsetCustVendSettlement.TransRecId
        {
            if (custVendTrans && offsetCustVendTrans)
            {
                taxSettlementReverse = TaxEngineTaxSettlementReverse::construct(
                    custVendTrans.RecId,
                    custVendTrans.Voucher,
                    custVendTrans.TransDate,
                    offsetCustVendTrans.RecId,
                    offsetCustVendTrans.Voucher,
                    offsetCustVendTrans.TransDate);
                    taxSettlementReverse.calcAndPost();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    private SysInstrumentationProgressLogger createProgressLogger()
    {
        str sourceName = CustVendInstrumentationFormatterExt::SourceNameSysModule(CustVendInstrumentationConstantsExt::SourceNameSettleReversal, this.getModule());

        return SysInstrumentationProgressLogger::createLogger(sourceName, CustVendInstrumentationConstantsExt::SettlementNamespace);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>