<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankPaymCancelExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BankPaymCancelExt</c> class cancels a deposit slip or customer payment transaction and all its
///    related information in the system.
/// </summary>
public class BankPaymCancelExt extends RunBase
{
    BankAccount             accountID;
    BankDepositNum          depositNum;
    ReasonCode              reason;
    ReasonComment           reasonComment;
    LedgerJournalNameId     journalName;
    TransDate               cancelDate;

    NoYes                   isLedgerAccountType;

    BankDeposit depositToCancel;
    BankAccountTrans bankAccountTransToCancel;
    CustTrans custTransToCancel;
    RecId cashGeneralJournalAccountEntryToCancel;
    RecId offsetGeneralJournalAccountEntryToCancel;
    RecId interCompanyDebitGeneralJournalAccountEntryToCancel;
    RecId interCompanyCreditGeneralJournalAccountEntryToCancel;

    boolean isPaymentInterCompany;
    NumberSeq paymentCancelVoucherSequence;
    NumberSeq interCompanyCancelVoucherSequence;
    NumberSequenceReference paymentCancelNumberSeqRef;
    NumberSequenceCode interCompanyCancelNumberSeqCode;
    Voucher cancelTransVoucher;
    Voucher cancelInterCompanyTransVoucher;

    ReasonRefRecID cancelReasonRef;
    TransTxt cancelTransTxt;
    TransTxt cancelInterCompanyTransTxt;
    LedgerVoucherGroup cancelLedgerVoucherGroup;
    LedgerVoucher cancelLedgerVoucher;
    LedgerVoucherObject cancelLedgerVoucherObject;
    LedgerVoucher cancelInterCompanyLedgerVoucher;
    LedgerVoucherObject cancelInterCompanyLedgerVoucherObject;
    BankPaymCancelType bankPaymCancelType;

    LedgerBondClient_RU     ledgerBondClient_RU;
    LedgerBondClient_RU     ledgerBondClientInterCompany_RU;
    CustTable custTable;
    CustTrans cancellingCustTrans;
    boolean isMCRCancel;

    ExchRate exchRate;
    ExchrateSecondary exchRateSecond;
    ExchRate reportingExchRate;
    ReportingCurrencyExchRate reportingCurrencyExchRate;
    ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecondary;
    EUROTriangulation triangulation;

    CashRegisterLocationRecId_W locationRecId;
    CashRegisterTerminalRecId_W terminalRecId;
    CashRegisterOperatorRecId_W operatorRecId;
    private TransactionReversalContract contract;
    private boolean isCancelSuccessful;

    #ISOCountryRegionCodes

    private const Version Version1 = 1;
    private const Version Version2 = 2;
    private const Version CurrentVersion = 3;


    #LOCALMACRO.CurrentListV1
        accountID,
        depositNum,
        cancelDate,
        reason,
        reasonComment,
        journalName
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>closeCancellingSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the settlements created from the customer transactions so that they cannot be reversed.
    /// </summary>
    protected void closeCancellingSettlements()
    {
        CustSettlement custSettlementToClose;

        // Update status of settlement records to prevent subsequent settlement reversals
        update_recordset custSettlementToClose
            setting CanBeReversed = NoYes::No
            where (custSettlementToClose.TransRecId == custTransToCancel.RecId ||
                (custSettlementToClose.OffsetRecid == custTransToCancel.RecId &&
                 custSettlementToClose.OffsetCompany == custTransToCancel.company())) &&
                custSettlementToClose.CanBeReversed == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancelInterCompanyLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>LedgerVoucher</c> object for the intercompany transactions that will be created for
    ///    the customer transaction company and adds it to the current <c>LedgerVoucherGroup</c> object.
    /// </summary>
    protected void createCancelInterCompanyLedgerVoucher()
    {
        changecompany(depositToCancel.RefCompany)
        {
            // Create LedgerVoucher for customer transaction company
            cancelInterCompanyLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Cust, interCompanyCancelNumberSeqCode);

            cancelInterCompanyLedgerVoucher.parmCompanyId(depositToCancel.RefCompany);
            cancelInterCompanyLedgerVoucher.parmCheckBlockedDimensions(false);

            // Initialize LedgerVoucherObject & set parms
            cancelInterCompanyLedgerVoucherObject = LedgerVoucherObject::newVoucher(
                                                    cancelInterCompanyTransVoucher,
                                                    cancelDate,
                                                    SysModule::Cust,
                                                    LedgerTransType::Cust);

            if (LedgerParameters::find().TransactionReversalCorrection)
            {
                cancelInterCompanyLedgerVoucherObject.parmCorrection(true);
            }

            cancelInterCompanyLedgerVoucherObject.lastTransTxt(cancelInterCompanyTransTxt);

            // Add LedgerVoucherObject to cancelling LedgerVoucher
            cancelInterCompanyLedgerVoucher.addVoucher(cancelInterCompanyLedgerVoucherObject);
        }

        // Add cancelling LedgerVoucher to LedgerVoucherGroup
        cancelLedgerVoucherGroup.addLedgerVoucher(cancelInterCompanyLedgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancelLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>LedgerVoucher</c> object for the transactions that will be created for the deposit or
    ///    customer transaction company and adds it to the current <c>LedgerVoucherGroup</c> object.
    /// </summary>
    protected void createCancelLedgerVoucher()
    {
        // Create LedgerVoucher for deposit/customer transaction company
        cancelLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Cust, paymentCancelNumberSeqRef.numberSequenceTable().NumberSequence);

        cancelLedgerVoucher.parmCompanyId(depositToCancel.RecId != 0 ? depositToCancel.company() : custTransToCancel.company());
        cancelLedgerVoucher.parmCheckBlockedDimensions(false);

        // Initialize LedgerVoucherObject & set parms
        cancelLedgerVoucherObject = LedgerVoucherObject::newVoucher(cancelTransVoucher, cancelDate, SysModule::Cust, LedgerTransType::Cust);
        cancelLedgerVoucherObject.parmReasonRef(cancelReasonRef);

        if (LedgerParameters::find().TransactionReversalCorrection)
        {
            cancelLedgerVoucherObject.parmCorrection(true);
        }

        cancelLedgerVoucherObject.lastTransTxt(cancelTransTxt);

        // Add LedgerVoucherObject to cancelling LedgerVoucher
        cancelLedgerVoucher.addVoucher(cancelLedgerVoucherObject);

        // Add cancelling LedgerVoucher to LedgerVoucherGroup
        cancelLedgerVoucherGroup.addLedgerVoucher(cancelLedgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the bank account transaction that cancels the bank account transaction for the deposit or
    ///    offsets the customer transaction.
    /// </summary>
    protected void createCancellingBankAccountTrans()
    {
        BankAccountTrans cancellingBankAccountTrans;
        BankPaymFeeCancel bankPaymFee;

        cancellingBankAccountTrans = bankPaymCancelType.createCancellingBankTrans();

        bankPaymFee = BankPaymFeeCancel::construct(cancelLedgerVoucher,
            cancelLedgerVoucherObject,
            bankAccountTransToCancel,
            cancellingBankAccountTrans.ReasonRefRecID,
            custTransToCancel,
            reasonComment);

        bankPaymFee.cancelCustPaymentBankFees();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingCashLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a new transaction to the current <c>LedgerVoucher</c> object that cancels the cash account
    ///    posting.
    /// </summary>
    protected void createCancellingCashLedgerTrans()
    {
        bankPaymCancelType.createCancellingPaymentLedgerTrans(cashGeneralJournalAccountEntryToCancel, bankAccountTransToCancel.PaymReference);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the transactions that cancel the transactions that correspond to the deposit or customer
    ///    transaction.
    /// </summary>
    protected void createCancellingCustTrans()
    {
        CustVoucher cancellingCustVoucher = this.constructCancellingCustVoucher();

        this.initCancellingCustVoucher(cancellingCustVoucher);

        this.initCancellingCustTrans();

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (this.isSettlementProcessRun_IN(cancellingCustTrans))
            {
                if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract())
                    || !this.parmContract().parmIsBatch())
                {
                    if (Box::yesNo("@GLS6278", DialogButton::No) == DialogButton::No)
                    {
                        throw error("@GLS6279");
                    }
                }
                else
                {
                    // we are reversing in batch so fail the scenario since we can't prompt
                    throw error(strFmt("@CashManagement:BankPaymentCancel_TaxWithholding", this.getCancellationVoucher()));
                }
            }
            cancellingCustVoucher.taxWithholdReversal_IN(depositToCancel.Voucher ? depositToCancel.Voucher : cancellingCustTrans.Voucher,
                                                        cancellingCustTrans.TransDate,
                                                        cancellingCustTrans.TableId,
                                                        cancellingCustTrans.RecId,
                                                        cancelInterCompanyLedgerVoucher ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher);
        }

        if (BankPaymCancelExt::isSalesTaxSettlementProcessRun_IN(cancellingCustTrans))
        {
            throw error(strFmt("@CashManagement:BankPaymentCancel_PartialSettlement", this.getCancellationVoucher()));
        }

        // Post cancelling customer transaction
        if (isPaymentInterCompany)
        {
            // Change to ref company to post
            changecompany(depositToCancel.RefCompany)
            {
                cancellingCustVoucher.post(cancelInterCompanyLedgerVoucher, cancellingCustTrans);
            }
        }
        else
        {
            cancellingCustVoucher.post(cancelLedgerVoucher, cancellingCustTrans);
        }

        // terminal is fixed for cancel transaction
        if (CashRegisterProcessingBase::isEnabledForTerminal(terminalRecId)
            && CashRegisterPaymMode_W::existsPaymMode(cancellingCustTrans.PaymMode))
        {
            CashRegisterProcessingBase cashRegisterProcessing = CashRegisterProcessingBase::construct(terminalRecId);
            cashRegisterProcessing.newFromPaymentTrans(cancellingCustTrans)
                .withCustTransToCancel(custTransToCancel)
                .cashRegisterOperator(CashRegisterOperator_W::find(operatorRecId))
                .cashRegisterTerminal(CashRegisterTerminal_W::find(terminalRecId))
                .validate()
                .initFiscalTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCancellingCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the cancelling customer voucher.
    /// </summary>
    /// <returns>The cancelling customer voucher.</returns>
    protected CustVoucher constructCancellingCustVoucher()
    {
        CustVoucher cancellingCustVoucher;

        cancellingCustVoucher = CustVendVoucher::construct(
                                SysModule::Cust,
                                custTransToCancel.AccountNum,
                                -custTransToCancel.AmountCur,
                                custTransToCancel.CurrencyCode,
                                LedgerTransTxt::None,
                                custTransToCancel.DefaultDimension,
                                custTransToCancel.PostingProfile,
                                LedgerPostingType::CustBalance);

        return cancellingCustVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCancellingCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initalize the cancelling customer voucher.
    /// </summary>
    /// <param name = "_cancellingCustVoucher">The cancelling customer voucher.</param>
    protected void initCancellingCustVoucher(CustVoucher _cancellingCustVoucher)
    {
        _cancellingCustVoucher.parmPaymMode(custTransToCancel.PaymMode);
        _cancellingCustVoucher.parmPaymSpec(custTransToCancel.PaymSpec);
        _cancellingCustVoucher.parmPrePayment(custTransToCancel.Prepayment);
        _cancellingCustVoucher.parmTransTxt(isPaymentInterCompany ? cancelInterCompanyTransTxt : cancelTransTxt);
        _cancellingCustVoucher.parmTransDate(cancelDate);
        _cancellingCustVoucher.parmExchRate(exchRate);
        _cancellingCustVoucher.parmExchRateSecondary(exchRateSecond);
        _cancellingCustVoucher.parmReportingCurrencyExchRate(reportingCurrencyExchRate);
        _cancellingCustVoucher.parmReportingCurrencyExchRateSecondary(reportingCurrencyExchRateSecondary);
        _cancellingCustVoucher.parmTriangulation(triangulation);
        _cancellingCustVoucher.parmCancelledPayment(true);
        _cancellingCustVoucher.parmTransRefId(isPaymentInterCompany ? cancelInterCompanyTransVoucher : cancelTransVoucher);
        _cancellingCustVoucher.parmTransRefType(CustTransRefType::Other);
        _cancellingCustVoucher.parmReasonRefRecID(cancelReasonRef);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCancellingCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the cancelling customer transaction.
    /// </summary>
    protected void initCancellingCustTrans()
    {
        // Copy cancelled to cancelling to maintain references to both for subsequent updates
        cancellingCustTrans = custTransToCancel.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingInterCompanyTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds new transactions to the current <c>LedgerVoucher</c> objects that cancel the intercompany
    ///    account postings.
    /// </summary>
    protected void createCancellingInterCompanyTrans()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        GeneralJournalEntry generalJournalEntry;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject postingReference;
        LedgerVoucherTransObject postingTransaction;

        [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(interCompanyCreditGeneralJournalAccountEntryToCancel);

        postingReference = cancelLedgerVoucher.findLedgerVoucherObject(cancelTransVoucher, cancelDate);

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(generalJournalAccountEntry.company()).RecId),
            postingReference.parmAccountingDate());

        exchangeRateHelper.parmExchangeRate1(generalJournalAccountEntry.getAccountingExchangeRate());
        exchangeRateHelper.parmReportingExchangeRate1(generalJournalAccountEntry.getReportingExchangeRate());

        postingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
            postingReference,
            LedgerPostingType::InterCompany,
            generalJournalAccountEntry.LedgerDimension,
            generalJournalAccountEntry.TransactionCurrencyCode,
            -generalJournalAccountEntry.TransactionCurrencyAmount,
            exchangeRateHelper);

        postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
        postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
        postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);

        postingTransaction.parmSkipDimensionValidation(true);

        // Add transaction to LedgerVoucher to offset cash transaction
        cancelLedgerVoucher.addTrans(postingTransaction);

        // Add transaction to intercompany LedgerVoucher to offset customer transaction
        // Must be in ref company for calculations to lookup rates in correct company
        changecompany(depositToCancel.RefCompany)
        {
            [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
                GeneralLedgerExtension::findRelated(interCompanyDebitGeneralJournalAccountEntryToCancel);

            postingReference =
                cancelInterCompanyLedgerVoucher.findLedgerVoucherObject(cancelInterCompanyTransVoucher, cancelDate);

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(generalJournalAccountEntry.company()).RecId),
                postingReference.parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(generalJournalAccountEntry.getAccountingExchangeRate());
            exchangeRateHelper.parmReportingExchangeRate1(generalJournalAccountEntry.getReportingExchangeRate());

            postingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                postingReference,
                LedgerPostingType::InterCompany,
                generalJournalAccountEntry.LedgerDimension,
                generalJournalAccountEntry.TransactionCurrencyCode,
                -generalJournalAccountEntry.TransactionCurrencyAmount,
                exchangeRateHelper);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);

            postingTransaction.parmSkipDimensionValidation(true);

            cancelInterCompanyLedgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingOffsetLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the ledger transaction that cancels the offset ledger transaction.
    /// </summary>
    protected void createCancellingOffsetLedgerTrans()
    {
        bankPaymCancelType.createCancellingOffsetLedgerTrans(offsetGeneralJournalAccountEntryToCancel, bankAccountTransToCancel.PaymReference, custTransToCancel.RecId, custTransToCancel.TableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the transactions that cancel the transactions that correspond to the deposit or customer
    ///    transaction.
    /// </summary>
    protected void createCancellingTrans()
    {
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        GeneralJournalAccountEntry generalJournalAccountEntry;
        CustVendPaymJournalFee custVendPaymJournalFee;

        // Create LedgerVoucherGroup
        cancelLedgerVoucherGroup = LedgerVoucherGroup::construct();

        // Create LedgerVoucher & LedgerVoucherObject for deposit/customer transaction company
        this.createCancelLedgerVoucher();

        // determine exchange rates to use for conversion
        if (custTransToCancel)
        {
            // if reversing a customer transaction use exchange rate from customer record
            exchRate = custTransToCancel.ExchRate;
            exchRateSecond = custTransToCancel.ExchRateSecond;
            reportingExchRate = custTransToCancel.ReportingCurrencyCrossRate;
            reportingCurrencyExchRate = custTransToCancel.ReportingCurrencyExchRate;
            reportingCurrencyExchRateSecondary = custTransToCancel.ReportingCurrencyExchRateSecondary;
            triangulation = custTransToCancel.euroTriangulation;
        }
        else if (bankAccountTransToCancel)
        {
            // no cust trans but is bank trans, get exchange rate from ledger trans with posting or bank
            generalJournalAccountEntry = GeneralJournalAccountEntry::find(cashGeneralJournalAccountEntryToCancel);

            exchRate = generalJournalAccountEntry.getAccountingExchangeRate();
            exchRateSecond = 0;
            reportingCurrencyExchRate = generalJournalAccountEntry.getReportingExchangeRate();
            reportingExchRate = reportingCurrencyExchRate;
            reportingCurrencyExchRateSecondary = 0;
            triangulation = NoYes::No;
        }
        else
        {
            // get exchange rate from offsetLedgerTransToCancel
            generalJournalAccountEntry = GeneralJournalAccountEntry::find(offsetGeneralJournalAccountEntryToCancel);

            exchRate = generalJournalAccountEntry.getAccountingExchangeRate();
            exchRateSecond = 0;
            reportingCurrencyExchRate = generalJournalAccountEntry.getReportingExchangeRate();
            reportingExchRate = reportingCurrencyExchRate;
            reportingCurrencyExchRateSecondary = 0;
            triangulation = NoYes::No;
        }

        if (countryRegion_RU)
        {
            ledgerBondClient_RU = cancelLedgerVoucherObject.ledgerBondClient_RU();
            if (ledgerBondClient_RU)
            {
                ledgerBondClient_RU.addNewLogObject();
            }
        }
        bankPaymCancelType = BankPaymCancelType::construct(custTransToCancel,
            depositToCancel,
            custVendPaymJournalFee,
            bankAccountTransToCancel,
            cancelReasonRef,
            cancelLedgerVoucher,
            cancelLedgerVoucherObject);

        // Create cancelling bank account transaction, if needed
        if (bankAccountTransToCancel)
        {
            this.createCancellingBankAccountTrans();
            /////////////////////////// bankPaymCancelType.cancelBankDocument();

            // Create cancelling cash transaction as cancelling does not use BankVoucher
            this.createCancellingCashLedgerTrans();
        }
        else
        {
            // Otherwise create cancelling offset ledger transaction
            this.createCancellingOffsetLedgerTrans();
        }

        // If deposit was intercompany, create LedgerVoucher for intercompany transactions
        if (isPaymentInterCompany)
        {
            this.createCancelInterCompanyLedgerVoucher();

            if (countryRegion_RU)
            {
                changecompany(depositToCancel.RefCompany)
                {
                    ledgerBondClientInterCompany_RU = cancelInterCompanyLedgerVoucherObject.ledgerBondClient_RU();
                    if (ledgerBondClientInterCompany_RU)
                    {
                        ledgerBondClientInterCompany_RU.addNewLogObject();
                    }
                }
            }
        }

        // Create & post cancelling customer transaction - ledger transaction will be included
        if (custTransToCancel)
        {
            this.createCancellingCustTrans();
        }
        else
        {
            // Otherwise create cancelling ledger transaction
            this.createCancellingOffsetLedgerTrans();
        }

        // If deposit was intercompany, create cancelling IC ledger transactions for both companies
        if (isPaymentInterCompany)
        {
            this.createCancellingInterCompanyTrans();

            if (countryRegion_RU)
            {
                changecompany(depositToCancel.RefCompany)
                {
                    if (ledgerBondClientInterCompany_RU)
                    {
                        ledgerBondClientInterCompany_RU.bondLastVRef2CurrentLog();
                        ledgerBondClientInterCompany_RU.removeCurrentLogObject();
                    }
                }
            }
        }

        if (countryRegion_RU
            && ledgerBondClient_RU)
        {
            ledgerBondClient_RU.bondLastVRef2CurrentLog();
            ledgerBondClient_RU.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLedgerTransFurtherPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the bridge posting record
    /// </summary>
    protected void deleteLedgerTransFurtherPosting()
    {
        LedgerTransFurtherPosting   ledgerTransFurtherPosting;
        LedgerEntry                 ledgerEntry;

        delete_from ledgerTransFurtherPosting
            exists join ledgerEntry
                where ledgerEntry.RecId == ledgerTransFurtherPosting.RefRecId
                    && ledgerEntry.GeneralJournalAccountEntry == offsetGeneralJournalAccountEntryToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog = Dialog::newFormnameRunbase(formStr(BankPaymCancel),this);

        dialog.caption("@SYS24593");
        dialog = this.dialogInternal(dialog);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableCashRegister_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Cash Register functionality is enabled for current Cancel payment.
    /// </summary>
    /// <returns>True if functionality is enabled, otherwise - false.</returns>
    public boolean enableCashRegister_W()
    {
        boolean enableCashRegister = false;

        if(CashRegisterPaymMode_W::existsPaymMode(custTransToCancel.PaymMode))
        {
            CashRegisterFiscalTrans_W cashRegisterFiscalTrans = CashRegisterFiscalTrans_W::findCustTrans(this.parmCustTrans());
        
            if (cashRegisterFiscalTrans.RecId)
            {
                // Cash transaction has been already selected.
                ClassId cashRegisterProcessingClassId = CashRegister_W::find(cashRegisterFiscalTrans.CashRegister).ProcessingClassId;
                enableCashRegister = CashRegisterProcessingBase::isEnabled(cashRegisterProcessingClassId);
            }
            else
            {
                enableCashRegister = CashRegisterProcessingBase::isEnabledForCurrentUser();
            }
        }

        return enableCashRegister;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankAccountTransByCustTrans</Name>
				<Source><![CDATA[
    public BankAccountTrans findBankAccountTransByCustTrans(CustTrans _custTrans)
    {
        BankAccountTrans bankAccountTransLocal;
        BankChequeTable bankChequeTable;

        select forupdate firstonly bankAccountTransLocal
           where bankAccountTransLocal.Voucher == _custTrans.Voucher
              && bankAccountTransLocal.TransDate == _custTrans.TransDate
              && bankAccountTransLocal.AmountMST == -_custTrans.AmountMST;

        if (bankAccountTransLocal == null)
        {
            /* If the bank transaction is not found, it may be because of bridged posting, so
            that vouchers (and maybe dates) are different on CustTrans and the corresponding
            BankAccountTrans. If a bank check has been generated, we can still find the bank
            transaction and cancel the check */

            select forupdate firstonly bankAccountTransLocal
                join bankChequeTable
                where bankAccountTransLocal.AccountId == bankChequeTable.AccountID
                   && bankAccountTransLocal.ChequeNum == bankChequeTable.ChequeNum
                   && bankAccountTransLocal.AmountCur == -bankChequeTable.AmountCur
                   && bankChequeTable.Voucher == _custTrans.Voucher
                   && bankChequeTable.TransDate == _custTrans.TransDate
                   && bankChequeTable.ChequeNum == _custTrans.PaymReference
                   && bankChequeTable.RecipientType == BankChequeRecipientType::Cust
                   && bankChequeTable.AmountCur == _custTrans.AmountCur;
        }

        return bankAccountTransLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCancelTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the transaction text for the canceling transactions.
    /// </summary>
    protected void getCancelTransTxt()
    {
        // Get the deposit company transaction txt from the deposit slip if present, otherwise from the customer transaction
        cancelTransTxt = strFmt('%1: %2, %3', "@SYS1068", depositToCancel.RecId != 0 ? depositToCancel.Voucher : custTransToCancel.Voucher, reasonComment);

        // Get the intercompany transaction txt from the customer transaction
        cancelInterCompanyTransTxt = strFmt('%1: %2, %3', "@SYS1068", custTransToCancel.Voucher, reasonComment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transaction that corresponds to the cash account posting for the deposit
    ///    or bank transaction.
    /// </summary>
    protected void getCashGeneralJournal()
    {
        BankPaymCancelLedgerAcctType bankPaymCancelLedgerAcctType;
        boolean taxWithholdParametersMarked = TaxWithholdParameters_IN::checkTaxParameters();
        CustTrans_W custTransToCancel_W;

        // If there is any withholding tax transaction then execute this code....
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            custTransToCancel_W = custTransToCancel.custTrans_W();
        }
        if (taxWithholdParametersMarked && (custTransToCancel_W.tdsAmount_IN || custTransToCancel_W.tcsAmount_IN))
        {
            bankPaymCancelLedgerAcctType = BankPaymCancelLedgerAcctType::construct(bankAccountTransToCancel,
                bankAccountTransToCancel);
        }
        else
        {
            // There can be multiple cash ledger transactions if a payment journal posted multiple lines to the same bank account

            // Using a deposit slip causes multiple BankAccountTrans records to be consolidated for 1 per journal per deposit
            // slip per bank account but there is still a Bank ledger transaction for each line.

            // Use the amount from the BankDeposit if it exists, otherwise use the amount from the CustTrans
            //  In multi-company scenarios there will always be a BankDeposit.
            if (depositToCancel)
            {
                bankPaymCancelLedgerAcctType = BankPaymCancelLedgerAcctType::construct(depositToCancel,
                    bankAccountTransToCancel);
            }
            else
            {
                // There is no BankDeposit; process originated from a customer transaction to cancel.
                // Use it to find the cash ledger transaction
                bankPaymCancelLedgerAcctType = BankPaymCancelLedgerAcctType::construct(custTransToCancel,
                    bankAccountTransToCancel);
            }
        }

        cashGeneralJournalAccountEntryToCancel = bankPaymCancelLedgerAcctType.retrieveCashGeneralJournalAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the customer of the deposit or transaction being canceled.
    /// </summary>
    protected void getCustTable()
    {
        if (isPaymentInterCompany)
        {
            custTable = CustTable::findByCompany(depositToCancel.RefCompany, depositToCancel.CustAccount);
        }
        else
        {
            custTable = CustTable::findByCompany(custTransToCancel.company(), custTransToCancel.AccountNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the customer transaction to cancel.
    /// </summary>
    protected void getCustTransToCancel()
    {
        container refCompany;

        if (!custTransToCancel)
        {
            // The CustTrans wasn't passed in when the class was initialized, find it.
            if (depositToCancel)
            {
                if (isPaymentInterCompany)
                {
                    refCompany += [depositToCancel.RefCompany];
                }
                else
                {
                    refCompany += [depositToCancel.company()];
                }

                // There is a deposit slip, use it to get the CustTrans
                select firstonly crossCompany:refCompany custTransToCancel
                    where custTransToCancel.RecId == depositToCancel.RefRecId;
            }
            else
            {
                // If there isn't a deposit, the transaction can't be found if it is intercompany
                // Search for the customer transaction based on the bank offset transaction
                if (bankAccountTransToCancel)
                {
                    select firstonly custTransToCancel
                        where custTransToCancel.Voucher == bankAccountTransToCancel.Voucher &&
                            custTransToCancel.TransDate == bankAccountTransToCancel.TransDate &&
                            custTransToCancel.PaymReference == bankAccountTransToCancel.PaymReference;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterCompanyGeneralJournalToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transactions for the intercompany account postings for the deposit.
    /// </summary>
    protected void getInterCompanyGeneralJournalToCancel()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        container refCompany;

        if (isPaymentInterCompany)
        {
            select firstonly RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == depositToCancel.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == depositToCancel.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == depositToCancel.DataAreaId
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalAccountEntry.IsCredit == NoYes::Yes
                    && generalJournalAccountEntry.PostingType == LedgerPostingType::InterCompany;

            interCompanyCreditGeneralJournalAccountEntryToCancel = generalJournalAccountEntry.RecId;

            refCompany += [depositToCancel.RefCompany];

            select firstonly crossCompany:refCompany RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == custTransToCancel.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == custTransToCancel.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == custTransToCancel.DataAreaId
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::primaryLedger(CompanyInfo::findDataArea(depositToCancel.RefCompany).RecId)
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalAccountEntry.IsCredit == NoYes::No
                    && generalJournalAccountEntry.PostingType == LedgerPostingType::InterCompany;

            interCompanyDebitGeneralJournalAccountEntryToCancel = generalJournalAccountEntry.RecId;
        }
        else
        {
            interCompanyDebitGeneralJournalAccountEntryToCancel = 0;
            interCompanyCreditGeneralJournalAccountEntryToCancel = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets class values to what is stored in the <c>SysLastValues</c> table.
    /// </summary>
    /// <remarks>
    ///    This method does not call the <c>super</c> method so that values are not retrieved when a new
    ///    <c>BankPaymCancelExt</c> instance is created.
    /// </remarks>
    public void getLast()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetToBankGeneralJournalToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transaction that offsets the bank transaction.
    /// </summary>
    protected void getOffsetToBankGeneralJournalToCancel()
    {
        BankPaymCancelLedgerAcctType bankPaymCancelLedgerAcctType;

        bankPaymCancelLedgerAcctType = BankPaymCancelLedgerAcctType::construct(depositToCancel,
            bankAccountTransToCancel);

        offsetGeneralJournalAccountEntryToCancel = bankPaymCancelLedgerAcctType.retrieveOffsetToCancelGeneralJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetToCustGeneralJournalToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transaction that offsets the customer transaction.
    /// </summary>
    protected void getOffsetToCustGeneralJournalToCancel()
    {
        BankPaymCancelLedgerAcctType bankPaymCancelLedgerAcctType;

        bankPaymCancelLedgerAcctType = BankPaymCancelLedgerAcctType::construct(custTransToCancel,
            bankAccountTransToCancel);

        offsetGeneralJournalAccountEntryToCancel = bankPaymCancelLedgerAcctType.retrieveOffsetToCancelGeneralJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the transactions to cancel that corresponds to the deposit or customer transaction.
    /// </summary>
    protected void getTransToCancel()
    {
        if (depositToCancel)
        {
            // Set editability on BankDeposit - found when instantiated
            depositToCancel.selectForUpdate(true);

            if (depositToCancel.RefCompany != '' && depositToCancel.company() != depositToCancel.RefCompany)
            {
                isPaymentInterCompany = true;
            }
            else
            {
                isPaymentInterCompany = false;
            }
        }

        // Get CustTrans
        this.getCustTransToCancel();

        if (bankAccountTransToCancel)
        {
            // Set editability on BankAccountTrans - found when instantiated
            bankAccountTransToCancel.selectForUpdate(true);

            // Get cash general journal - only with bank transaction
            this.getCashGeneralJournal();

            if (!custTransToCancel)
            {
                // If there is no CustTrans, the offset to the BankAccountTrans is Ledger
                this.getOffsetToBankGeneralJournalToCancel();
            }
        }
        else
        {
            // If there is no BankAccountTrans, the offset to the CustTrans is Ledger
            this.getOffsetToCustGeneralJournalToCancel();
        }

        // Get intercompany general journal
        this.getInterCompanyGeneralJournalToCancel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVouchersForCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the number sequences and voucher numbers that will be used for posting the transactions that
    ///    cancel the transaction that correspond to the deposit or customer transaction.
    /// </summary>
    protected void getVouchersForCancellingTrans()
    {
        LedgerInterCompany interCompanySetup;
        LedgerJournalName interCompanyJournalSetup;

        // Get voucher for cancelling deposit company transactions
        paymentCancelNumberSeqRef = CustParameters::numRefCustCloseVoucher();
        paymentCancelVoucherSequence = NumberSeq::newGetVoucher(paymentCancelNumberSeqRef);

        cancelTransVoucher = paymentCancelVoucherSequence.voucher();

        // Get voucher for cancelling intercompany transactions, if needed
        if (isPaymentInterCompany)
        {
            changecompany(depositToCancel.RefCompany)
            {
                // Get the LedgerIntercompany & intercompany journal records from the ref company for the deposit company
                interCompanySetup = LedgerInterCompany::findCompanyPair(depositToCancel.RefCompany, depositToCancel.company());
                interCompanyJournalSetup = LedgerJournalName::find(interCompanySetup.JournalName);

                // Get voucher number for cancelling ref company transactions
                interCompanyCancelNumberSeqCode = NumberSequenceTable::find(interCompanyJournalSetup.NumberSequenceTable).NumberSequence;
                interCompanyCancelVoucherSequence = NumberSeq::newGetVoucherFromCode(interCompanyCancelNumberSeqCode);

                cancelInterCompanyTransVoucher = interCompanyCancelVoucherSequence.voucher();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCashRegisterFiscalTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up fields devoted to Cash Register functionality based on input
    /// <c>CashRegisterFiscalTrans_W</c> objects.
    /// </summary>
    /// <param name = "_cashRegisterFiscalTrans">Current <c>CashRegisterFiscalTrans_W</c>.</param>
    public void initFromCashRegisterFiscalTrans_W(CashRegisterFiscalTrans_W _cashRegisterFiscalTrans)
    {
        if(_cashRegisterFiscalTrans)
        {
            locationRecId = CashRegisterTerminal_W::find(_cashRegisterFiscalTrans.Terminal).Location;
            terminalRecId = _cashRegisterFiscalTrans.Terminal;
            operatorRecId = _cashRegisterFiscalTrans.Operator;
        }
        else
        {
            CashRegisterOperator_W currentOperator = CashRegisterOperator_W::currentOperator();
            if (currentOperator)
            {
                locationRecId = currentOperator.Location;
                terminalRecId = currentOperator.Terminal;
                operatorRecId = currentOperator.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParms</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets fields on the class that are presented to the user on the <c>BankPaymCancelExt</c> form.
    /// </summary>
    /// <param name="_transDate">
    ///    The date of the payment reversal.
    /// </param>
    /// <param name="_reason">
    ///    A <c>ReasonCode</c> for why the deposit slip payment was canceled.
    /// </param>
    /// <param name="_reasonComment">
    ///    A description of why the deposit slip payment was canceled.
    /// </param>
    /// <param name="_journalName">
    ///    A name of a journal.
    /// </param>
    /// <remarks>
    ///    The <c>BankPaymCancelExt</c> form calls this method to tell the class what the user has entered on the
    ///    form.
    /// </remarks>
    [SysObsolete('This method has been deprecated. Please directly utilize the parm methods present on the object moving forward.', false, 30\6\2020)]
    public void initParms(TransDate _transDate,
        ReasonCode _reason,
        ReasonComment _reasonComment,
        LedgerJournalNameId _journalName)
    {
        this.parmTransDate(_transDate);
        this.parmReason(_reason);
        this.parmReasonComment(_reasonComment);
        this.parmJournalName(_journalName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlementProcessRun_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer.
    /// </summary>
    /// <param name="_custTrans">
    /// The table buffer used to find the record.
    /// </param>
    /// <returns>
    /// returns the boolean value.
    /// </returns>
    public boolean isSettlementProcessRun_IN(CustTrans  _custTrans)
    {
        TaxWithholdSettleTrans_IN   taxSettleTrans;

        select taxSettleTrans
            where taxSettleTrans.OrigVoucher    == _custTrans.Voucher
               && taxSettleTrans.TransDate      == _custTrans.TransDate;

        if (taxSettleTrans)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container contractContainer;

        if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            contractContainer = contract.pack();
        }

        return [CurrentVersion, accountID, depositNum, cancelDate, reason, reasonComment,
            journalName, locationRecId, terminalRecId, operatorRecId, contractContainer];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountId</Name>
				<Source><![CDATA[
    public BankAccount parmAccountId(BankAccount _account = accountID)
    {
        accountID = _account;
        return accountID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountTransToCancel</Name>
				<Source><![CDATA[
    public BankAccountTrans parmBankAccountTransToCancel(BankAccountTrans _bankAccountTransToCancel = bankAccountTransToCancel)
    {
        bankAccountTransToCancel = _bankAccountTransToCancel;
        return bankAccountTransToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankDepositToCancel</Name>
				<Source><![CDATA[
    public BankDeposit parmBankDepositToCancel(BankDeposit _bankDepositToCancel = depositToCancel)
    {
        depositToCancel = _bankDepositToCancel;
        return depositToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContract</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public TransactionReversalContract parmContract(TransactionReversalContract _contract = contract)
    {
        contract = _contract;

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustTrans</Name>
				<Source><![CDATA[
    public CustTrans parmCustTrans(CustTrans _custTrans = custTransToCancel)
    {
        custTransToCancel = _custTrans;
        return custTransToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDepositNum</Name>
				<Source><![CDATA[
    public BankDepositNum parmDepositNum(BankDepositNum _depositNum = depositNum)
    {
        depositNum = _depositNum;
        return depositNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsLedgerAccountType</Name>
				<Source><![CDATA[
    public NoYes parmIsLedgerAccountType(NoYes _isLedgerAccountType = isLedgerAccountType)
    {
        isLedgerAccountType = _isLedgerAccountType;
        return isLedgerAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    public LedgerJournalNameId parmJournalName(LedgerJournalNameId _journalName = journalName)
    {
        journalName = _journalName;
        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLocationRecId</Name>
				<Source><![CDATA[
    public CashRegisterLocationRecId_W parmLocationRecId(CashRegisterLocationRecId_W _locationRecId = locationRecId)
    {
        locationRecId = _locationRecId;
        return locationRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRIsMCRCancel</Name>
				<Source><![CDATA[
    public boolean parmMCRIsMCRCancel(boolean _isMCRCancel = isMCRCancel)
    {
        isMCRCancel = _isMCRCancel;
        return isMCRCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOperatorRecId</Name>
				<Source><![CDATA[
    public CashRegisterOperatorRecId_W parmOperatorRecId(CashRegisterOperatorRecId_W _operatorRecId = operatorRecId)
    {
        operatorRecId = _operatorRecId;
        return operatorRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReason</Name>
				<Source><![CDATA[
    public ReasonCode parmReason(ReasonCode _reason = reason)
    {
        reason = _reason;
        return reason;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonComment</Name>
				<Source><![CDATA[
    public ReasonComment parmReasonComment(ReasonComment _reasonComment = reasonComment)
    {
        reasonComment = _reasonComment;
        return reasonComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCancelSuccessful</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmIsCancelSuccessful(boolean _isCancelSuccessful = isCancelSuccessful)
    {
        isCancelSuccessful = _isCancelSuccessful;

        return isCancelSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTerminalRecId</Name>
				<Source><![CDATA[
    public CashRegisterTerminalRecId_W parmTerminalRecId(CashRegisterTerminalRecId_W _terminalRecId = terminalRecId)
    {
        terminalRecId = _terminalRecId;
        return terminalRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = cancelDate)
    {
        cancelDate = _transDate;
        return cancelDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    public boolean prompt()
    {
        boolean ret = true;

        if (!TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts all ledger transactions created by the process.
    /// </summary>
    protected void postCancellingTrans()
    {
        cancelLedgerVoucherGroup.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses settlements corresponding to transactions paid by the deposit or customer transaction.
    /// </summary>
    protected void reverseSettlement()
    {
        CustSettlement reverseCustSettlement;
        SpecTransManager specTransManager;
        CompanyId refCompany;

        Debug::assert(custTable.RecId);

        if (isPaymentInterCompany)
        {
            refCompany = depositToCancel.RefCompany;
        }
        else
        {
            refCompany = custTransToCancel.company();
        }

        changecompany(refCompany)
        {
            // Create SpecTransManager
            specTransManager = SpecTransManager::newFromSpec(custTable);

            this.markSettlementsForReversal(specTransManager);

            if (specTransManager.getSpecTransCount() > 0)
            {
                if (BrazilParameters::isEnabled())
                {
                    // Reverse settlements
                    CustTrans::reverseTransact(custTable,
                                               isPaymentInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                               SettleDatePrinc::SelectDate,
                                               this.parmTransDate(),
                                               true,
                                               custTransToCancel.Voucher,
                                               true);
                }
                else
                {
                    // Reverse settlements
                    CustTrans::reverseTransact(custTable,
                                               isPaymentInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                               SettleDatePrinc::SelectDate,
                                               this.parmTransDate(),
                                               false,
                                               '',
                                               true);
                }

                // Clean up SpecTrans records for reversal
                specTransManager.deleteAll();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markSettlementsForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark settlements for reversal.
    /// </summary>
    /// <param name = "_specTransManager">Used to interact with <c>SpecTrans</c> records.</param>
    protected void markSettlementsForReversal(SpecTransManager _specTransManager)
    {
        CustSettlement reverseCustSettlement;

        while select reverseCustSettlement
            where reverseCustSettlement.TransCompany == custTransToCancel.DataAreaId
                && reverseCustSettlement.TransRecId == custTransToCancel.RecId
                && reverseCustSettlement.CanBeReversed == NoYes::Yes
        {
            this.markSettlementForReversal(_specTransManager, reverseCustSettlement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markSettlementForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark a single settlement for reversal.
    /// </summary>
    /// <param name = "_specTransManager">Used to interact with <c>SpecTrans</c> records.</param>
    /// <param name = "_reverseCustSettlement">The <c>CustSettlement</c> that will be reversed.</param>
    protected void markSettlementForReversal(SpecTransManager _specTransManager, CustSettlement _reverseCustSettlement)
    {
        _reverseCustSettlement.CustVendSettlement::markThisAndRelatedOffsets(_specTransManager, custTransToCancel.CurrencyCode);

        if (BrazilParameters::isEnabled()
            && _reverseCustSettlement.SettlementGroup)
        {
            // Mark withholding tax settlement transactions when exists
            TaxWithhold::markRelatedVouchers_BR(custTransToCancel.CurrencyCode, _reverseCustSettlement, _specTransManager);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses taxes corresponding to a canceled transaction.
    /// </summary>
    protected void reverseTaxes()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        GeneralJournalEntry generalJournalEntry;
        TaxReverseTax reverseTax;
        LedgerPostingController controller;

        if (!custTransToCancel || custTransToCancel.Prepayment == NoYes::No)
        {
            reverseTax = new TaxReverseTax(
                            isPaymentInterCompany ? cancelInterCompanyTransVoucher : cancelTransVoucher,
                            cancelDate,
                            reasonComment);

            reverseTax.setExchRates(custTransToCancel.CurrencyCode, exchRate, exchRateSecond, Currency::noYes2UnknownNoYes(triangulation), cancelDate);
            reverseTax.setReverseRecId(custTransToCancel.RecId);
            reverseTax.setReverseTableId(custTransToCancel.TableId);

            // If customer transaction with ledger offset, there may be taxes to reverse - use the ledger offset
            if (custTransToCancel && offsetGeneralJournalAccountEntryToCancel)
            {
                [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
                    GeneralLedgerExtension::findRelated(offsetGeneralJournalAccountEntryToCancel);
            }

            // If ledger transaction with bank offset, there may be taxes to reverse - use the bank offset
            if (bankAccountTransToCancel && offsetGeneralJournalAccountEntryToCancel)
            {
                [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
                    GeneralLedgerExtension::findRelated(cashGeneralJournalAccountEntryToCancel);
            }

            changecompany(generalJournalAccountEntry.company())
            {
                if (isPaymentInterCompany)
                {
                    controller = LedgerPostingController::newForLedgerPostingJournal(cancelInterCompanyLedgerVoucher);
                }
                else
                {
                    controller = LedgerPostingController::newForLedgerPostingJournal(cancelLedgerVoucher);
                }

                while select Voucher, AccountingDate from subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                {
                    reverseTax.calcAndPost(controller, subledgerVoucherGeneralJournalEntry.Voucher, subledgerVoucherGeneralJournalEntry.AccountingDate);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        if (journalName != '')
        {
            // The process will occur through a bank deposit cancellation journal.
            BankDepositCreateCancelJourExt bankDepositCreateCancelJour = BankDepositCreateCancelJourExt::newBankDepositCreateCancelJourExt(this);
            bankDepositCreateCancelJour.createDepositCancelJournal();
        }
        else
        {
            // Get records to be cancelled
            this.getTransToCancel();

            // Validate records to be cancelled
            if (this.validateToCancelPayment())
            {
                ttsbegin;

                this.cancelPayment();

                ttscommit;

                if (cancellingCustTrans)
                {
                    CashRegisterProcessingBase::sendFromCancellingCustTrans(cancellingCustTrans);
                }
    
                if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
                {
                    info(strFmt("@CashManagement:BankPaymentCancel_CancelSuccess", this.getCancellationVoucher()));

                    isCancelSuccessful = true;
                }
                else
                {
                    info("@SYS26915");
                }
            }
            else
            {
                throw error(strFmt("@CashManagement:BankPaymentCancel_CancelError", this.getCancellationVoucher()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCancellationVoucher</Name>
				<Source><![CDATA[
    private Voucher getCancellationVoucher()
    {
        return depositToCancel.Voucher ? depositToCancel.Voucher : custTransToCancel.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the work of cancelling the payment after validating payment to be cancelled.
    /// </summary>
    protected void cancelPayment()
    {
        // Get vouchers for cancel process
        this.getVouchersForCancellingTrans();

        // Get transaction text for cancel process
        this.getCancelTransTxt();

        // Get reason code reference for cancel process
        cancelReasonRef = ReasonTableRef::createReasonTableRef(reason, reasonComment);

        // Create cancelling transactions
        this.createCancellingTrans();

        // Update related records
        this.updateRelatedRecords();

        // Finalize cancellation - post cancelling transactions
        this.postCancellingTrans();

        TransactionLog::create(TransactionLogType::PaymReversal, "@SYS82247");

        // create audit trail records for other companies.
        cancelLedgerVoucherGroup.createTransactionLog(TransactionLogType::PaymReversal, "@SYS82247");

        // Update collections status for the cancelled payment.
        this.updateCollectionsStatusAutomation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCancellingCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Settles the customer transaction that corresponds to the deposit or the customer transaction that
    ///    canceled the deposit.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    The open transactions for the customer transactions were not found.
    /// </exception>
    protected void settleCancellingCustTrans()
    {
        SpecTransManager specTransManager;
        container refCompany;
        CustTransOpen custTransOpenToSettle;

        Debug::assert(custTable.RecId != 0);

        refCompany += [custTransToCancel.company()];

        SpecTransExecutionContext specTransExecutionContext = SpecTransExecutionContext::newFromSource(custTable);
        specTransManager = SpecTransManager::newFromSpec(specTransExecutionContext.parmSpecContext());

        // Get open record for cancelled payment & mark for settlement
        while select crossCompany:refCompany custTransOpenToSettle
            where custTransOpenToSettle.RefRecId == custTransToCancel.RecId
        {
            specTransManager.insert(
                custTransOpenToSettle.company(),
                custTransOpenToSettle.TableId,
                custTransOpenToSettle.RecId,
                custTransOpenToSettle.AmountCur,
                custTransToCancel.CurrencyCode);
        }

        // Get open record for cancelling transaction & mark for settlement
        while select crossCompany:refCompany custTransOpenToSettle
            where custTransOpenToSettle.RefRecId == cancellingCustTrans.RecId
        {
            specTransManager.insert(
                custTransOpenToSettle.company(),
                custTransOpenToSettle.TableId,
                custTransOpenToSettle.RecId,
                custTransOpenToSettle.AmountCur,
                cancellingCustTrans.CurrencyCode);
        }

        if (specTransManager.getSpecTransCount() == 0)
        {
            throw error("@SYS25612");
        }

        // Settle transactions & close cancelling settlements
        changecompany(custTransToCancel.company())
        {
            CustTransSettleTransactionParameters custTransSettleTransactionParameters = CustTransSettleTransactionParameters::construct();
            custTransSettleTransactionParameters.ledgerVoucher = isPaymentInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher;
            CustTrans::settleTransaction(specTransExecutionContext, custTransSettleTransactionParameters);

            this.closeCancellingSettlements();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case CurrentVersion:
                this.create(packedClass);
                break;

            case Version2:
                [version, accountID, depositNum, cancelDate, reason, reasonComment, journalName,
                    locationRecId, terminalRecId, operatorRecId] = packedClass;
                break;

            case Version1:
                [version, #CurrentListV1] = packedClass;
                break;

            default :
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    private void create(container _packedClass)
    {
        container contractContainer;

        Version version;

        [version, accountID, depositNum, cancelDate, reason, reasonComment, journalName,
                    locationRecId, terminalRecId, operatorRecId, contractContainer] = _packedClass;
            
        if (TransactionReversalExecutionDetail::reversePostingFeatureEnabled())
        {
            contract = TransactionReversalContract::newFromExecutionId(emptyGuid());

            contract.unpack(contractContainer);

            if (contract != null)
            {
                // if no execution id then the contract was null.  This indicates we aren't using
                // the reversal framework
                if (contract.parmExecutionId() == emptyGuid())
                {
                    contract = null;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankAccountTransStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the canceled bank account transaction.
    /// </summary>
    protected void updateBankAccountTransStatus()
    {
        // Only add the cancelling reason, don't set the status to cancelled on the bank transaction
        bankAccountTransToCancel.ReasonRefRecID = ReasonTableRef::checkCreateInCompany( cancelReasonRef, bankAccountTransToCancel.DataAreaId);

        bankAccountTransToCancel.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankDocumentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates bank document status
    /// </summary>
    protected void updateBankDocumentStatus()
    {
        //use a new buffer instead of the form datasource buffer to avoid wrong UI update if any error occurs during update
        BankDeposit bankDeposit;

        if (BankAccountTable::isAdvancedBankReconciliationEnabled(depositToCancel.parmBankAccount())
            && BankDocumentTable::findBySource(depositToCancel.TableId, depositToCancel.RecId))
        {
            bankDeposit =  BankDeposit::find(depositToCancel.RecId, true);
            bankDeposit.Canceled = NoYes::Yes;
            bankDeposit.update();

            depositToCancel.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBridgePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the bridge posting record
    /// </summary>
    protected void updateBridgePosting()
    {
        LedgerTransFurtherPosting   ledgerTransFurtherPosting;
        LedgerEntry                 ledgerEntry;

        delete_from ledgerTransFurtherPosting
            where ledgerTransFurtherPosting.AccountNum == custTransToCancel.AccountNum
                && ledgerTransFurtherPosting.AccountType == LedgerJournalACType::Cust
            exists join ledgerEntry
                where ledgerEntry.RecId == ledgerTransFurtherPosting.RefRecId
                    && ledgerEntry.GeneralJournalAccountEntry == offsetGeneralJournalAccountEntryToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChequeStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the canceled bank account transaction.
    /// </summary>
    protected void updateChequeStatus()
    {
        BankChequeTable chequeToCancel;

        select firstonly forupdate chequeToCancel
            where chequeToCancel.Voucher == custTransToCancel.Voucher &&
                chequeToCancel.TransDate == custTransToCancel.TransDate &&
                chequeToCancel.ChequeNum == custTransToCancel.PaymReference &&
                chequeToCancel.RecipientType == BankChequeRecipientType::Cust &&
                chequeToCancel.AmountCur == custTransToCancel.AmountCur;

        if (chequeToCancel)
        {
            chequeToCancel.updateChequeStatusToCancelled(cancelReasonRef, chequeToCancel.DataAreaId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustTransCancelReason</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the customer transaction being canceled with the reason for the cancellation.
    /// </summary>
    protected void updateCustTransCancelReason()
    {
        changecompany(custTransToCancel.company())
        {
            custTransToCancel.selectForUpdate(true);

            custTransToCancel.reread();

            custTransToCancel.CancelledPayment = NoYes::Yes;
            custTransToCancel.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(cancelReasonRef, custTransToCancel.DataAreaId);

            custTransToCancel.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDepositStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the canceled deposit.
    /// </summary>
    protected void updateDepositStatus()
    {
        this.updateBankDocumentStatus();

        depositToCancel.Canceled = NoYes::Yes;
        depositToCancel.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(cancelReasonRef, depositToCancel.DataAreaId);

        depositToCancel.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates records related to the canceled deposit or payment.
    /// </summary>
    protected void updateRelatedRecords()
    {
        if (custTransToCancel.RecId)
        {
            // Get customer - will be used for reversals & settlements
            this.getCustTable();

            // Reverse settlements involving the payment being cancelled
            this.reverseSettlement();

            // Settle cancelled & cancelling transactions
            this.settleCancellingCustTrans();

            // Set the reason on the cancelled customer transaction
            this.updateCustTransCancelReason();

            // Update the check status - if one was associated to the customer transaction
            this.updateChequeStatus();

            // Remove any bridge posting records
            this.deleteLedgerTransFurtherPosting();
        }

        // Reverse taxes
        this.reverseTaxes();

        // Update status on cancelled deposit
        if (depositToCancel.RecId)
        {
            this.updateDepositStatus();
        }

        // Update status on cancelled bank transaction
        if (bankAccountTransToCancel)
        {
            this.updateBankAccountTransStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateToCancelPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the payment can be canceled.
    /// </summary>
    /// <returns>
    ///    true if the payment can be canceled; otherwise, false.
    /// </returns>
    protected boolean validateToCancelPayment()
    {
        boolean isValid = true;
        TransDate originalTransDate;
        BankAccountTable bankAccountTable;
        Voucher currentVoucher = this.getCancellationVoucher();

        bankAccountTable = BankAccountTable::find(this.parmAccountId()); 

        if (bankAccountTable.BankAccountStatus == BankAccountHoldStatus::InactiveForNewTransactions
            || bankAccountTable.BankAccountStatus == BankAccountHoldStatus::InactiveForAllTransactions)
        {
            isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_InactiveBankAccountError", currentVoucher, this.parmAccountId()));
        }
        else if (bankAccountTable.BankAccountStatus == BankAccountHoldStatus::ActiveForAllTransactions)
        {
            isValid = BankAccountTable::isActive(this.parmAccountId(), this.parmTransDate());

            if (!isValid)
            {
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_InactiveBankAccountError", currentVoucher, this.parmAccountId()));
            }
        }

        if (!bankAccountTransToCancel)
        {
            if (offsetGeneralJournalAccountEntryToCancel == 0)
            {
                // The offset to the customer transaction can't be found - bank or ledger
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_BankTransactionNotFoundError", currentVoucher));
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_LedgerTransactionNotFoundCheckDepositError", currentVoucher));
            }
        }
        else
        {
            if (cashGeneralJournalAccountEntryToCancel == 0)
            {
                // The ledger posting for the bank transaction can't be found
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_LedgerTransactionNotFoundCashBridgingError", currentVoucher));
            }
        }

        if (!custTransToCancel)
        {
            if (offsetGeneralJournalAccountEntryToCancel == 0)
            {
                // The offset to the bank transaction can't be found - customer or ledger
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_CustomerTransactionNotFoundError", currentVoucher));
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_LedgerTransactionNotFoundCheckDepositError", currentVoucher));
            }
        }

        // If payment is intercompany, there must be a deposit and the intercompany transactions must be found
        if (isPaymentInterCompany)
        {
            if (interCompanyDebitGeneralJournalAccountEntryToCancel == 0 || interCompanyCreditGeneralJournalAccountEntryToCancel == 0)
            {
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_LedgerTransactionsNotFoundDueToFrom", currentVoucher));
            }
        }

        originalTransDate = depositToCancel ? depositToCancel.TransDate : custTransToCancel.TransDate;

        // Cancellation date must not be before latest posting date
        if (originalTransDate > cancelDate)
        {
            isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_CancelDateBeforePostingDate",
                currentVoucher,
                date2StrUsr(cancelDate, DateFlags::FormatAll),
                date2StrUsr(originalTransDate, DateFlags::FormatAll)));
        }

        // Bank deposit must not be cancelled
        if (depositToCancel && depositToCancel.Canceled == NoYes::Yes)
        {
            isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_PaymentAlreadyCancelled",
                currentVoucher,
                depositToCancel.DepositNum));
        }

        // Bank transaction must not be reconciled
        if (bankAccountTransToCancel && bankAccountTransToCancel.Reconciled == NoYes::Yes)
        {
            if (bankAccountTransToCancel.PaymReference)
            {
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_PaymentReconciled",
                    currentVoucher,
                    bankAccountTransToCancel.PaymReference));
            }
            else
            {
                isValid = checkFailed(strFmt("@CashManagement:BankPaymentCancel_TransactionReconciled", currentVoucher));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS24593";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesTaxSettlementProcessRun_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether any partially settled customer transactions exists
    /// </summary>
    /// <param name="_custTrans">
    /// The customer map
    /// </param>
    /// <returns>
    /// True if any partially settled customer transactions exists
    /// </returns>
    public static boolean isSalesTaxSettlementProcessRun_IN(CustTrans  _custTrans)
    {
        ComponentTransactions_IN    componentTransactions;
        TaxTrans                    paymentTaxTrans;
        TaxTrans_W                  paymentTaxTrans_W;
        LedgerTransVoucherLink      ledgerTransVoucherLinkParent;
        LedgerTransVoucherLink      ledgerTransVoucherLinkChild;
        #ISOCountryRegionCodes

        if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])) && TaxParameters::checkTaxParametersExcludingCustoms_IN())
        {
            while select PaidAmount, PayableAmount from componentTransactions
                where componentTransactions.Voucher   == _custTrans.LastSettleVoucher
                   && componentTransactions.TransDate == _custTrans.TransDate
            {
                if (componentTransactions.PaidAmount != 0 &&
                    componentTransactions.PaidAmount < componentTransactions.PayableAmount)
                {
                    return true;
                }
            }
            //For servicetax partial settlement
            while select  RecId from ledgerTransVoucherLinkParent
                where ledgerTransVoucherLinkParent.Voucher         == _custTrans.Voucher
                   && ledgerTransVoucherLinkParent.TransDate      == _custTrans.TransDate
                   && ledgerTransVoucherLinkParent.VoucherGroupId == ledgerTransVoucherLinkParent.RecId
                join RecId from ledgerTransVoucherLinkChild
                    where ledgerTransVoucherLinkChild.VoucherGroupId  == ledgerTransVoucherLinkParent.RecId
                        && ledgerTransVoucherLinkChild.VoucherGroupId != ledgerTransVoucherLinkChild.RecId
                join RecId from paymentTaxTrans
                    where paymentTaxTrans.TransDate   == ledgerTransVoucherLinkChild.TransDate
                        && paymentTaxTrans.Voucher    == ledgerTransVoucherLinkChild.Voucher
                        && paymentTaxTrans.TaxOrigin  == TaxOrigin::Payment
                join RecId from paymentTaxTrans_W
                    where paymentTaxTrans_W.TaxTrans == paymentTaxTrans.RecId
                        && paymentTaxTrans_W.TaxType_IN == TaxType_IN::ServiceTax
                join PaidAmount, PayableAmount from componentTransactions
                    where componentTransactions.TransRecid == paymentTaxTrans.RecId
            {
                if (componentTransactions.PaidAmount != 0 &&
                    abs(componentTransactions.PaidAmount) < abs(componentTransactions.PayableAmount))
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        BankPaymCancelExt  bankPaymCancel;
        Args    localArgs = new Args();
        CustVendPDCManager  custVendPDCManager;

        if (args && args.record())
        {
            bankPaymCancel = BankPaymCancelExt::newBankPaymCancel(args.record());

            if (bankPaymCancel.prompt())
            {
                localArgs.caller(bankPaymCancel);
                localArgs.record(args.record());
                BankPaymCancelExt::serverRun(localArgs);

                custVendPDCManager = args.parmObject();
                if (custVendPDCManager)
                {
                    custVendPDCManager.parmCheckCancelStatus(true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onInitBankPaymCancel</Name>
				<Source><![CDATA[
    delegate void onInitBankPaymCancel(EventHandlerResult res, BankPaymCancelExt bankPaymCancel, Common _common, boolean _isMCRCancel = false){}

]]></Source>
			</Method>
			<Method>
				<Name>initBankPaymCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>BankPaymCancelExt</c> class and initializes several internal
    ///    variables with information from a <c>BankAccountTrans</c>, <c>BankDeposit</c>, or <c>CustTrans</c>
    ///    record.
    /// </summary>
    /// <param name="_common">
    ///    A record buffer that contains information about a deposit.
    /// </param>
    /// <param name="_isMCRCancel">
    ///  True if payment has to be canceled , false otherwise
    /// </param>
    /// <returns>
    ///    A new instance of the <c>BankPaymCancelExt</c> class that is initialized with values from the passed
    ///    in record buffer.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The table buffer that was passed into the method is not <c>BankDeposit</c> or <c>CustTrans</c>.
    /// </exception>
    public void initBankPaymCancel(Common _common,
                                   boolean _isMCRCancel = false)
    {
        CustTrans         localCustTrans;
        container         refCompany;

        EventHandlerResult result = new EventHandlerResult();

        this.onInitBankPaymCancel(result, this, _common, _isMCRCancel);

        if (!result.booleanResult())
        {
            switch (_common.TableId)
            {
                case tableNum(BankDeposit) :
                    this.parmBankDepositToCancel(_common);
                    this.parmTransDate(this.parmBankDepositToCancel().TransDate);
                    this.parmBankAccountTransToCancel(BankAccountTrans::findByDepositNum(this.parmBankDepositToCancel().DepositNum));

                    // Check to see if the offset to Bank is Customer or Ledger
                    if ((this.parmBankDepositToCancel().RefCompany != '') && (this.parmBankDepositToCancel().company() != this.parmBankDepositToCancel().RefCompany))
                    {
                        refCompany += [this.parmBankDepositToCancel().RefCompany];
                    }
                    else
                    {
                        refCompany += [this.parmBankDepositToCancel().company()];
                    }

                    select firstonly crossCompany:refCompany RecId from localCustTrans
                    where localCustTrans.RecId == this.parmBankDepositToCancel().RefRecId;

                    if (!localCustTrans)
                    {
                        // If there is no CustTrans, the offset to Bank is Ledger
                        this.parmIsLedgerAccountType(NoYes::Yes);
                    }

                    break;

                case tableNum(CustTrans) :
                    this.parmCustTrans(_common);

                    if (isConfigurationkeyEnabled(configurationKeyNum(TAMPromotionsManagement)) &&
                    this.parmCustTrans().mcrIsDeduction())
                    {
                        throw error(strFmt("@MCR:DeductionCancelForbiddenVoucher", this.parmCustTrans().Voucher));
                    }

                    this.parmTransDate(this.parmCustTrans().TransDate);
                    this.parmBankDepositToCancel(BankDeposit::findRef(this.parmCustTrans().RecId));
                    if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                    {
                        this.parmMCRIsMCRCancel(_isMCRCancel);
                    }
                    if (this.parmBankDepositToCancel())
                    {
                        this.parmBankAccountTransToCancel(BankAccountTrans::findByDepositNum(this.parmBankDepositToCancel().DepositNum));
                    }
                    else
                    {
                        this.parmBankAccountTransToCancel(this.findBankAccountTransByCustTrans(this.parmCustTrans()));
                    }
                    if (this.enableCashRegister_W())
                    {
                        this.initFromCashRegisterFiscalTrans_W(CashRegisterFiscalTrans_W::findCustTrans(this.parmCustTrans()));
                    }

                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBankPaymCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>BankPaymCancelExt</c> class and initializes several internal
    ///    variables with information from a <c>BankAccountTrans</c>, <c>BankDeposit</c>, or <c>CustTrans</c>
    ///    record.
    /// </summary>
    /// <param name="_common">
    ///    A record buffer that contains information about a deposit.
    /// </param>
    /// <param name="_isMCRCancel">
    ///  True if payment has to be canceled , false otherwise
    /// </param>
    /// <returns>
    ///    A new instance of the <c>BankPaymCancelExt</c> class that is initialized with values from the passed
    ///    in record buffer.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The table buffer that was passed into the method is not <c>BankDeposit</c> or <c>CustTrans</c>.
    /// </exception>
    public static BankPaymCancelExt newBankPaymCancel(Common _common
        ,boolean _isMCRCancel = false
        )
    {
        BankPaymCancelExt    bankPaymCancel;

        bankPaymCancel = new BankPaymCancelExt();

        bankPaymCancel.initBankPaymCancel(_common, _isMCRCancel);

        bankPaymCancel.parmAccountId(bankPaymCancel.parmBankAccountTransToCancel().AccountId);
        bankPaymCancel.parmDepositNum(bankPaymCancel.parmBankAccountTransToCancel().DepositNum);

        return bankPaymCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serverRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>BankPaymCancelExt</c> class from a pack and calls its <c>Run</c> method
    ///    on the server tier.
    /// </summary>
    /// <param name="args">
    ///    The arguments that contain the calling record and an instance of the <c>BankPaymCancelExt</c> class.
    /// </param>
    public static void serverRun(Args args)
    {
        BankPaymCancelExt    paymCancel;

        paymCancel = BankPaymCancelExt::newBankPaymCancel(args.record());
        paymCancel.unpack(args.caller().pack());
        paymCancel.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionsStatusAutomation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update collection status.
    /// </summary>
    protected void updateCollectionsStatusAutomation()
    {
        if (CustDisputeHistoryAutomation::doesDisputeExist(cancellingCustTrans.RecId, true))
        {
            CustDisputeHistoryAutomationPayment::updateCollectionsStatus(cancellingCustTrans.RecId, CustDisputeHistoryAutomationAction::PaymentCancel);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>