<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TransactionReversal_LedgerExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TransactionReversal_Ledger</c> class helps to reverse ledger transactions.
/// </summary>
/// <remarks>
///    This class helps in reversing transactions either directly from the <c>LedgerTransAccount</c> form,
///    or in reversing coherent ledger transactions upon reversal of a customer transaction. This class is
///    derived from the <see cref="T:TransactionReversal" />.
/// </remarks>
class TransactionReversal_LedgerExt extends TransactionReversalExt
{
    #isoCountryRegionCodes

    SysModule               sysModule; // Used in the method initLedgerVoucher
    NoYes                   exchangeAdjustment; // Is TransactionReversal_Ledger called due to reversal of an ExchangeAdjustment
    AmountMSTExchAdjustment exchangeAdjustmentAmount;
    AmountMSTSecondary      exchangeAdjustmentReportingAmount;
    List                    accrualVouchers;
    TransDate               exchangeRateDate;

    private boolean canReverse = true;
    private boolean doSkipCurrencyAdjustTrans;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createCustVendTrans_W</Name>
				<Source><![CDATA[
    private void createCustVendTrans_W(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        TransDate _transDate,
        Voucher _voucher,
        LedgerVoucher _ledgerVoucher,
        recId _callerCustVendRecId,
        boolean _revoke)
    {
        CustVendTrans   custVendTrans;
        CustTrans       custTransLocal, checkForReversalCustTrans;
        VendTrans       vendTransLocal, checkForReversalVendTrans;
        TransactionReversalTrans custTransReversalTrans, vendTransReversalTrans;

        switch (_generalJournalAccountEntry.PostingType)
        {
            // If a revalued voucher has already been reversed there will be more than one transaction with the same voucher and date.
            // We must be sure the exact record we want does not exist.
            case LedgerPostingType::VendBalance :
                select firstonly RecId from vendTransLocal where
                                vendTransLocal.Voucher == _voucher &&
                                vendTransLocal.TransDate == _transDate &&
                                vendTransLocal.RecId == _callerCustVendRecId;
                if (vendTransLocal.RecId != _callerCustVendRecId)
                {
                    if (_revoke)
                    {
                        checkForReversalVendTrans.selectLocked(false);
                        vendTransReversalTrans.selectLocked(false);

                        select firstonly checkForReversalVendTrans
                            where checkForReversalVendTrans.Voucher == _voucher &&
                                checkForReversalVendTrans.TransDate == _transDate
                            exists join vendTransReversalTrans
                                where vendTransReversalTrans.RefTableId == tablenum(VendTrans) &&
                                    vendTransReversalTrans.RefRecId == checkForReversalVendTrans.RecId &&
                                    vendTransReversalTrans.Reversed == NoYes::Yes &&
                                    vendTransReversalTrans.Original == NoYes::Yes;

                        custVendTrans = checkForReversalVendTrans;
                    }
                    else
                    {
                        checkForReversalVendTrans.selectLocked(false);

                        select firstonly checkForReversalVendTrans where
                            checkForReversalVendTrans.Voucher == _voucher &&
                            checkForReversalVendTrans.TransDate == _transDate &&
                            checkForReversalVendTrans.SettleAmountCur == 0 &&
                            checkForReversalVendTrans.Closed != reversalDate &&
                            checkForReversalVendTrans.LastSettleVoucher != reversalVoucher;

                        custVendTrans = checkForReversalVendTrans;
                    }

                    TransactionReversal_Vend::createAuxiliaryVendTrans(custVendTrans,
                                                                        reversalTraceNum,
                                                                        reversalVoucher,
                                                                        reversalDate,
                                                                        _ledgerVoucher,
                                                                        _revoke);
                }
                break;
            case LedgerPostingType::CustBalance :
                select firstonly RecId from custTransLocal where
                                custTransLocal.Voucher == _voucher &&
                                custTransLocal.TransDate == _transDate &&
                                custTransLocal.RecId == _callerCustVendRecId;

                if (custTransLocal.RecId != _callerCustVendRecId)
                {
                    if (_revoke)
                    {
                        checkForReversalCustTrans.selectLocked(false);
                        custTransReversalTrans.selectLocked(false);

                        select firstonly checkForReversalCustTrans
                            where checkForReversalCustTrans.Voucher == _voucher &&
                                checkForReversalCustTrans.TransDate == _transDate
                            exists join custTransReversalTrans
                                where custTransReversalTrans.RefTableId == tablenum(CustTrans) &&
                                    custTransReversalTrans.RefRecId == checkForReversalCustTrans.RecId &&
                                    custTransReversalTrans.Reversed == NoYes::Yes &&
                                    custTransReversalTrans.Original == NoYes::Yes;

                        custVendTrans = checkForReversalCustTrans;
                    }
                    else
                    {
                        checkForReversalCustTrans.selectLocked(false);

                        select firstonly checkForReversalCustTrans where
                            checkForReversalCustTrans.Voucher == _voucher       &&
                            checkForReversalCustTrans.TransDate == _transDate   &&
                            checkForReversalCustTrans.SettleAmountCur == 0      &&
                            checkForReversalCustTrans.Closed != reversalDate    &&
                            checkForReversalCustTrans.LastSettleVoucher != reversalVoucher;

                        custVendTrans = checkForReversalCustTrans;
                    }

                    TransactionReversal_Cust::createAuxiliaryCustTrans(
                        custVendTrans,
                        reversalTraceNum,
                        reversalVoucher,
                        reversalDate,
                        _ledgerVoucher,
                        _revoke);
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveLedgerPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the voucher used in the general journal creation.
    /// </summary>
    /// <param name = "_ledgerPostingController">
    /// The <c>LedgerPostingController</c> class in reference with the posting voucher.
    /// </param>
    /// <param name = "_referenceVoucher">
    /// The voucher that is used in the general journal creation.
    /// </param>
    /// <param name = "_newTransdate">
    /// The new transaction date.
    /// </param>
    /// <param name = "_accrual">
    /// A boolean value that indicates if the reversal transaction is accrual.
    /// </param>
    /// <param name = "_originalLedgerPostingReference">
    /// The original <c>LedgerVoucherObject</c> object. This object is obsolete,
    /// see the saveOriginalLedgerPostingReference() method.
    /// </param>
    /// <param name = "_transactionReversalCorrection">
    /// A boolean value that indicates if the reversal transaction is a correction.
    /// </param>
    /// <returns>
    /// The <c>LedgerVoucherObject</c> object.
    /// </returns>
    protected LedgerVoucherObject retrieveLedgerPostingReference(
            LedgerPostingController _ledgerPostingController,
            Voucher                 _referenceVoucher,
            TransDate               _newTransdate,
            boolean                 _accrual,
            LedgerVoucherObject     _originalLedgerPostingReference,
            boolean                 _transactionReversalCorrection)
    {
        LedgerVoucherObject ledgerPostingReference = _ledgerPostingController.getReference();

        if (ledgerPostingReference == null || _referenceVoucher != reversalVoucher)
        {
            ledgerPostingReference =
                LedgerVoucherObject::newReference(_referenceVoucher, _newTransdate);

            _ledgerPostingController.addReference(ledgerPostingReference);
        }

        if (_transactionReversalCorrection && !revoke)
        {
            ledgerPostingReference.parmIsCorrectionDefault(true);
        }

        return ledgerPostingReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOriginalLedgerPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>LedgerVoucherObject</c> class from the given <c>LedgerPostingController</c> class. 
    /// </summary>
    /// <param name = "_ledgerPostingController">The <c>LedgerPostingController</c> class 
    /// with reference to a <c>LedgerVoucherObject</c> class.</param>
    /// <param name = "_transDate">The transaction reversal date.</param>
    /// <param name = "_accrual">A boolean value that indicates if the reversal transaction is an accrual.</param>
    /// <returns>The <c>LedgerVoucherObject</c> class.</returns>
    [Wrappable(true)]
    protected final LedgerVoucherObject saveOriginalLedgerPostingReference(
        LedgerPostingController _ledgerPostingController,
        TransDate _transDate,
        boolean _accrual)
    {
        LedgerVoucherObject ledgerPostingReference = _ledgerPostingController.getReference();

        // verify the reference number and accounting date are correct
        Debug::assert(ledgerPostingReference.parmSubledgerVoucher() == reversalVoucher);
        // An accrual with a date prior to the reversal date will reverse on that date so it is valid for the dates not to equal
        Debug::assert(_accrual || ledgerPostingReference.parmAccountingDate() == _transDate);

        return ledgerPostingReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGeneralJournal</Name>
				<Source><![CDATA[
    void createGeneralJournal(
        Voucher         _voucher,
        TransDate       _transDate,
        LedgerVoucher   _ledgerVoucher,
        boolean         _newVoucher    = true,
        boolean         _accrual       = false,
        Voucher         _baseVoucher   = reversalVoucher,
        RecId           _callerCustVendRecId = 0,
        RecId           _accountingEvent = 0,
        boolean         _excludeSubledgerJournalTransfers = false)
    {
        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        LedgerJournalVoucherChanged ledgerJournalVoucherChangedAccrual;
        TransDate                   newTransdate = reversalDate;
        LedgerJournalTable          ledgerJournalTable;
        LedgerPostingController     ledgerPostingController;
        LedgerVoucherObject         ledgerPostingReference;
        LedgerVoucherObject         originalLedgerPostingReference;
        LedgerVoucherTransObject    ledgerPostingTransaction;
        GeneralJournalAccountEntry  generalJournalAccountEntry;
        GeneralJournalEntry         generalJournalEntry;
        LedgerEntry                 ledgerEntry;
        SubledgerVoucherGeneralJournalEntry subLedgerVoucherLink;
        boolean                     success;
        SubledgerJournalAccountEntry    subledgerJournalAccountEntry;
        SubledgerJournalEntry           subledgerJournalEntry;
        Voucher                     referenceVoucher;
        // <GIN>
        boolean                     countryRegion_IN    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        boolean                     isVATEnabled        = TaxParameters::isVATEnable_IN();
        // </GIN>
        // <GEERU>
        GeneralJournalAccountEntry  generalJournalAccountEntryOffset;
        GeneralJournalAccountEntry_W generalJournalAccountEntryW;
        Set                         ledgerTransSearchSet    = new Set(typeName2Type(extendedTypeStr(recId)));
        // </GEERU>
        boolean                     transactionReversalCorrection = LedgerParameters::find().TransactionReversalCorrection;

        if (_newVoucher)
        {
            reversalTraceNum = this.getReference(reversalTraceNum);
        }

        // If there is no original GeneralJournalAccountEntry, it is the first time of reversal
        if (originalGeneralJournalAccountEntry == null)
        {
             // if the sysModule is ledger, it is a reveral only of ledger hence a TransactionReversalTrans original must be created for the ledger transaction
            if (sysModule == SysModule::Ledger)
            {
                TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                            inputGeneralJournalAccountEntry.RecId,
                                                            reversalTraceNum,
                                                            true,
                                                            false,
                                                            false);
            }

            while select RecId, AccountingCurrencyAmount, ReportingCurrencyAmount, GeneralJournalEntry from generalJournalAccountEntry
                outer join IsExchangeAdjustment from ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                exists join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                      && generalJournalEntry.Ledger == Ledger::current()
                      && (!_excludeSubledgerJournalTransfers || generalJournalEntry.TransferId == 0)
                exists join subLedgerVoucherLink
                    where subLedgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                      && subLedgerVoucherLink.Voucher == _voucher
                      && subLedgerVoucherLink.VoucherDataAreaId == curext()
                      && subLedgerVoucherLink.AccountingDate == _transDate
            {
                // If this is an exchange adjustment reversal, only reverse GeneralJournalAccountEntry
                // lines with the same amount as the exch. adjustment. This is because the voucher may
                // contain a reversal of a previous exch. adjustment.
                if (this.parmExchangeAdjustment())
                {
                    if ((this.parmExchangeAdjustmentAmount() &&
                        (abs(this.parmExchangeAdjustmentAmount()) == abs(generalJournalAccountEntry.AccountingCurrencyAmount)))
                    ||
                    (this.parmExchangeAdjustmentReportingAmount() &&
                        (abs(this.parmExchangeAdjustmentReportingAmount()) == abs(generalJournalAccountEntry.ReportingCurrencyAmount)))
                    ||
                        ledgerEntry.IsExchangeAdjustment)
                    {
                        TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                                    generalJournalAccountEntry.RecId,
                                                                    reversalTraceNum,
                                                                    false,
                                                                    false);
                    }
                    else
                    {
                        continue;
                    }
                }
                else if (this.parmDoSkipCurrencyAdjustTrans() && this.hasAnyExchRateEntries(generalJournalAccountEntry.GeneralJournalEntry))
                {
                    continue;
                }
                else
                {
                    TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                                generalJournalAccountEntry.RecId,
                                                                reversalTraceNum,
                                                                false,
                                                                false);
                }
            }
        }

        this.setTransactionTxt(_transDate, _voucher);

        // use a local to hold the voucher to use for creating a ledgerPosdingRefernece in case accrual requires an additional one
        // we don't want to overwrite the default since it is required in other places
        referenceVoucher = reversalVoucher;

        if (_accrual)
        {
            if (_transDate > reversalDate)
            {
                // need a new voucher if the date is past the reversal date
                // never attempt to reuse any voucher except the reversalVoucher which contains all accrual amounts prior to the reversal date
                referenceVoucher = NumberSeq::newGetNum(LedgerParameters::numRefLedgerReversalVoucher(), false).num();
                if (accrualVouchers == null)
                {
                    accrualVouchers = new List(Types::String);
                }
                accrualVouchers.addEnd(referenceVoucher);
            }

            newTransdate = _transDate;
            ledgerJournalVoucherChangedAccrual.FromDate    = reversalDate;
            ledgerJournalVoucherChangedAccrual.FromVoucher = _baseVoucher;
            ledgerJournalVoucherChangedAccrual.ToDate      = newTransdate;
            ledgerJournalVoucherChangedAccrual.ToVoucher   = referenceVoucher;

            ledgerJournalVoucherChangedAccrual.insert();
        }

        // convert to the ledger posting controller model
        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

        // retrieve the reversal voucher + transaction date in cases of accruals because multiple accruals require us to reuse the reversal voucher
        // for accrual values dated on or before the reversal date
        if (_accrual && _transDate <= reversalDate)
        {
            if (LedgerFiscalCalendar::existDateWithOpenStatus(Ledger::fiscalCalendar(), _transDate))
            {
                ledgerPostingController.findReference(reversalVoucher, _transDate);
            }
            else
            {
                ledgerPostingController.findReference(reversalVoucher, reversalDate);
            }
        }

        if (ledgerPostingController.getReference() != null && referenceVoucher == reversalVoucher)
        {
            originalLedgerPostingReference = this.saveOriginalLedgerPostingReference(ledgerPostingController, newTransdate, _accrual);
        }
        ledgerPostingReference = this.retrieveLedgerPostingReference(ledgerPostingController, referenceVoucher, newTransdate, _accrual, originalLedgerPostingReference, transactionReversalCorrection);

        // The call is for fixed asset module, when only fixed asset transactions has to be reversed.
        if (!_excludeSubledgerJournalTransfers)
        {
            this.updateTaxTrans(_voucher, _transDate);
        }

        // <GIN>
        if (countryRegion_IN
            && TaxWithholdParameters_IN::checkTaxParameters())
        {
            this.updateTaxWithholdTrans_IN(_voucher, _transDate);
        }
        // </GIN>
        while select PostingLayer, JournalCategory, DocumentDate, DocumentNumber from generalJournalEntry
            where generalJournalEntry.Ledger == Ledger::current()
                && (!_excludeSubledgerJournalTransfers || generalJournalEntry.TransferId == 0)
        join RecId from subLedgerVoucherLink
            where subLedgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                && subLedgerVoucherLink.Voucher == _voucher
                && subLedgerVoucherLink.VoucherDataAreaId == curext()
                && subLedgerVoucherLink.AccountingDate == _transDate
        join * from generalJournalAccountEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
        // <GEERU>
        outer join * from generalJournalAccountEntryW
            where generalJournalAccountEntryW.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
               && generalJournalAccountEntryW.GeneralJournalEntry == generalJournalEntry.RecId
        // </GEERU>
        outer join * from ledgerEntry
            where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
        {
            // If this is an exchange adjustment reversal, only reverse GeneralJournalAccountEntry
            // lines with the same amount as the exch. adjustment. This is because the voucher may
            // contain a reversal of a previous exch. adjustment.

            // <GIN>
            if (revoke == false
                && isVATEnabled
                && generalJournalAccountEntry.PostingType == LedgerPostingType::VAT_IN)
            {
                generalJournalAccountEntry = this.reversalPostingVAT_IN(generalJournalAccountEntry,
                                                                        _voucher,
                                                                        _transDate,
                                                                        _ledgerVoucher);
            }
            //</GIN>

            if (FeatureExt::isFeatureEnabled('Dynamics.AX.Application.LedgerTransactionReversalDocumentNumberAndDateFeature')) //FeatureStateProvider::isFeatureEnabled(LedgerTransactionReversalDocumentNumberAndDateFeature::instance()))
            {
                ledgerPostingReference.parmDocumentDate(generalJournalEntry.DocumentDate);
                ledgerPostingReference.parmDocumentNumber(generalJournalEntry.DocumentNumber);
            }

            if (this.parmExchangeAdjustment())
            {
                if ((this.parmExchangeAdjustmentAmount() &&
                    (abs(this.parmExchangeAdjustmentAmount()) == abs(generalJournalAccountEntry.AccountingCurrencyAmount)))
                ||
                (this.parmExchangeAdjustmentReportingAmount() &&
                    (abs(this.parmExchangeAdjustmentReportingAmount()) == abs(generalJournalAccountEntry.ReportingCurrencyAmount)))
                ||
                    ledgerEntry.IsExchangeAdjustment)
                {
                    success = true;
                }
                else
                {
                    continue;
                }
            }
            else if (this.parmDoSkipCurrencyAdjustTrans() && this.hasAnyExchRateEntries(generalJournalAccountEntry.GeneralJournalEntry))
            {
                continue;
            }

            if (this.parmExchangeAdjustment() ||
                // <GEERU>
                (!this.parmExchangeAdjustment() &&
                generalJournalEntry.JournalCategory != LedgerTransType::AdvanceAdjustment_RU ||
                !generalJournalAccountEntryW.hasBond_RU()))
                // </GEERU>
            {
                if (ledgerPostingReference.parmPostingLayer() != generalJournalEntry.PostingLayer)
                {
                    if (originalLedgerPostingReference == null)
                    {
                        originalLedgerPostingReference = ledgerPostingReference;

                        // change the posting layer because we added this posting voucher
                        ledgerPostingReference = LedgerVoucherObject::newReference(referenceVoucher, newTransdate);
                        ledgerPostingReference.parmPostingLayer(generalJournalEntry.PostingLayer);
                        ledgerPostingController.addReference(ledgerPostingReference);
                    }
                    else
                    {
                        ledgerPostingReference = null;

                        // search for a posting voucher for the posting layer
                        if (ledgerPostingController.findReference(
                            originalLedgerPostingReference.parmSubledgerVoucher(),
                            originalLedgerPostingReference.parmAccountingDate(),
                            generalJournalEntry.PostingLayer))
                        {
                            ledgerPostingReference = ledgerPostingController.getReference();
                        }

                        if (ledgerPostingReference == null)
                        {
                            // create a new posting voucher for the posting layer
                            ledgerPostingReference = LedgerVoucherObject::newReference(
                                originalLedgerPostingReference.parmSubledgerVoucher(),
                                originalLedgerPostingReference.parmAccountingDate(),
                                originalLedgerPostingReference.parmSysModule());

                            ledgerPostingReference.parmPostingLayer(generalJournalEntry.PostingLayer);
                            ledgerPostingController.addReference(ledgerPostingReference);
                        }
                    }
                }

                if (_accrual)
                {
                    if (!TransactionReversalTrans::findTransactionReversalTrans(tableNum(GeneralJournalAccountEntry), generalJournalAccountEntry.RecId))
                    {
                        TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                                    generalJournalAccountEntry.RecId,
                                                                    reversalTraceNum,
                                                                    false,
                                                                    false);
                    }
                }
                // <GEERU>
                if (!ledgerTransSearchSet.in(generalJournalAccountEntry.RecId))
                {
                    if (generalJournalAccountEntryW.hasBond_RU())
                    {
                        ledgerTransSearchSet.add(generalJournalAccountEntry.RecId);
                    }
                // </GEERU>

                    // if an accounting event value exists we need to get the amount to reverse from the subledgerJournalAccountEntry in case of summarization
                    // and the GeneralJournalAccountEntry contains a summarized amount.
                    if (_accountingEvent)
                    {
                        select firstOnly RecId from subledgerJournalAccountEntry
                              where subledgerJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                        exists join subledgerJournalEntry
                            where subledgerJournalEntry.Ledger == Ledger::current() &&
                                subledgerJournalEntry.AccountingEvent == _accountingEvent &&
                                subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId;

                        if (subledgerJournalAccountEntry)
                        {
                            select sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount) from subledgerJournalAccountEntry
                                where subledgerJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                            join AccountingEvent, RecId from subledgerJournalEntry
                                where subledgerJournalEntry.AccountingEvent == _accountingEvent &&
                                    subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId;

                            // always set even if zero since we may read generalJournalAccountEntry records that did not come from this transaction.
                            generalJournalAccountEntry.TransactionCurrencyAmount = subledgerJournalAccountEntry.TransactionCurrencyAmount;
                            generalJournalAccountEntry.AccountingCurrencyAmount = subledgerJournalAccountEntry.AccountingCurrencyAmount;
                            generalJournalAccountEntry.ReportingCurrencyAmount = subledgerJournalAccountEntry.ReportingCurrencyAmount;
                        }
                    }

                    if (FeatureExt::isFeatureEnabled('Dynamics.AX.Application.LedgerJournalTransTxtLedgerReversingEntryFeature')) //FeatureStateProvider::isFeatureEnabled(LedgerJournalTransTxtLedgerReversingEntryFeature::instance()))
                    {
                        if (TransactionTextContext::isTypeSupported(LedgerTransTxt::TransactionReversal))
                        {
                            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::TransactionReversal);
                            transactionTextContext.setTableBuffer(generalJournalAccountEntry);
                            transactionTxt.setTransactionTextContext(transactionTextContext);
                        }
                    }

                    TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters parameters = TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters::construct();

                    parameters.parmGeneralJournalAccountEntry(generalJournalAccountEntry);
                    parameters.parmLedgerEntry(ledgerEntry);
                    parameters.parmTransactionReversalCorrection(transactionReversalCorrection);
                    parameters.parmLedgerPostingReference(ledgerPostingReference);

                    ledgerPostingTransaction = this.initializeLedgerVoucherTransObject(parameters);

                    ledgerPostingController.addTrans(ledgerPostingTransaction);

                    // <GEERU>
                    // sys code above is moved to createCustVendTrans_W() method. Method is called two times, first time here and second time for RU offset account bellow
                    this.createCustVendTrans_W(generalJournalAccountEntry, _transDate, _voucher, _ledgerVoucher, _callerCustVendRecId, revoke);

                    if (generalJournalAccountEntryW.hasBond_RU())
                    {
                        generalJournalAccountEntryOffset = generalJournalAccountEntryW.bondedLine_RU();
                        ledgerTransSearchSet.add(generalJournalAccountEntryOffset.RecId);

                        parameters.parmGeneralJournalAccountEntry(generalJournalAccountEntryOffset);

                        ledgerPostingTransaction = this.initializeLedgerVoucherTransObjectBond_RU(parameters);

                        ledgerPostingController.addTrans(ledgerPostingTransaction);

                        _ledgerVoucher.bondLast2_RU();

                        this.createCustVendTrans_W(generalJournalAccountEntryOffset, _transDate, _voucher, _ledgerVoucher, _callerCustVendRecId, revoke);
                    }
                }
                // </GEERU>
            }
        }

        while   select  ledgerJournalVoucherChanged
                where   ledgerJournalVoucherChanged.FromDate    == _transDate
                &&      ledgerJournalVoucherChanged.FromVoucher == _voucher
                exists join ledgerJournalTable
                where   ledgerJournalTable.JournalNum           == ledgerJournalVoucherChanged.JournalNum
                &&      (ledgerJournalTable.JournalType         == LedgerJournalType::Daily ||
                         ledgerJournalTable.JournalType         == LedgerJournalType::VendInvoiceRegister)
        {
            this.createGeneralJournal(
                ledgerJournalVoucherChanged.ToVoucher,
                ledgerJournalVoucherChanged.ToDate,
                _ledgerVoucher,
                false,
                true,
                reversalVoucher);
        }

        // The transaction for an approval has the old Voucher number on it.  Need to add a General Journal entry for new values when voucher number was changed.
        while   select  ledgerJournalVoucherChanged
                where   ledgerJournalVoucherChanged.FromDate      == _transDate
                &&      ledgerJournalVoucherChanged.FromVoucher   == _voucher
                exists join ledgerJournalTable
                where   ledgerJournalTable.JournalNum           == ledgerJournalVoucherChanged.JournalNum
                &&      ledgerJournalTable.JournalType          == LedgerJournalType::Approval
        {
            if (ledgerJournalVoucherChanged.ToVoucher == _voucher && ledgerJournalVoucherChanged.ToDate == _transDate)
            {
                continue;
            }

            this.createGeneralJournal(
                ledgerJournalVoucherChanged.ToVoucher,
                ledgerJournalVoucherChanged.ToDate,
                _ledgerVoucher,
                false,
                true,
                reversalVoucher);
        }

        while   select  ledgerJournalVoucherChanged
                where   ledgerJournalVoucherChanged.FromDate    == _transDate
                &&      ledgerJournalVoucherChanged.FromVoucher == _voucher
                &&      !ledgerJournalVoucherChanged.JournalNum
        {
            this.createGeneralJournal(
                ledgerJournalVoucherChanged.ToVoucher,
                ledgerJournalVoucherChanged.ToDate,
                _ledgerVoucher,
                false,
                true,
                reversalVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectBond_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> object when current transaction is bonded.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters</c> instance with parameters to initialize the <c>LedgerVoucherTransObject</c> object.
    /// </param>
    /// <returns>
    /// Initialized <c>LedgerVoucherTransObject</c> object.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectBond_RU(TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters _parameters)
    {
        LedgerVoucherTransObject ledgerPostingTransaction = LedgerVoucherTransObject::newGeneralJournal(_parameters.parmGeneralJournalAccountEntry(), _parameters.parmLedgerEntry());
        ledgerPostingTransaction.parmIsCorrection(_parameters.parmLedgerPostingReference().parmIsCorrectionDefault());

        if (!revoke || _parameters.parmTransactionReversalCorrection())
        {
            ledgerPostingTransaction.updateSignSide(!revoke, !_parameters.parmTransactionReversalCorrection());
        }
        else
        {
            Debug::assert(revoke);
            ledgerPostingTransaction.updateSignSide(false, false);
        }

        TaxTransGeneralJournalAccountEntry::reversePostedLinks(
                            _parameters.parmGeneralJournalAccountEntry().RecId,
                            taxTransRecIdMap,
                            ledgerPostingTransaction);

        ledgerPostingTransaction.parmText(transactionTxt.txt());
        ledgerPostingTransaction.parmReasonCode(reasonRefRecID);
        ledgerPostingTransaction.parmIgnoreAllocation(true);

        ledgerPostingTransaction.parmHistoricalExchangeRateDate(_parameters.parmGeneralJournalAccountEntry().HistoricalExchangeRateDate);

        return ledgerPostingTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> object.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters</c> instance with parameters to initialize the <c>LedgerVoucherTransObject</c> object.
    /// </param>
    /// <returns>
    /// Initialized <c>LedgerVoucherTransObject</c> object.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObject(TransactionReversalLedgerInitializeLedgerVoucherTransObjectParameters _parameters)
    {
        LedgerVoucherTransObject ledgerPostingTransaction = LedgerVoucherTransObject::newGeneralJournal(_parameters.parmGeneralJournalAccountEntry(), _parameters.parmLedgerEntry());

        ledgerPostingTransaction.parmSkipDimensionValidation(true);

        if (_parameters.parmTransactionReversalCorrection() && !revoke)
        {
            ledgerPostingTransaction.parmIsCorrection(_parameters.parmLedgerPostingReference().parmIsCorrectionDefault());
        }

        if (!revoke || _parameters.parmTransactionReversalCorrection())
        {
            ledgerPostingTransaction.updateSignSide(!revoke, !_parameters.parmTransactionReversalCorrection());
        }
        else
        {
            Debug::assert(revoke);
            ledgerPostingTransaction.updateSignSide(false, false);
        }

        TaxTransGeneralJournalAccountEntry::reversePostedLinks(
                        _parameters.parmGeneralJournalAccountEntry().RecId,
                        taxTransRecIdMap,
                        ledgerPostingTransaction);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            TaxWHTTransGeneralJournalAccountEntry_IN::reversePostedLinks(
                _parameters.parmGeneralJournalAccountEntry().RecId,
                taxWHTransRecIdMap,
                ledgerPostingTransaction);
        }

        if (transactionTxt.txt())
        {
            ledgerPostingTransaction.parmText(transactionTxt.txt());
        }

        ledgerPostingTransaction.parmReasonCode(reasonRefRecID);
        // don't allocate since we are reversing records that have already been allocated
        ledgerPostingTransaction.parmIgnoreAllocation(true);

        ledgerPostingTransaction.parmHistoricalExchangeRateDate(_parameters.parmGeneralJournalAccountEntry().HistoricalExchangeRateDate);

        return ledgerPostingTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>LedgerVoucher</c> class, when it is implemented in a derived class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>LedgerVoucher</c> class, when this method is implemented in a derived
    ///    class.
    /// </returns>
    /// <remarks>
    ///    This method must be implemented by derived classes, so that the <c>LedgerVoucher</c> class is
    ///    created by using the correct <c>SysModule</c> enumeration type, such as the <c>SysModule::Cust</c>
    ///    enumeration value. If called directly from this base class, this method will throw an error that
    ///    indicates that it must be implemented by a derived class.
    /// </remarks>
    public LedgerVoucher initLedgerVoucher()
    {
        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Ledger, LedgerParameters::numRefLedgerReversalVoucher().numberSequenceTable().NumberSequence);
        ledgerVoucher.parmReversal(true);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetCheckRequired</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether budget funds available check is required for the ledger transaction reversal
    ///    process.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    protected boolean isBudgetCheckRequired()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoSkipCurrencyAdjustTrans</Name>
				<Source><![CDATA[
    public boolean parmDoSkipCurrencyAdjustTrans(boolean _doSkipCurrencyAdjustTrans = doSkipCurrencyAdjustTrans)
    {
        doSkipCurrencyAdjustTrans = _doSkipCurrencyAdjustTrans;
        return doSkipCurrencyAdjustTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeAdjustment</Name>
				<Source><![CDATA[
    public NoYes parmExchangeAdjustment(NoYes _exchangeAdjustment = exchangeAdjustment)
    {
        exchangeAdjustment = _exchangeAdjustment;
        return exchangeAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeAdjustmentAmount</Name>
				<Source><![CDATA[
    public AmountMSTExchAdjustment parmExchangeAdjustmentAmount(AmountMSTExchAdjustment _exchangeAdjustmentAmount = exchangeAdjustmentAmount)
    {
        exchangeAdjustmentAmount = _exchangeAdjustmentAmount;

        return exchangeAdjustmentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeAdjustmentReportingAmount</Name>
				<Source><![CDATA[
    public AmountMSTSecondary parmExchangeAdjustmentReportingAmount(AmountMSTSecondary _exchangeAdjustmentReportingAmount = exchangeAdjustmentReportingAmount)
    {
        exchangeAdjustmentReportingAmount = _exchangeAdjustmentReportingAmount;

        return exchangeAdjustmentReportingAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecId</Name>
				<Source><![CDATA[
    public ReasonRefRecID parmReasonRefRecId(ReasonRefRecID _reasonRefRecID = reasonRefRecID)
    {
        reasonRefRecID = _reasonRefRecID;
        return reasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSysModule</Name>
				<Source><![CDATA[
    public SysModule parmSysModule(SysModule _sysModule = sysModule)
    {
        sysModule = _sysModule;
        return sysModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDeferredAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a voucher for the defered amount after authority settlement
    /// </summary>
    /// <param name="_voucher">
    /// Transaction Voucher
    /// </param>
    /// <param name="_transdate">
    /// Transaction date
    /// </param>
    /// <param name="_ledgerVoucher">
    /// LedgerVoucher object
    /// </param>
    /// <param name="_deferdAmount">
    /// defered amount to be posted
    /// </param>
    /// <param name="_ledgerDimension">
    /// Account to which amount has to be posted
    /// </param>
    /// <param name="_currencyCode">
    /// Transaction currency code
    /// </param>
    public void postDeferredAmount_IN(
        Voucher                         _voucher,
        TransDate                       _transdate,
        LedgerVoucher                   _ledgerVoucher,
        AmountCur                       _deferdAmount,
        LedgerDimensionDefaultAccount   _ledgerDimension,
        CurrencyCode                    _currencyCode)
    {
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerPostingController         ledgerPostingController;
        CurrencyExchangeHelper          currencyExchangeHelper;

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _transDate);

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerPostingController.getReference(),
                                                    LedgerPostingType::VAT_IN,
                                                    _ledgerDimension,
                                                    _currencyCode,
                                                    _deferdAmount,
                                                    currencyExchangeHelper);

        ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
        ledgerVoucherTransObject.parmIgnoreAllocation(true);
        ledgerPostingController.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts new records in the <c>TransactionReversalTrans</c> table for the new, reversed, or revoked ledger transaction after a ledger transaction reversal or revoke.
    /// </summary>
    void postReversal() // postReversal = after reversal
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        ListEnumerator              accrualVoucherEnumerator;
        Voucher                     accrualVoucher;

        // the reversal voucher and reversal date are always present becuase the default is to generate one voucher
        while select RecId from generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherLink
                where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherLink.Voucher == reversalVoucher
                    && subledgerVoucherLink.VoucherDataAreaId == curext()
                    && subledgerVoucherLink.AccountingDate == reversalDate
        {
            TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                        generalJournalAccountEntry.RecId,
                                                        reversalTraceNum,
                                                        false,
                                                        false);
        }

        // there may be more vouchers generated by accruals
        if (accrualVouchers != null)
        {
            accrualVoucherEnumerator = accrualVouchers.getEnumerator();
            while (accrualVoucherEnumerator.moveNext())
            {
                accrualVoucher = accrualVoucherEnumerator.current();

                // the date is different from the reversal date so don't use date as criteria
                while select RecId from generalJournalAccountEntry
                    exists join generalJournalEntry
                        where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                            && generalJournalEntry.Ledger == Ledger::current()
                    exists join subledgerVoucherLink
                        where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                            && subledgerVoucherLink.Voucher == accrualVoucher
                            && subledgerVoucherLink.VoucherDataAreaId == curext()
                {
                    TransactionReversalTrans::createTransaction(tableNum(GeneralJournalAccountEntry),
                                                                generalJournalAccountEntry.RecId,
                                                                reversalTraceNum,
                                                                false,
                                                                false);
                }
            }

            accrualVouchers = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversal</Name>
				<Source><![CDATA[
    void reversal(Args args)
    {
        GeneralJournalEntry inputGeneralJournalEntry;
        GeneralJournalEntry originalGeneralJournalEntry;
        GeneralJournalEntry validGeneralJournalEntry;
        SubledgerVoucherGeneralJournalEntry validSubledgerVoucherGeneralJournalEntry;
        SubledgerVoucherGeneralJournalEntry originalSubledgerVoucherGeneralJournalEntry;
        SubledgerVoucherGeneralJournalEntry inputSubledgerVoucherGeneralJournalEntry;
        LedgerExchAdjHist foreignCurrencyRevalHistory;
     
        super(args);

        if (args.dataset() != tableNum(GeneralJournalAccountEntry) && args.dataset() != tableNum(LedgerExchAdjHist))
        {
            throw error(Error::missingFormActiveBuffer(classStr(TransactionReversal_Ledger)));
        }

        originatingRecord = args.record();

        if (args.dataset() == tableNum(GeneralJournalAccountEntry))
        {
            inputGeneralJournalAccountEntry = originatingRecord as GeneralJournalAccountEntry;
        }
        else if (args.dataset() == tableNum(LedgerExchAdjHist))
        {
            foreignCurrencyRevalHistory = originatingRecord as LedgerExchAdjHist;

            select firstonly * from inputGeneralJournalAccountEntry
                exists join inputGeneralJournalEntry
                    where inputGeneralJournalEntry.SubledgerVoucher == foreignCurrencyRevalHistory.SubledgerVoucher &&
                        inputGeneralJournalEntry.AccountingDate == foreignCurrencyRevalHistory.AccountingDate &&
                        inputGeneralJournalEntry.Ledger == foreignCurrencyRevalHistory.Ledger &&
                        inputGeneralJournalEntry.RecId == inputGeneralJournalAccountEntry.GeneralJournalEntry;
        }

        [originalGeneralJournalAccountEntry, revoke, reversalTraceNum] =
            TransactionReversalTrans::findGeneralJournalOriginal(inputGeneralJournalAccountEntry);

        if (originalGeneralJournalAccountEntry != null)
        {
            select firstonly * from originalGeneralJournalEntry
                where originalGeneralJournalEntry.RecId == originalGeneralJournalAccountEntry.GeneralJournalEntry
            join * from originalSubledgerVoucherGeneralJournalEntry
                where originalSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry == originalGeneralJournalEntry.RecId;
        }

        if (inputGeneralJournalAccountEntry != null)
        {
            select firstonly * from inputGeneralJournalEntry
                where inputGeneralJournalEntry.RecId == inputGeneralJournalAccountEntry.GeneralJournalEntry
            join * from inputSubledgerVoucherGeneralJournalEntry
                where inputSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry == inputGeneralJournalEntry.RecId;
        }

        if (originalGeneralJournalAccountEntry == null)
        {
            validGeneralJournalEntry = inputGeneralJournalEntry;
            validSubledgerVoucherGeneralJournalEntry = inputSubledgerVoucherGeneralJournalEntry;
        }
        else
        {
            validGeneralJournalEntry = originalGeneralJournalEntry;
            validSubledgerVoucherGeneralJournalEntry = originalSubledgerVoucherGeneralJournalEntry;
        }

        this.defaultReversalDate(inputGeneralJournalEntry.AccountingDate);

        if (args.dataset() == tableNum(LedgerExchAdjHist))
        {
            if (!GeneralJournalAccountEntry_Extension::checkGeneralJournalEntryAccountingDate(inputGeneralJournalAccountEntry, inputGeneralJournalEntry))
            {
                info("@GeneralLedger:ForeignCurrencyRevaluationReversalYearClosed");
            }
        }

        this.validateReverse(); // MOD: updated cause original method is obsolete
        
        if (canReverse &&
            this.checkLedgerPostingTypeApplicable(
                validSubledgerVoucherGeneralJournalEntry.Voucher,
                validSubledgerVoucherGeneralJournalEntry.AccountingDate))
        {
            if (originalGeneralJournalEntry == null)
            {
                minimumDate = inputSubledgerVoucherGeneralJournalEntry.AccountingDate;
            }
            else
            {
                minimumDate = revoke ? inputSubledgerVoucherGeneralJournalEntry.AccountingDate : originalSubledgerVoucherGeneralJournalEntry.AccountingDate;
            }

            this.saveLast();

            if (this.skipDialogPrompt(args) || this.prompt())
            {
                ttsbegin;
                this.parmSysModule(SysModule::Ledger);
                this.initLedgerVoucher();

                this.createGeneralJournal(
                    validSubledgerVoucherGeneralJournalEntry.Voucher,
                    validSubledgerVoucherGeneralJournalEntry.AccountingDate,
                    ledgerVoucher);

                ledgerVoucher.end();

                // Submit the budget funds available check
                this.submitBudget();

                this.postReversal();

                LedgerVoucherList ledgerVoucherList = ledgerVoucher.getInternalCollection();
                ledgerVoucherList.first();
                LedgerVoucherObject ledgerVoucherObject = ledgerVoucherList.item() as LedgerVoucherObject;

                this.voucherReversed(
                    ledgerVoucherObject.parmVoucher(),
                    ledgerVoucherObject.parmAccountingDate(),
                    ledgerVoucherObject.parmLedger(),
                    originatingRecord,
                    revoke);

                this.updateOriginal(validSubledgerVoucherGeneralJournalEntry.AccountingDate, validSubledgerVoucherGeneralJournalEntry.Voucher);

                TransactionLog::create(TransactionLogType::TransactionReversal, "@SYS88953");
                ttscommit;

                this.logResult(inputGeneralJournalEntry.SubledgerVoucher, inputGeneralJournalEntry.AccountingDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logResult</Name>
				<Source><![CDATA[
    private void logResult(Voucher _voucher, TransDate _transDate)
    {
        // Give more detailed errors when the mass reversal feature is being used.
        if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            if (revoke)
            {
                info(strFmt("@GeneralLedger:TransactionReversalRevoked", _voucher, _transDate));
            }
            else
            {
                info(strFmt("@GeneralLedger:TransactionReversalSuccess", _voucher, _transDate));
            }
                
            reverseSuccessful = true;
        }
        else
        {
            info(revoke ? "@SYS78557" : "@SYS78558");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does validation against the transaction attempting to be reversed, throwing errors as appropriate.
    /// </summary>
    //[SysObsolete('Please use TransactionReversal_Ledger.validateReverse() instead.', false, 25\06\2020)]
    //protected void validateCanReverse()
    //{
    //    this.validateReverse();
    //}

    /// <summary>
    /// Performs validation against the transaction attempting to be reversed.
    /// </summary>
    /// <returns>
    /// A boolean value indicating if the reversal was successful.
    /// </returns>
    protected boolean validateReverse()
    {
        canReverse = true;

        LedgerEntry ledgerEntry;
        select firstonly * from ledgerEntry where ledgerEntry.GeneralJournalAccountEntry == inputGeneralJournalAccountEntry.RecId;

        if (!inputGeneralJournalAccountEntry.canReverse(ledgerEntry))
        {
            canReverse = false;

            // The mass transaction reversal feature does not throw errors if a provider cannot
            // reverse a transaction.  Other providers may decide to reverse it.
            // If being invoked without the feature on or via the old reversal menu items
            // then we need this to work the way it has in the past.
            if (!TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
            {
                throw error(strFmt("@GeneralLedger:TransactionReversalNoReverseForAccountMessage",
                    GeneralJournalEntry::findByGeneralJournalAccountEntry(inputGeneralJournalAccountEntry.RecId).SubledgerVoucher,
                    inputGeneralJournalAccountEntry.PostingType,
                    inputGeneralJournalAccountEntry.LedgerAccount));
            }
        }

        return canReverse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversalPostingVAT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to reversal posting of the GeneralJournalAccountEntry.
    /// </summary>
    /// <param name="_generalJournalAccountEntry">
    /// The GeneralJournalAccountEntry record.
    /// </param>
    /// <param name="_voucher">
    /// The voucher for which we need the payable account.
    /// </param>
    /// <param name="_transDate">
    /// The transDate.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher Object.
    /// </param>
    /// <returns>
    /// The GeneralJournalAccountEntry record.
    /// </returns>
    public GeneralJournalAccountEntry reversalPostingVAT_IN(
        GeneralJournalAccountEntry             _generalJournalAccountEntry,
        Voucher                                _voucher,
        TransDate                              _transDate,
        LedgerVoucher                          _ledgerVoucher = null)
    {
        container                       taxTransRecs;
        TaxTrans_IN                     taxTransLocalPeriodic;
        int                             loop;
        LedgerDimensionAccount          ledgerDimensionDefault;
        TaxCode                         taxCode;
        LedgerDimensionAccount          ledgerDimension;
        TaxAmount                       deferred;
        TaxAmount                       payable;
        boolean                         posted;
        LedgerJournalTrans              ledgerJournalTrans;

        taxCode = TaxTrans::findByGeneralJournalAccountEntry_IN(_generalJournalAccountEntry.RecId).TaxCode;

        [posted,deferred,payable,ledgerDimension,taxTransRecs] = this.getDeferementInfo_IN(_generalJournalAccountEntry, taxCode, _voucher, _transDate);

        ledgerJournalTrans = LedgerJournalTrans::findJournalForVoucher(_voucher, _transDate);

        if (goodsType == VATGoodsType_IN::Input
            // if the journal transactions are posted with any goods type with ledger and ledger combination then system should pick  always payable a/c.
            || (ledgerJournalTrans.RecId && (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                 && ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)))
        {
            ledgerDimensionDefault = this.getPayableAccount_IN(_generalJournalAccountEntry.LedgerDimension, taxCode, _voucher, _transDate);
            _generalJournalAccountEntry.LedgerDimension = ledgerDimensionDefault ? ledgerDimensionDefault : _generalJournalAccountEntry.LedgerDimension;
        }
        else
        {
            if (deferred)
            {
                this.updateDefermentScheduleLinesVAT_IN(deferred);
            }
            else
            {
                this.updateDefermentScheduleLinesVAT_IN(abs(_generalJournalAccountEntry.TransactionCurrencyAmount));
            }

            if (posted)
            {
                // The deferred amount should hit the defferred account after the authority settlement
                if (deferred != 0)
                {
                    this.postDeferredAmount_IN(_voucher, _transDate, _ledgerVoucher, -deferred,
                                                _generalJournalAccountEntry.LedgerDimension,
                                                _generalJournalAccountEntry.TransactionCurrencyCode);
                }
                // After the authority settlement, the amount in the recoverable should hit payable account
                if (payable !=0)
                {
                    _generalJournalAccountEntry.AccountingCurrencyAmount  = payable;
                    _generalJournalAccountEntry.TransactionCurrencyAmount = _generalJournalAccountEntry.AccountingCurrencyAmount;
                    _generalJournalAccountEntry.ReportingCurrencyAmount   = _generalJournalAccountEntry.AccountingCurrencyAmount;
                    _generalJournalAccountEntry.LedgerDimension           = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension);
                }
            }

            for (loop = 1; loop <= conlen(taxTransRecs); loop++)
            {
                taxTransLocalPeriodic = TaxTrans_IN::findRecId(conpeek(taxTransRecs,loop),true);
                taxTransLocalPeriodic.vatDefLineTransferred = NoYes::Yes;
                taxTransLocalPeriodic.update();
            }
        }

        return _generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS78542";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        LedgerExchAdjHist   ledgerExchAdjHist;

        TransactionReversal_LedgerExt transactionReversal = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) ?
                                                           new TransactionReversal_Ledger_RUExt() :
                                                           TransactionReversal_LedgerExt::construct();

        if (args.dataset() == tableNum(LedgerExchAdjHist))
        {
            ledgerExchAdjHist = args.record();
        }

        if (ledgerExchAdjHist && ledgerExchAdjHist.LegalEntity != curExt())
        {
            changecompany(ledgerExchAdjHist.LegalEntity)
            {
                transactionReversal.reversal(args);
            }
        }
        else
        {
            transactionReversal.reversal(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>TransactionReversal_Ledger</c> object.
    /// </summary>
    /// <returns>A new instance of the <c>TransactionReversal_Ledger</c> object.</returns>
    public static TransactionReversal_LedgerExt construct()
    {
        return new TransactionReversal_LedgerExt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        taxTransRecIdMap = new Map(Types::Int64, Types::Int64);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a new <see cref="T:TransactionTxt" /> object, with the chance of using the specified
    ///    transaction date and voucher.
    /// </summary>
    /// <param name="_transDate">
    ///    The date to set in the <c>TransactionTxt</c> object.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher to set in the <c>TransactionTxt</c> object.
    /// </param>
    /// <param name="_formLetterNum">
    ///    The form letter number to set in the <c>TransactionTxt</c> object; optional.
    /// </param>
    /// <param name = "_key1">The first key; optional.</param>
    /// <param name = "_key2">The second key; optional.</param>
    /// <param name = "_key3">The third key; optional.</param>
    public void setTransactionTxt(
        TransDate _transDate,
        Voucher _voucher,
        str 20 _formLetterNum = '',
        str 20 _key1 = '',
        str 20 _key2 = '',
        str 20 _key3 = '')
    {
        str 20 formLetterNum = _formLetterNum;
        str 20 key1 = _key1;

        if (!key1 || !formLetterNum)
        {
            if (sysModule == SysModule::Cust)
            {
                CustTrans custTransLocal = CustTrans::findVoucherDate(_voucher, _transDate);

                if (!formLetterNum)
                {
                    formLetterNum = custTransLocal.Invoice;
                }

                if (!key1)
                {
                    key1 = custTransLocal.AccountNum;
                }
            }
            else if (sysModule == SysModule::Vend)
            {
                VendTrans vendTransLocal = VendTrans::findVoucherDate(_voucher, _transDate);

                if (!formLetterNum)
                {
                    formLetterNum = vendTransLocal.Invoice;
                }

                if (!key1)
                {
                    key1 = vendTransLocal.AccountNum;
                }
            }
        }

        super(_transDate, _voucher, formLetterNum, key1, _key2, _key3);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAnyExchRateEntries</Name>
				<Source><![CDATA[
    private boolean hasAnyExchRateEntries(RefRecId _generalJournalEntry)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;

        select firstonly RecId from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == _generalJournalEntry
                && (generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateGain
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateLoss);

        return generalJournalAccountEntry.RecId != 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>