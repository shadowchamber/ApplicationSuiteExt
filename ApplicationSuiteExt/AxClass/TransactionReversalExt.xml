<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TransactionReversalExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TransactionReversal</c> class is the parent class of a hierarchy for reversing transactions.
/// </summary>
/// <remarks>
///    For example, if a customer transaction is to be reversed, the class
///    <c>TransactionReversal_Cust</c>, which derives from this class, is called. During a reversal of a
///    customer transaction, a new customer transaction that has the reversed amount is created and
///    settled. Also the ledger transactions connected to the customer transaction are reversed. A table
///    named <c>TransactionReversal</c> will contain a record for each reversed transaction. The
///    transactions in the table <c>TransactionReversal</c> will never be deleted, so they can be used for
///    historical reasons.If a record that has been reversed is reversed again, it is called a revoke, and
///    the original transaction is open, while the reversed and revoked transactions are settled.It is not
///    possible to reverse transactions that are connected to the inventory such as a sales order invoice.
/// </remarks>
abstract class TransactionReversalExt extends RunBase
{

    LedgerParameters            ledgerParameters;

    CustTransCashDisc           custTransCashDisc;
    VendTransCashDisc           vendTransCashDisc;
    TransactionTxt              transactionTxt;
    Voucher                     reversalVoucher;            // The voucher for the reversal (FORMERLY KNOWN AS newVoucher)
    TransDate                   reversalDate;               // The date for the reversal (FORMERLY KNOWN AS newDate)
    TransDate                   minimumDate;
    TraceNum                    reversalTraceNum;           // The trace number for the reversal
    boolean                     revoke;                     // If the original transaction is reversed, then this is a revoke

    LedgerVoucher               ledgerVoucher;

    VendTrans                   vendTrans;
    VendTrans                   vendTransOrig;
    CustTrans                   custTrans;
    CustTrans                   custTransOrig;
    GeneralJournalAccountEntry  inputGeneralJournalAccountEntry;
    GeneralJournalAccountEntry  originalGeneralJournalAccountEntry;
    Common                      originatingRecord;

    ReasonCode                  reasonCode;
    ReasonComment               reasonComment;
    ReasonRefRecID              reasonRefRecID;

    Map                         taxTransRecIdMap;
    Map                         taxWHTransRecIdMap;

    DialogField                 dialogReverseDate;

    Set                         budgetControlGeneralJournalEntries;

    //<GIN>
    VATGoodsType_IN                 goodsType;
    //</GIN>

    private TransactionReversalContract contract; 

    protected boolean reverseSuccessful;

    #DEFINE.CurrentVersion(3)
    #LOCALMACRO.CurrentList
        reversalDate,
        minimumDate,
        revoke
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    public void saveLast()
    {
        // saveLast() isn't applicable for the mass transaction reversal feature
        // as the values from the dialog don't apply to subsequent runs.
        if (!TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReversalDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the reversal date if a date wasn't supplied to the reversal process.
    /// </summary>
    /// <param name = "_date">The default date.</param>
    [Hookable(false)]
    protected void defaultReversalDate(TransDate _date)
    {
        if (!reversalDate 
            && TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            reversalDate = _date;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses a single transaction.
    /// </summary>
    /// <param name = "_common">The record to be reversed.</param>
    /// <returns>A boolean value indicating whether or not the reversal was successful.</returns>
    /// <remarks>
    /// Throws an exception if the reversal is not allowed due to business rules.
    /// Returns false if the current reversal provider cannot reverse the transaction.
    /// Returns true if the current reversal provider reverses successfully.  
    /// </remarks>
    [Hookable(false)]
    public boolean reverseTransaction(Common _common)
    {
        Args args = new Args();
        args.record(_common);

        this.reversal(args);

        return reverseSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReasonCodeMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if reason codes are mandatory.
    /// </summary>
    /// <returns>true if reason codes are mandatory; otherwise, false.</returns>
    [Hookable(false)]
    public boolean isReasonCodeMandatory()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherReversed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for post ledger transaction reversal handling.
    /// </summary>
    /// <param name = "_voucher">The reversal voucher.</param>
    /// <param name = "_accountingDate">The accounting date of the reversal.</param>
    /// <param name = "_ledger">The <c>Ledger</c> table record.</param>
    /// <param name = "_originatingRecord">The originating record the reversal process was invoked for.</param>
    /// <param name = "_revoked">true if the reversal is a revoke of a reversal; otherwise, false.</param>
    delegate void voucherReversed(
        Voucher _voucher,
        TransDate _accountingDate,
        Ledger _ledger,
        Common _originatingRecord,
        boolean _revoked)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkingLedgerPostingTypeApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for check if a transaction can be reversed.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">The <c>GeneralJournalAccountEntry</c> table source record checked for reversal.</param>
    /// <param name = "_generalJournalEntry">The <c>GeneralJournalEntry</c> table source record checked for reversal.</param>
    /// <param name = "_originatingRecord">The table record from which the process was invoked from.</param>
    /// <param name = "_eventHandlerResult">The <c>EventHandlerResult</c> class instance.</param>
    delegate void checkingLedgerPostingTypeApplicable(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry _generalJournalEntry,
        Common _originatingRecord,
        EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerPostingTypeApplicable</Name>
				<Source><![CDATA[
    boolean checkLedgerPostingTypeApplicable(Voucher   _voucher,
                                            TransDate _transDate)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        LedgerEntry ledgerEntry;
        boolean ret = true;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        SubledgerJournalEntry subledgerJournalEntry;

        while select * from subledgerVoucherLink
            where subledgerVoucherLink.Voucher == _voucher
                && subledgerVoucherLink.VoucherDataAreaId == CompanyInfo::find().DataArea
                && subledgerVoucherLink.AccountingDate == _transDate
            join * from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherLink.GeneralJournalEntry &&
                generalJournalEntry.Ledger == Ledger::current()
                join * from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    outer join * from ledgerEntry
                        where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
        {
            select firstonly RecId from subledgerJournalAccountEntry
                where subledgerJournalAccountEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                exists join * from subledgerJournalEntry
                    where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
                        && subledgerJournalEntry.Voucher == subledgerVoucherLink.Voucher
                        && subledgerJournalEntry.VoucherDataAreaId == subledgerVoucherLink.VoucherDataAreaId;
            
            if (!this.checkPostingType(generalJournalEntry, subledgerVoucherLink, generalJournalAccountEntry,
                subledgerJournalAccountEntry.RecId,
                ledgerEntry))
            {
                ret = false;
                break;
            }
        }

        if (!ret 
            && TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            return false;
        }

        EventHandlerResult eventHandlerResult = new EventHandlerResult();
        eventhandlerResult.result(ret);

        this.checkingLedgerPostingTypeApplicable(
            inputGeneralJournalAccountEntry,
            GeneralJournalEntry::find(inputGeneralJournalAccountEntry.GeneralJournalEntry),
            originatingRecord,
            eventHandlerResult);

        ret = eventHandlerResult.result();

        if (ret)
        {
            return ret;
        }
        else
        {
            if (eventHandlerResult.hasResult())
            {
                throw error(strfmt(
                    "@GeneralLedger:TransactionReversalNoReverseForAccountMessage",
                    _voucher,
                    generalJournalAccountEntry.PostingType,
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
            }

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the required number sequences are set up. If the required number sequences are not set up, this method throws an error.
    /// </summary>
    void checkNumberSequence()
    {
        NumberSequenceReference numberSequenceReference;
        NumberSequenceTable     numberSequenceTableNum;

        numberSequenceReference = LedgerParameters::numRefTraceNum();
        if (! numberSequenceReference)
        {
            throw error("@SYS53912");
        }
        numberSequenceTableNum = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

        if (!numberSequenceTableNum)
        {
            throw error(strfmt("@SYS53911",numberSequenceReference.referenceLabel(),numberSequenceReference.referenceModuleLabel()));
        }
        if (! numberSequenceTableNum.Continuous)
        {
            throw error(strfmt("@SYS78707",numberSequenceReference.referenceLabel(),numberSequenceReference.referenceModuleLabel()));
        }

        numberSequenceReference = LedgerParameters::numRefLedgerReversalVoucher();
        if (! numberSequenceReference)
        {
            throw error("@SYS53912");
        }
        numberSequenceTableNum = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

        if (!numberSequenceTableNum)
        {
            throw error(strfmt("@SYS53911",numberSequenceReference.referenceLabel(),numberSequenceReference.referenceModuleLabel()));
        }
        if (!numberSequenceTableNum.Continuous && !JournalReversalNoLongerRequiresConsecutiveNumberSequenceFeature::isEnabled())
        {
            throw error(strfmt("@SYS78707",numberSequenceReference.referenceLabel(),numberSequenceReference.referenceModuleLabel()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCheckPostingType</Name>
				<Source><![CDATA[
    delegate void onCheckPostingType(GeneralJournalAccountEntry _generalJournalAccountEntry, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean checkPostingType(
        GeneralJournalEntry _generalJournalEntry,
        SubledgerVoucherGeneralJournalEntry _subledgerVoucherLink,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        RefRecId _subledgerJournalAccountEntry,
        LedgerEntry _ledgerEntry)
    {
        boolean isValid;

        if (_generalJournalAccountEntry.PostingType == LedgerPostingType::VendBalance
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::VendPurchLedger
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::VendOffsetAccount
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::VendInterest
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::VendCashDisc
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustBalance
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustRevenue
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustInterest
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustCashDisc
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustCollectionLetterFee
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::CustInterestFee
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchAdvance
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchAdvanceApplication
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::SalesRoundOff
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::SalesFreight
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchFee
            || _generalJournalAccountEntry.PostingType == LedgerPostingType::PurchaseInvoiceRoundOff)
        {
            isValid = true;
        }

        // MODs: add delegate
        EventHandlerResult result = new EventHandlerResult();

        this.onCheckPostingType(_generalJournalAccountEntry, result);

        boolean evRes = result.result();

        if (evRes)
        {
            isValid = true;
        }
        // MODe: add delegate

        if (isValid)
        {
            isValid = _generalJournalAccountEntry.checkLedgerEntryJournalizing(true);
            isValid = _generalJournalAccountEntry.checkGeneralJournalEntryAccountingDate(_generalJournalEntry, true) && isValid;
        }
        else
        {
            isValid = _generalJournalAccountEntry.checkReversal(_generalJournalEntry, _subledgerVoucherLink, _ledgerEntry, true, true, _subledgerJournalAccountEntry);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog box can be built by using the <c>Dialog</c> class or by using a class that is created in
    ///    the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        Dialog  dialog = super();

        dialog.addText(revoke ? "@SYS78565" : "@SYS78567" );

        dialogReverseDate = dialog.addFieldValue(extendedtypestr(TransDate), minimumDate, "@SYS88950", "@SYS88805");

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeferementInfo_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates General journal lines for ledger journal posting type VAT.
    /// </summary>
    /// <param name="_generalJournalLine">
    /// Table buffer of GeneralJournalLine.
    /// </param>
    /// <param name="_taxCode">
    /// The value of taxCode.
    /// </param>
    /// <param name="_voucher">
    /// The voucher information.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// Returns a container which contains values required for posting.
    /// </returns>
    public container getDeferementInfo_IN(
        GeneralJournalAccountEntry  _generalJournalLine,
        TaxCode                     _taxCode,
        Voucher                     _voucher,
        TransDate                   _transDate)
    {
        TaxTrans                        taxTransOrig;
        TaxTrans                        taxTransPeriodic;
        TaxTrans_IN                     taxTransLocalOrig;
        TaxTrans_IN                     taxTransLocalPeriodic;
        TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
        DefermentScheduleTrans_IN       deferment;
        TaxAmount                       deferredLoc;
        TaxAmount                       payableLoc;
        TaxAmount                       tmpAmount;
        TaxAmount                       tmpAmt;
        TaxLedgerAccounts_IN            taxLedgerAccounts;
        LedgerJournalTrans              ledgerJournalTrans;
        TaxAmount                       debit;
        boolean                         post;
        ComponentTransactions_IN        settleTransLocal;
        container                       taxTransRecords;
        int                             loop;
        container                       defermentPeriodic;

        select firstonly RecId from taxTransOrig
            where taxTransOrig.Voucher          == _voucher
                && taxTransOrig.TransDate       == _transDate
                && taxTransOrig.TaxCode         == _taxCode;

        goodsType = TaxTrans_IN::findRefRecId(taxTransOrig.RecId).VATGoodsType;

        if (goodsType == VATGoodsType_IN::CapitalGoods)
        {
            loop = 1;
            while select RefRecId, RecId from taxTransLocalPeriodic
                where taxTransLocalPeriodic.TaxTransVATRefRecId   == taxTransOrig.RecId
                    && taxTransLocalPeriodic.vatDefLineTransferred == NoYes::No
            {
                select firstonly RecId from taxTransPeriodic
                    where taxTransPeriodic.RecId == taxTransLocalPeriodic.RefRecId;
                select firstonly RecoverableAmount, RecId from settleTransLocal
                    where settleTransLocal.TransRecid == taxTransPeriodic.RecId;

                debit += settleTransLocal.RecoverableAmount;
                if (settleTransLocal)
                {
                    taxTransRecords = conpoke(taxTransRecords,loop,taxTransLocalPeriodic.RecId);
                    loop++;
                }
            }

            post = false;
            deferredLoc = 0;
            payableLoc = 0;
            taxLedgerAccounts.clear();
            if (debit)
            {
                taxTransLocalOrig = TaxTrans_IN::findRefRecId(taxTransOrig.RecId);

                while select RecId from ledgerJournalTrans
                    where ledgerJournalTrans.VendTransId        == VendTrans::findVoucherDate(_voucher, _transDate).RecId
                       && ledgerJournalTrans.PurchLedgerPosting == ArrivalPostingType::None
                {
                    deferment = DefermentScheduleTrans_IN::findExtRecId(ledgerJournalTrans.RecId);
                    if (deferment.RecId)
                    {
                        break;
                    }
                }

                if (deferment.RecId && deferment.VATDefermentAmount != 0)
                {
                    tmpAmount = abs(debit);
                }
                tmpAmt      = abs(_generalJournalLine.TransactionCurrencyAmount) - tmpAmount;
                deferredLoc += tmpAmt;
                payableLoc  += tmpAmount;

                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::Table,taxTransOrig.taxTrans_W().TaxRegistrationNumberTable_IN);
                if (taxLedgerAccountSetup.RecId)
                {
                    taxLedgerAccounts = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                                TaxAccountType_IN::VATPayableAccount,
                                                                                taxTransLocalOrig.TaxComponentTable);
                }

                if (!taxLedgerAccounts)
                {
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::All);
                    taxLedgerAccounts     = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                                    TaxAccountType_IN::VATPayableAccount,
                                                                                    taxTransLocalOrig.TaxComponentTable);
                }

                post = true;
            }
        }

        if (_generalJournalLine.AccountingCurrencyAmount < 0)
        {
            defermentPeriodic = [post,-deferredLoc,-payableLoc,taxLedgerAccounts.LedgerDimension, taxTransRecords];
        }
        if (_generalJournalLine.AccountingCurrencyAmount > 0)
        {
            defermentPeriodic = [post, deferredLoc, payableLoc, taxLedgerAccounts.LedgerDimension, taxTransRecords];
        }

        return defermentPeriodic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        reversalDate = dialogReverseDate.value();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayableAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets payable account.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerDimensionAccount</c> class.
    /// </returns>
    public LedgerDimensionAccount getPayableAccount_IN(LedgerDimensionAccount _ledgerDimension,
        TaxCode                _taxCode,
        Voucher                _voucher,
        TransDate              _transDate)
    {
        TaxTrans                        taxTransOrig;
        TaxLedgerAccounts_IN            taxLedgerAccounts;
        TaxTrans_IN                     taxTransLocalOrig;
        TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
        ComponentTransactions_IN        settleTransLocal;
        TaxTransGeneralJournalAccountEntry taxLink;

        select firstonly RecId from taxTransOrig
             where taxTransOrig.Voucher         ==  _voucher
                && taxTransOrig.TransDate       == _transDate
                && taxTransOrig.TaxCode         == _taxCode
             join RecId from taxLink
                where taxLink.TaxTrans             == taxTransOrig.RecId
                   && taxLink.TaxTransRelationship == TaxTransRelationshipType::Tax
                   && taxLink.LedgerDimension      == _ledgerDimension;

        taxTransLocalOrig = TaxTrans_IN::findRefRecId(taxTransOrig.RecId);

        select firstonly RecId from settleTransLocal
            where settleTransLocal.TransRecid == taxTransOrig.RecId;
        if (settleTransLocal.RecId)
        {
            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::Table,taxTransOrig.taxTrans_W().TaxRegistrationNumberTable_IN);
            if (taxLedgerAccountSetup.RecId)
            {
                taxLedgerAccounts = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                            TaxAccountType_IN::VATPayableAccount,
                                                                            taxTransLocalOrig.TaxComponentTable);
            }

            if (!taxLedgerAccounts.RecId)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::All);
                taxLedgerAccounts     = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                                TaxAccountType_IN::VATPayableAccount,
                                                                                taxTransLocalOrig.TaxComponentTable);
            }
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.LedgerDimension, taxTransLocalOrig.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReference</Name>
				<Source><![CDATA[
    TraceNum getReference(TraceNum  _traceNum)
    {
        if (!reversalVoucher)
        {
            reversalVoucher = NumberSeq::newGetNum(LedgerParameters::numRefLedgerReversalVoucher(), false).num();
        }

        if (_traceNum)
        {
            return _traceNum;
        }
        else
        {
            return NumberSeq::newGetNum(LedgerParameters::numRefTraceNum(), false).num();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a new <see cref="T:LedgerVoucher" />, when it is implemented in a derived class.
    /// </summary>
    /// <returns>
    ///    A new <c>LedgerVoucher</c>, when this method is implemented in a derived class.
    /// </returns>
    /// <remarks>
    ///    This method must be implemented by derived classes, so that the <c>LedgerVoucher</c> is
    ///    instantiated with the correct <c>SysModule</c>, such as <c>SysModule::Cust</c>.If called directly
    ///    from this base class, this method will throw an error indicating that it must be implemented by a
    ///    derived class.
    /// </remarks>
    public LedgerVoucher initLedgerVoucher()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetCheckRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether budget funds available check is required for the transaction reversal process.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// Overrides this method to return true if a budget funds available check is required.
    /// </remarks>
    protected boolean isBudgetCheckRequired()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        taxTransRecIdMap = new Map(Types::Int64, Types::Int64);
        taxWHTransRecIdMap = new Map(Types::Int64, Types::Int64);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container contractContainer;

        if (contract)
        {
            contractContainer = contract.pack();
        }

        return [#CurrentVersion, #CurrentList, contractContainer];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the contract.  
    /// </summary>
    /// <param name = "_contract">The contract.</param>
    /// <returns>The contract.</returns>
    /// <remarks>
    /// Assigning a contract will result in the reason reference within the contract to
    /// be set and used for reversals.
    /// </remarks>
    [Hookable(false)]
    public TransactionReversalContract parmContract(TransactionReversalContract _contract = contract)
    {
        contract = _contract;

        if (contract != null)
        {
            this.reasonRefRecID = contract.parmReasonRefRecId();
        }

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversalDate</Name>
				<Source><![CDATA[
    public TransDate parmReversalDate(TransDate  _reversalDate = reversalDate)
    {
        reversalDate = _reversalDate;

        return reversalDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversalTraceNum</Name>
				<Source><![CDATA[
    public TraceNum parmReversalTraceNum(TraceNum   _traceNum = reversalTraceNum)
    {
        reversalTraceNum = _traceNum;
        return reversalTraceNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversalVoucher</Name>
				<Source><![CDATA[
    public Voucher parmReversalVoucher(Voucher   _voucher = reversalVoucher)
    {
        reversalVoucher = _voucher;
        return reversalVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRevoke</Name>
				<Source><![CDATA[
    public boolean parmRevoke(boolean _revoke = revoke)
    {
        revoke = _revoke;
        return revoke;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes the transaction reversal.
    /// </summary>
    /// <param name = "args">
    /// The arguments for the reversal.
    /// </param>
    void reversal(Args args)
    {
        this.checkNumberSequence();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a new <see cref="T:TransactionTxt" /> object, with the chance of using the specified
    ///    transaction date and voucher.
    /// </summary>
    /// <param name="_transDate">
    ///    The date to set in the <c>TransactionTxt</c> object.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher to set in the <c>TransactionTxt</c> object.
    /// </param>
    /// <param name="_formLetterNum">
    ///    The form letter number to set in the <c>TransactionTxt</c> object; optional.
    /// </param>
    /// <param name = "_key1">The first key; optional.</param>
    /// <param name = "_key2">The second key; optional.</param>
    /// <param name = "_key3">The third key; optional.</param>
    void setTransactionTxt(
        TransDate _transDate,
        Voucher _voucher,
        str 20 _formLetterNum = '',
        str 20 _key1 = '',
        str 20 _key2 = '',
        str 20 _key3 = '')
    {
        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::TransactionReversal);
        transactionTxt.setDate(_transDate);
        transactionTxt.setVoucher(_voucher);
        transactionTxt.setFormLetter(_formLetterNum);
        transactionTxt.setKey1(_key1);
        transactionTxt.setKey2(_key2);
        transactionTxt.setKey3(_key3);
        transactionTxt.setLanguage(currentUserLanguage());
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDialogPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not to skip the dialog prompt during transaction reversal.
    /// </summary>
    /// <param name = "_args"><c>Args</c> instance that should contain the same arguments that are passed to the reversal method.</param>
    /// <returns>true if the dialog prompt should be skipped; otherwise, false.</returns>
    protected boolean skipDialogPrompt(Args _args)
    {
        return TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract());

    }

]]></Source>
			</Method>
			<Method>
				<Name>submitBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits the budget funds available check.
    /// </summary>
    protected void submitBudget()
    {
        LedgerVoucherList ledgerVoucherList;
        boolean haveLedgerVoucherObject;

        if (this.isBudgetCheckRequired()
            && BudgetControlCheckRequest::isControlConfigured())
        {
            budgetControlGeneralJournalEntries = new Set(Types::Class);

            if (ledgerVoucher != null)
            {
                ledgerVoucherList = ledgerVoucher.getInternalCollection();

                if (ledgerVoucherList != null)
                {
                    haveLedgerVoucherObject = ledgerVoucherList.first();

                    while (haveLedgerVoucherObject)
                    {
                        this.submitBudgetForLedgetVoucherObject(ledgerVoucherList.item());

                        haveLedgerVoucherObject = ledgerVoucherList.next();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitBudgetForLedgetVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits the budget funds available check for a ledger voucher.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger voucher.
    /// </param>
    private void submitBudgetForLedgetVoucherObject(LedgerVoucherObject _ledgerVoucherObject)
    {
        boolean haveLedgerVoucherTransObject;
        BudgetControlGeneralJournalEntry budgetControlGeneralJournalEntry;
        LedgerVoucherTransList ledgerVoucherTransList;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_ledgerVoucherObject.isPosted()
            && BudgetControlConfiguration::existActiveForPrimaryLedger(Ledger::primaryLedger(CompanyInfo::current(_ledgerVoucherObject.parmLegalEntity()))))
        {
            // Subledger voucher is successfully posted to ledger.
            // Process the subledger voucher to perform budget check as there might be prior budget checks performed on the general journal entry being reversed.
            budgetControlGeneralJournalEntry =
                BudgetControlGeneralJournalEntry::newGeneralJournalEntry(
                    _ledgerVoucherObject.parmGeneralJournalEntryRecId(),
                    _ledgerVoucherObject.parmSubledgerVoucher());

            ledgerVoucherTransList = _ledgerVoucherObject.getInternalCollection();

            haveLedgerVoucherTransObject = ledgerVoucherTransList.first();

            while (haveLedgerVoucherTransObject)
            {
                ledgerVoucherTransObject = ledgerVoucherTransList.item();

                budgetControlGeneralJournalEntry.addLedgerDimensionDetail(
                    _ledgerVoucherObject.parmLegalEntity(),
                    ledgerVoucherTransObject.parmLedgerDimensionId(),
                    ledgerVoucherTransObject.parmTransactionCurrencyAmount(),
                    ledgerVoucherTransObject.parmTransactionCurrencyCode());

                haveLedgerVoucherTransObject = ledgerVoucherTransList.next();
            }

            budgetControlGeneralJournalEntry.saveBudgetSource();

            // Submits budget check using the submit budget server method to enhance performance.
            BudgetControlAccountingJournalProcessor::submitGeneralJournalToCheckBudgetServer(budgetControlGeneralJournalEntry);

            budgetControlGeneralJournalEntries.add(budgetControlGeneralJournalEntry);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container contractContainer;

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList, contractContainer] = _packedClass;

                contract = TransactionReversalContract::newFromExecutionId(emptyGuid());
                contract.unpack(contractContainer);

                if (contract != null)
                {
                    // if no execution id then the contract was null.  This indicates we aren't using 
                    // the mass reversal framework 
                    if (contract.parmExecutionId() == emptyGuid())
                    {
                        contract = null;
                    }
                }

                break;
            case 2 :
                [version, #CurrentList] = _packedClass;
                break;
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDefermentScheduleLinesVAT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates deferment schedule lines VAT.
    /// </summary>
    /// <param name="_deferred">
    /// The deferred.
    /// </param>
    public void updateDefermentScheduleLinesVAT_IN(TaxAmount   _deferred)
    {
        LedgerJournalTrans          ledgerJournalTransLoc;
        DefermentScheduleTrans_IN   defermentSchedule;

        if (LedgerJournalTable::find(vendTrans.JournalNum).JournalType == LedgerJournalType::Approval)
        {
            select firstonly RecId from ledgerJournalTransLoc
                where ledgerJournalTransLoc.Voucher            == vendTrans.Voucher
                    && ledgerJournalTransLoc.TransDate         ==  vendTrans.TransDate
                    && ledgerJournalTransLoc.JournalNum         == vendTrans.JournalNum
                    && ledgerJournalTransLoc.PurchLedgerPosting == ArrivalPostingType::None;
        }
        else
        {
            select firstonly RecId from ledgerJournalTransLoc
                where ledgerJournalTransLoc.Voucher == vendTrans.Voucher
                    && ledgerJournalTransLoc.TransDate ==  vendTrans.TransDate;
        }
        defermentSchedule = DefermentScheduleTrans_IN::findExtRecId(ledgerJournalTransLoc.RecId);

        if (defermentSchedule.RecId)
        {
            DefermentScheduleTransLines_IN::updateCredit(defermentSchedule,revoke,_deferred);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the original <c>TransactionReversalTrans</c> records to be either reversed or not reversed.
    /// </summary>
    /// <param name = "_transDate">
    /// The transaction date of the original transaction.
    /// </param>
    /// <param name = "_voucher">
    /// The voucher of the original transaction.
    /// </param>
    /// <param name = "_excludeSubledgerJournalTransfers">
    /// Determines if subledger transfers are excluded; optional.
    /// </param>
    [HookableAttribute(true)]
    public void updateOriginal(
        TransDate   _transDate,
        Voucher     _voucher,
        boolean     _excludeSubledgerJournalTransfers = false)
    {
        TaxTrans            taxTransLocal;
        TaxPurchaseTaxTrans taxPurchaseTaxTransLocal;
        TaxReportVoucher    taxReportVoucherLocal;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;

        while select RecId from generalJournalAccountEntry
            exists join generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && (!_excludeSubledgerJournalTransfers || generalJournalEntry.TransferId == 0)
            exists join subledgerVoucherLink
                where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherLink.AccountingDate == _transDate
                    && subledgerVoucherLink.Voucher == _voucher
        {
            TransactionReversalTrans::updateOriginal(tablenum(GeneralJournalAccountEntry), generalJournalAccountEntry.RecId, !revoke);
        }

        while select forupdate RecId from taxTransLocal
             where taxTransLocal.TransDate == _transDate
                && taxTransLocal.Voucher   == _voucher
        {
            TransactionReversalTrans::updateOriginal(tablenum(TaxTrans), taxTransLocal.RecId, !revoke);
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TaxDocumentGeneralJournalEntryLink  generalJournalEntryLink;
            TaxDocumentRowTransaction           taxDocumentRowTransaction;

            select firstOnly SourceTableName, SourceRecId from generalJournalEntryLink
                where generalJournalEntryLink.Voucher             == _voucher
                    && generalJournalEntryLink.AccountingDate     == _transDate
                exists join generalJournalEntry
                    where generalJournalEntry.RecId       == generalJournalEntryLink.GeneralJournalEntry
                        && generalJournalEntry.Ledger     == Ledger::current();
            
            if (generalJournalEntryLink)
            {
                TaxDocument taxDocument = TaxDocumentUtils::getTaxDocumentBySource(tableName2Id(generalJournalEntryLink.SourceTableName), generalJournalEntryLink.SourceRecId);
                if (taxDocument)
                {
                    taxDocument.selectForUpdate(true);
                    taxDocument.Status = TaxDocumentStatus::Reversed;
                    taxDocument.update();

                    update_recordset taxDocumentRowTransaction
                        setting TaxDocumentStatus = TaxDocumentStatus::Reversed
                        where taxDocumentRowTransaction.TransactionJourHeaderTableId    == tableName2Id(generalJournalEntryLink.SourceTableName)
                            && taxDocumentRowTransaction.TransactionJourHeaderRecId     == generalJournalEntryLink.SourceRecId;
                }
            }
        }
        // </GTE>

        while select RecId from taxPurchaseTaxTransLocal
            where taxPurchaseTaxTransLocal.TransDate == _transDate
                && taxPurchaseTaxTransLocal.Voucher   == _voucher
        {
            TransactionReversalTrans::updateOriginal(tablenum(TaxPurchaseTaxTrans), taxPurchaseTaxTransLocal.RecId, !revoke);
        }

        while select RecId from taxReportVoucherLocal
            where taxReportVoucherLocal.TransDate  == _transDate
                && taxReportVoucherLocal.Voucher   == _voucher
        {
            TransactionReversalTrans::updateOriginal(tablenum(TaxReportVoucher), taxReportVoucherLocal.RecId, !revoke);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses the tax transactions in the <c>TaxTrans</c>, <c>TaxPurchaseTaxTrans</c>, and
    ///    <c>TaxReportVoucher</c> tables with the specified voucher and transaction date.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher of the transactions to reverse.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the transactions to reverse.
    /// </param>
    [HookableAttribute(true)]
    void updateTaxTrans(Voucher     _voucher,
                        TransDate   _transDate)
    {
        #IsoCountryRegionCodes

        TaxTrans            taxTrans;
        TaxPurchaseTaxTrans taxPurchaseTaxTrans;
        TaxReportVoucher    taxReportVoucher;
        TaxTrans            taxTransLocal;
        TaxPurchaseTaxTrans taxPurchaseTaxTransLocal;
        TaxReportVoucher    taxReportVoucherLocal;
        // <GIN>
        TaxTransReversal_IN taxTransReversal;
        // </GIN>

        // <GIN>

        if (TaxParameters::checkTaxParameters_IN())
        {
            taxTransReversal = new TaxTransReversal_IN();
            taxTransReversal.init();
        }

        // </GIN>

        while select forupdate taxTrans
             where taxTrans.TransDate == _transDate
                && taxTrans.Voucher   == _voucher
        {
            taxTransLocal = this.initTaxTrans(taxTrans);
            taxTransLocal.insert();
            // <GIN>
            if (TaxParameters::checkTaxParameters_IN())
            {
                taxTransReversal.reverseByTaxTrans(taxTrans.RecId, taxTransLocal);
            }
            // </GIN>

            taxTransRecIdMap.insert(taxTrans.RecId, taxTransLocal.RecId);

            TransactionReversalTrans::createTransaction(tablenum(TaxTrans),taxTrans.RecId,reversalTraceNum);
            TransactionReversalTrans::createTransaction(tablenum(TaxTrans),taxTransLocal.RecId,reversalTraceNum);
        }

        // <GIN>
        if (TaxParameters::isExciseEnable_IN())
        {
            taxTransReversal.reverseExciseRegistration(_transDate, _voucher, reversalDate, reversalVoucher);
        }
        // </GIN>

        while select forupdate taxPurchaseTaxTrans
             where taxPurchaseTaxTrans.TransDate == _transDate
                && taxPurchaseTaxTrans.Voucher   == _voucher
        {
            taxPurchaseTaxTrans.Reversed      = true;
            taxPurchaseTaxTrans.TraceNum      = reversalTraceNum;
            taxPurchaseTaxTrans.update();

            taxPurchaseTaxTransLocal               = taxPurchaseTaxTrans.data();
            taxPurchaseTaxTransLocal.Voucher       = reversalVoucher;
            taxPurchaseTaxTransLocal.TransDate     = reversalDate;
            if (!revoke)
            {
                taxPurchaseTaxTransLocal.BaseAmountMST = taxPurchaseTaxTrans.BaseAmountMST * -1;
                taxPurchaseTaxTransLocal.TaxAmountMST  = taxPurchaseTaxTrans.TaxAmountMST * -1;
            }
            taxPurchaseTaxTransLocal.insert();

            TransactionReversalTrans::createTransaction(tablenum(TaxPurchaseTaxTrans),taxPurchaseTaxTrans.RecId,reversalTraceNum);
            TransactionReversalTrans::createTransaction(tablenum(TaxPurchaseTaxTrans),taxPurchaseTaxTransLocal.RecId,reversalTraceNum);
        }

        while select forupdate taxReportVoucher
            where taxReportVoucher.TransDate  == _transDate
                && taxReportVoucher.Voucher   == _voucher
        {
            taxReportVoucher.Reversed  = true;
            taxReportVoucher.TraceNum  = reversalTraceNum;
            taxReportVoucher.update();

            taxReportVoucherLocal           = taxReportVoucher.data();
            taxReportVoucherLocal.Voucher   = reversalVoucher;
            taxReportVoucherLocal.TransDate = reversalDate;
            taxReportVoucherLocal.Reversed  = true;
            taxReportVoucherLocal.TraceNum  = reversalTraceNum;
            taxReportVoucherLocal.insert();

            TransactionReversalTrans::createTransaction(tablenum(TaxReportVoucher),taxReportVoucher.RecId,reversalTraceNum);
            TransactionReversalTrans::createTransaction(tablenum(TaxReportVoucher),taxReportVoucherLocal.RecId,reversalTraceNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates witholding tax transaction.
    /// </summary>
    /// <param name="_voucher">
    /// Voucher number is used to find the record.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date is used to find the record.
    /// </param>
    // <GIN>
    public void updateTaxWithholdTrans_IN(Voucher     _voucher,
                                          TransDate   _transDate)
    {
        taxWHTransRecIdMap = TaxwithholdTransReverse_IN::reverseTaxWithholdTransForJournalV2(_voucher, _transDate, reversalVoucher, reversalDate, reversalTraceNum, revoke);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    // </GIN>

    public boolean validate(Object _calledFrom = null)
    {
        boolean ret;

        ret = super(_calledFrom);

        if (reversalDate < minimumDate)
        {
            ret = checkFailed(strfmt("@SYS91506", date2StrUsr(reversalDate, DateFlags::FormatAll), date2StrUsr(minimumDate, DateFlags::FormatAll)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS78542";
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>TaxTrans</c> record.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The buffer of table <c>TaxTrans</c>.
    /// </param>
    /// <returns>
    /// Returns the buffer of local table <c>TaxTrans</c>.
    /// </returns>
    protected TaxTrans initTaxTrans(TaxTrans _taxTrans)
    {
        TaxTrans taxTransLocal;

        taxTransLocal = _taxTrans.data();
        if (revoke)
        {
            taxTransLocal.copyTaxTrans(_taxTrans, 1);
        }
        else
        {
            taxTransLocal.copyTaxTrans(_taxTrans, -1);
        }
        taxTransLocal.Voucher   = reversalVoucher;
        taxTransLocal.TransDate = reversalDate;
        taxTransLocal.TaxOrigin = TaxOrigin::TaxReversed;

        return taxTransLocal;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>